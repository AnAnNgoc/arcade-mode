{
  "name": "ArcadeMode Interview Questions",
  "order": "",
  "time": "",
  "helpRoom": "",
  "challenges": [
    {
      "title": "Conventurist",
      "type": "arcade-mode",
      "categories": [
        "algorithms",
        "closures",
        "debounce",
        "throttle"
      ],
      "difficulty": "4",
      "images": "public/img/challenges/conventurist.png",
      "description": [
        "<img class='challenge__image' src='public/img/challenges/conventurist.png'>",
        "Your love of programming, games, and adventuring with friends have led you to create a simple sidescroller game that you call 'Conventurist,' a portmanteau of the 'con-' prefix meaning 'together or with,' 'adventurer,' and '-ist' suffix meaning 'person who is concerned with.' As you playtest your own creation, you note that when the character collides with another collidable object, the collision sound you added 'bmph,' plays to the tune of 'bmpbmpbmpbmpbmpbmpbmpbmpbmph.' Of course, you immediately understand the collision sound needs to be attentuated.",
        "Having done some research, you learn that throttling enforces a maximum rate-limit whereas debounce prevents a called function from being called again until a certain time has passed. You decide to add both into your game.",
        "Implement a throttle function and a debounce function such that when applied to another function, attentuates said function. For both throttle and debounce, use a corresponding delay of 200ms."
      ],
      "challengeSeed": [
        "function throttle (fn) {",
        "  // Good luck!",
        "  return true;",
        "}",
        "",
        "function debounce (fn) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function throttle (fn) {\n  const delay = 200;\n  let isThrottled = false;\n  return (...args) => {\n    if (!isThrottled) {\n      isThrottled = true;\n      setTimeout(() => {\n        isThrottled = false;\n      }, 200);\n      return fn.apply(this, args);\n    }\n    return null;\n  };\n}\n\nfunction debounce (fn) {\n  const delay = 200;\n  let isDebounced = false;\n  let debounceTimer;\n  return (...args) => {\n    if (!isDebounced) {\n      isDebounced = true;\n      return fn.apply(this, args);\n    }\n    clearTimeout(debounceTimer);\n    debounceTimer = setTimeout(() => {\n      isDebounced = false;\n    }, 200);\n    return null;\n  };\n}\n"
      ],
      "tail": [
        "function testFn () {",
        "  // function that throttle and debounce fires",
        "  return 'bmph';",
        "}",
        "",
        "function callFn (fn) {",
        "  // function that will call the throttle and debounce functions",
        "  return new Promise((resolve, reject) => {",
        "    if (typeof fn !== 'function') {",
        "      return reject('Throttle and/or debounce should return a function.');",
        "    }",
        "    const results = [];",
        "    const intervalAction = () => { results.push(fn()); };",
        "    const interval = setInterval(intervalAction, 16.7);",
        "",
        "    setTimeout(() => {",
        "      clearInterval(interval);",
        "    }, 225);",
        "",
        "    let interval2;",
        "",
        "    setTimeout(() => {",
        "      interval2 = setInterval(intervalAction, 16.7);",
        "    }, 450);",
        "",
        "    setTimeout(() => {",
        "      clearInterval(interval2);",
        "      resolve(results);",
        "    }, 500);",
        "  });",
        "}",
        "",
        "const answerThrottle = ['bmph', ...Array(12).fill(null), 'bmph', 'bmph', null, null];",
        "const answerDebounce = ['bmph', ...Array(13).fill(null), 'bmph', null, null];"
      ],
      "tests": [
        "assert(typeof throttle === 'function', 'message: <code>throttle</code> is a function.');",
        "assert(typeof debounce === 'function', 'message: <code>debounce</code> is a function.');",
        "assert(typeof throttle(testFn) === 'function', 'message: <code>throttle</code> should return a function.');",
        "assert(typeof debounce(testFn) === 'function', 'message: <code>debounce</code> should return a function.');",
        "assert.becomes(callFn(throttle(testFn)), answerThrottle, 'message: Throttle test case failed.');",
        "assert.becomes(callFn(debounce(testFn)), answerDebounce, 'message: Debounce test case failed.');"
      ],
      "id": 0
    },
    {
      "title": "Gittaca",
      "type": "arcade-mode",
      "categories": [
        "algorithms",
        "dynamic programming",
        "longest common subsequence"
      ],
      "difficulty": "8",
      "benchmark": "diff(benchmark[0], benchmark[1]);",
      "images": "public/img/challenges/pexels-photo-127556.jpeg",
      "description": [
        "<img class='challenge__image' src='public/img/challenges/pexels-photo-127556.jpeg'>",
        "With the arrival of precision genetic editing tools such as CRISPR/cas9 and the emerging field of nanoengineering, you wish to create a version control system for tracking modifications of genetic data. Instead of line-based diffing, your algorithm will be nucleotide (character) based. Knowing that most genomes are in the ballpark of billions of DNA base pairs (Gbp), diffing complete genomes cannot be completed in a reasonable amount of time or space given current technology levels. Therefore, you decide to focus on diffing genetic data at the gene level and lower in the ballpark of hundred thousands base pairs (Mbp). Since you just are just beginning, you test small strings first.",
        "Implement an algorithm that will output the diff of two provided strings",
        "Sample input",
        "diff('GTAGACA', 'GATTACA');",
        "Sample outputs (multiple answers possible)",
        "G +A T +T A -G -A C A",
        "G -T A +T +T -G A C A",
        "G -T A -G +T +T A C A"
      ],
      "challengeSeed": [
        "function diff (oldStr, newStr) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function createLCSTable (str1, str2, l1, l2) {\n  const arr = new Array(l1 + 1).fill(0).map(() => new Array(l2 + 1).fill(0));\n  for (let row = 1; row <= l1; row++) {\n    for (let col = 1; col <= l2; col++) {\n      if (str1[row - 1] === str2[col - 1]) {\n        arr[row][col] = arr[row - 1][col - 1] + 1;\n      }\n      else arr[row][col] = Math.max(arr[row - 1][col], arr[row][col - 1]);\n    }\n  }\n  return arr;\n}\n\nfunction generateDiff (oldStr, newStr, lcsTable, diffArr) {\n  const osl = oldStr.length;\n  const nsl = newStr.length;\n\n  if (osl > 0 && nsl > 0 && oldStr[osl - 1] === newStr[nsl - 1]) {\n    diffArr.unshift(oldStr[osl - 1]);\n    generateDiff(oldStr.slice(0, -1), newStr.slice(0, -1), lcsTable, diffArr);\n  }\n  else if (nsl > 0 && (osl === 0 || lcsTable[osl][nsl - 1] >= lcsTable[osl - 1][nsl])) {\n    diffArr.unshift(`+${newStr[nsl - 1]}`);\n    generateDiff(oldStr, newStr.slice(0, -1), lcsTable, diffArr);\n  }\n  else if (osl > 0 && (nsl === 0 || lcsTable[osl][nsl - 1] < lcsTable[osl - 1][nsl])) {\n    diffArr.unshift(`-${oldStr[osl - 1]}`);\n    generateDiff(oldStr.slice(0, -1), newStr, lcsTable, diffArr);\n  }\n}\n\nfunction diff (oldStr, newStr) {\n  const lcsTable = createLCSTable(oldStr, newStr, oldStr.length, newStr.length);\n  const diffArr = [];\n  generateDiff(oldStr, newStr, lcsTable, diffArr);\n\n  return diffArr.join(' ');\n}\n"
      ],
      "naive": "function getLCS (X, Y, m, n) {\n  const arr = [];\n  for (let i = 0; i < 2 ** m; i++) {\n    const strArr = [];\n    let bits = i.toString(2);\n    const bitLength = ((2 ** m) - 1).toString(2).length;\n    while (bits.length < bitLength) {\n      bits = `0${bits}`;\n    }\n    for (let j = 0; j < m; j++) {\n      if (bits[j] === '0') {\n        strArr.push(X[j]);\n      }\n    }\n    arr.push(strArr.join(''));\n  }\n\n  return arr;\n}\n\nfunction generateDiff (o, n, l) {\n  const arr = [];\n  let i = 0;\n  let j = 0;\n\n  while (i < l.length) {\n    while (j < o.length) {\n      if (l[i] === o[j]) {\n        arr.push(o[j]);\n        i++;\n      }\n      else arr.push(`-${o[j]}`);\n      j++;\n    }\n  }\n\n  const finalArr = [];\n  for (let a = 0, b = 0; b < n.length;) {\n    if (arr[a] !== undefined && arr[a].length !== 1) {\n      finalArr.push(arr[a]); // push in the -\n      a++;\n    }\n    else if (arr[a] === n[b]) { // push in same\n      finalArr.push(n[b]);\n      b++;\n      a++;\n    }\n    else {\n      finalArr.push(`+${n[b]}`);\n      b++;\n    }\n  }\n\n  return finalArr;\n}\n\nfunction diff (oldStr, newStr) {\n  let longestSubsequence = '';\n  const LCS = getLCS(oldStr, newStr, oldStr.length, newStr.length);\n  for (let i = 0; i < LCS.length; i++) {\n    if (newStr.indexOf(LCS[i]) >= 0) {\n      if (LCS[i].length > longestSubsequence.length) {\n        longestSubsequence = LCS[i];\n      }\n    }\n  }\n\n  const result = generateDiff(oldStr, newStr, longestSubsequence);\n\n  return result.join(' ');\n}\n",
      "tail": [
        "const testCase1 = ['GTTG', 'GTTAC'];",
        "const tc1Answers = [['G', 'T', 'T', '+A', '+C', '-G'], ['G', 'T', 'T', '-G', '+A', '+C']].map(arr => arr.join(' '));",
        "const testCase2 = ['ATCGTGT', 'AGTGCAGC'];",
        "const tc2Answers = [",
        "  ['A', '-T', '-C', 'G', 'T', 'G', '-T', '+C', '+A', '+G', '+C'],",
        "  ['A', '-T', '-C', 'G', 'T', 'G', '+C', '+A', '+G', '+C', '-T']",
        "].map(arr => arr.join(' '));",
        "const benchmark = [",
        "  'TGTAGAAGCGTGGC',",
        "  'TCGATAGTAGAGT'",
        "];"
      ],
      "tests": [
        "assert(typeof diff === 'function', 'message: <code>diff</code> is a function.');",
        "assert.include(tc1Answers, diff(testCase1[0], testCase1[1]), 'message: diff(\"GTTG\", \"GTTAC\") should return either \"G T T +A +C -G\" or \"G T T -G +A +C\"');",
        "assert.include(tc2Answers, diff(testCase2[0], testCase2[1]), 'message: diff(\"ATCGTGT\", \"AGTGCAGC\") should return either \"A -T -C G T G -T +C +A +G +C\" or \"A -T -C G T G +C +A +G +C -T\"');"
      ],
      "id": 0
    },
    {
      "title": "LRU Cache",
      "type": "arcade-mode",
      "description": [
        "Least-recently used (LRU) is a policy which evicts (removes) the item which was least-recently used in the cache. A cache is a lookup table (for example hash table) having constant-time complexity for getting and setting data.",
        "In this challenge, you need to implement a cache with LRU eviction policy. The capacity of the cache is not known beforehand, so your solution must take that into account."
      ],
      "challengeSeed": [
        "function LRUCache(capacity) {",
        "  // Good luck!",
        "",
        "  this.get = function(key) {",
        "    // Insert your solution here",
        "  };",
        "",
        "  this.set = function(key, data) {",
        "    // Insert your solution here",
        "  };",
        "}"
      ],
      "solutions": [
        "function LRUCache(capacity) {\n  const hashTable = {};\n  const lruList = [];\n\n  this.get = function(key) {\n    if (hashTable[key]) {\n      const index = lruList.indexOf(key);\n      lruList.splice(index, 1);\n      lruList.push(key);\n      return hashTable[key];\n    }\n    return null;\n  };\n\n  /* Sets an item into the cache. */\n  this.set = function(key, data) {\n    hashTable[key] = data;\n    const index = lruList.indexOf(key);\n    if (index === -1) {\n      if (lruList.length === capacity) {\n        const evictedKey = lruList.shift(); // Evict LRU data\n        delete hashTable[evictedKey];\n      }\n      lruList.push(key);\n    }\n    else { // Move to the front of the list\n      lruList.splice(index, 1);\n      lruList.push(key);\n    }\n  };\n}\n"
      ],
      "tail": [
        "const c1 = new LRUCache(4);",
        "c1.set('abcde', { a: 'ccc' });",
        "",
        "const c2 = new LRUCache(2);",
        "c2.set('aaa', 10); c2.set('bbb', 11); c2.set('ccc', 12);",
        "",
        "const c3 = new LRUCache(2);",
        "c3.set('aaa', 10); c3.set('bbb', 11); c3.get('aaa'); c3.set('ccc', 80);"
      ],
      "tests": [
        "assert(c1.get('xav') === null, 'Cache miss returns null');",
        "assert(c1.get('abcde').a === 'ccc', 'Should return the cache object');",
        "assert(c2.get('aaa') === null, 'Item should be already evicted.');",
        "assert(c2.get('ccc') === 12, 'Item should be still cached.');",
        "assert(c3.get('bbb') === null, 'The item should be evicted.');",
        "assert(c3.get('ccc') === 80, 'The item should be evicted.');"
      ],
      "id": 0
    },
    {
      "title": "Petch",
      "type": "arcade-mode",
      "categories": [
        "algorithms",
        "xor",
        "encryption",
        "bit manipulation"
      ],
      "difficulty": "2",
      "images": "public/img/challenges/petch.png",
      "description": [
        "<img class='challenge__image' src='public/img/challenges/petch.png'>",
        "Despite what others say, you and Petch were the best of friends in childhood long before she became famous. In fact during that last summer before she moved away, you two were especially fond of solving cryptography puzzles after finding out about them one day from a magazine at the local market. Among the topics learned, you two learned of the XOR (exclusive-or) function which only outputs true when both inputs are different. In a table concerning bits, it would look like this.",
        "Input Output",
        "A B",
        "0 0     0",
        "0 1     1",
        "1 0     1",
        "1 1     0",
        "Accompanying the XOR function description was a 6-bit abbreviated ASCII set. ",
        " !\"#$%&'()*+,-./0123456789:;=?@[\\]^_abcdefghijklmnopqrstuvwxyz|~",
        "With the corresponding numbering in decimal,",
        "  ! \" ...",
        "0 1 2 ...",
        "And in binary,",
        "   0 000000",
        "!  1 000001",
        "\"  2 000010",
        "...",
        "z 61 111101",
        "| 62 111110",
        "~ 63 111111",
        "You both also learned of the one-time pad, an uncrackable encryption technique that uses a one-time pre-shared key the same or longer than the message being sent. You two were inseparable.",
        "There then came a day when you found out. She had to move because her father had to relocate for work. You both knew what this meant. A few days before she left, she handed you a one-time pad. \"In case anything happens,\" she said with a smirk on her face. \"In case,\" you replied with a grin across yours.",
        "Fast forward to the present, you found out a few years ago that Petch has become a famous singer with millions of Twitter followers. Thinking that she may have long forgotten about you, you decide to anonymously follow her on Twitter, once in a while checking to see how her life is evolving.",
        "Then one day it happened. You saw the string of seemingly random characters in her most recent tweet. You knew beyond a doubt it was directed to you. You need to deciper her message.",
        "Implement a function that uses the XOR cipher to encrypt/decrypt messages when provided with a key and message."
      ],
      "challengeSeed": [
        "const characterSet = ` !\"#$%&'()*+,-./0123456789:;=?@[\\\\]^_abcdefghijklmnopqrstuvwxyz|~`;",
        "",
        "const OTP = `;'z@qxkw]0i\"'8]mn64'y.x2*@xj87zy]k:xf\"!p,!e(-xuar%!19#[t,@ &n r cido3j7( w_^$8^hyj1#d[rt.8_/4(1)]_c.l.75[r-mt]%8n$2[:y\"7,:j:9)c_/\"?l?u3pwbgt`;",
        "",
        "const petchMsg = `h_(^&tk667:\"tm]#9]oio.75w@7=8\\\\(.9+r3e\"a&|x@\\\\ux3 #%srthktys n# @i0i!6b:u\\\\!`;",
        "",
        "function XOR (key, msg) {",
        "  // Good luck!",
        "}",
        "// Run the following to get user output:",
        "// XOR(OTP, petchMsg);"
      ],
      "solutions": [
        "const characterSet = ` !\"#$%&'()*+,-./0123456789:;=?@[\\\\]^_abcdefghijklmnopqrstuvwxyz|~`;\nconst OTP = `;'z@qxkw]0i\"'8]mn64'y.x2*@xj87zy]k:xf\"!p,!e(-xuar%!19#[t,@ &n r cido3j7( w_^$8^hyj1#d[rt.8_/4(1)]_c.l.75[r-mt]%8n$2[:y\"7,:j:9)c_/\"?l?u3pwbgt`;\nconst petchMsg = `h_(^&tk667:\"tm]#9]oio.75w@7=8\\\\(.9+r3e\"a&|x@\\\\ux3 #%srthktys n# @i0i!6b:u\\\\!`;\nfunction XOR (key, msg) {\n  let totalKey = key;\n  while (msg.length > totalKey.length) {\n    totalKey = key.concat(key);\n  }\n  return [...msg].map((ch, i) => {\n    return characterSet[characterSet.indexOf(ch) ^ characterSet.indexOf(totalKey[i])]\n  }).join('');\n}\n\n// XOR(OTP, petchMsg);\n"
      ],
      "tail": [
        "const encryptedMsg = '';",
        "const decipheredMsg = '';"
      ],
      "tests": [
        "assert(typeof XOR === 'function', 'message: <code>XOR</code> is a function.');",
        "assert(XOR(OTP, encryptedMsg) === decipheredMsg, 'message: <code>XOR</code> did not produce the right message.');"
      ],
      "id": 0
    },
    {
      "title": "Queue using two stacks",
      "type": "arcade-mode",
      "difficulty": "2",
      "categories": "data structures",
      "description": [
        "A queue is  a data structure with FIFO (first-in first-out) properties. Elements are removed in the same order as they are inserted. In this challenge, you need to implement Queue class using two Stack data structures.",
        "Implement a Queue class with two methods: enqueue() which inserts an element into a queue and dequeue() which removes an element in an insertion order."
      ],
      "head": [
        "function Stack() {",
        "  this.list = [];",
        "",
        "  this.size = function() {",
        "    return this.list.length;",
        "  };",
        "",
        "  this.pop = function() {",
        "    return this.list.pop();",
        "  };",
        "",
        "  this.push = function(elem) {",
        "    return this.list.push(elem);",
        "  };",
        "}"
      ],
      "challengeSeed": [
        "",
        "// You have the following data structure available",
        "// Stack:",
        "//    push(elem): Push new element to the top",
        "//    pop():  Remove and return the top element",
        "//    size(): Return the number of elements in Stack",
        "//",
        "// Don't declare any other variables or use arrays!",
        "// Good luck!",
        "",
        "function Queue () {",
        "  this.s1 = new Stack();",
        "  this.s2 = new Stack();",
        "",
        "  this.enqueue = function(elem) {",
        "    // Your solution",
        "  };",
        "",
        "  this.dequeue = function() {",
        "    // Your solution",
        "  };",
        "}"
      ],
      "solutions": [
        "function Queue () {\n  this.s1 = new Stack();\n  this.s2 = new Stack();\n\n  this.enqueue = function(elem) {\n    this.s1.push(elem);\n  };\n\n  this.dequeue = function() {\n    if (this.s2.size() > 0) {\n      return this.s2.pop();\n    }\n    while (this.s1.size() > 0) {\n      this.s2.push(this.s1.pop());\n    }\n    return this.s2.pop();\n  };\n}\n"
      ],
      "tail": [
        "const q = new Queue();",
        "q.enqueue(1); q.enqueue(2); q.enqueue(3);",
        "",
        "const q2 = new Queue();",
        "[1, 2, 3, 4, 5, 6].forEach(num => q2.enqueue(num));",
        "q2.dequeue(); q2.dequeue(); q2.dequeue(); q2.dequeue();",
        "[7, 8, 9, 10].forEach(num => q2.enqueue(num));",
        "",
        "const q3 = new Queue();",
        "q3.enqueue(1); q3.enqueue(2); q3.dequeue(); q3.dequeue();",
        "q3.enqueue('aaa'); q3.enqueue('bbb');"
      ],
      "tests": [
        "assert(typeof Queue === 'function', 'message: Queue must be a constructor function.');",
        "assert(q.dequeue() === 1, 'message: 1 is dequeued correctly');",
        "assert(q2.dequeue() === 5, 'message: 5 is dequeued correctly');",
        "assert(q3.dequeue() === 'aaa', 'message: aaa is dequeued correctly');"
      ],
      "id": 0
    },
    {
      "title": "Bookshop in Rome",
      "type": "arcade-mode",
      "catgories": [
        "algorithms",
        "sorting"
      ],
      "difficulty": "5",
      "images": "public/img/challenges/pexels-photo-358717.jpeg",
      "description": [
        "<img class='challenge__image' src='public/img/challenges/pexels-photo-358717.jpeg'>",
        "On your last day of vacation, a quaint used bookstore catches your eye on one of the smaller streets of Rome. \"Perhaps this bookstore will have that out of print book I have been looking for all these years,\" you think to yourself. As you walk inside, you note the large pile of books in the back of the store and the sparsely-furnished bookshelves throughout. The shopkeep, a thin elderly man with combed back white hair and spectacles, seems to be deep in the process of organizing one of the bookshelves. You browse each aisle with ease due to the sparseness, but also because of your familiarity with the cover design of the book. It is then that you finally notice it on the bookshelf with other aged books. \"They have it!\" you think estatically. Of course, you made sure multiple times.",
        "As you approach the shopkeep to purchase the book, he becomes visibly startled at your presence. \"Goodness! I thought I had locked the door. I apologize, but due to the recent earthquake most of the books need to be resorted before I can reopen the store.\"",
        "Noting the book you have in your hand, he continues. \"That's quite the rare book. I can offer it to you if you help me sort through all the books here. I cannot sell it for anything else at this point.\"",
        "Understanding that your flight is tomorrow, you only have today to sort through all the books. Luckily for you, you know a few sorting algorithms. You accept the shopkeep's offer.",
        "Given an array of book author last names, sort the books without using Array.prototype.sort()."
      ],
      "head": [
        "// Set Array.prototype.sort to null, prevents user from using it",
        "Array.prototype.sort = undefined;"
      ],
      "challengeSeed": [
        "function sortBooks (arr) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function sortBooks (arr) {\n  if (arr.length > 1) {\n    // quick sort implementation\n    const pivot = arr[Math.floor(arr.length / 2)]; // use approx middle element as pivot\n    let leftIndex = 0;\n    let rightIndex = arr.length - 1;\n    while (leftIndex < rightIndex) {\n      if (arr[leftIndex] >= pivot) {\n        if (arr[rightIndex] <= pivot) {\n          [arr[leftIndex], arr[rightIndex]] = [arr[rightIndex], arr[leftIndex]]; // swap\n          leftIndex++;\n        }\n        rightIndex--;\n      }\n      else leftIndex++;\n    }\n\n    const rightHalf = arr.splice(leftIndex);\n    const leftHalf = arr;\n\n    Array.prototype.push.apply(sortBooks(leftHalf), sortBooks(rightHalf));\n  }\n\n  return arr;\n}\n"
      ],
      "tail": [
        "const userProvidedArr = ['Rossi', 'Russo', 'Ferrarri', 'Esposito', 'Bianchi', 'Romano', 'Columbo'];",
        "const unmodifiedArr = ['Rossi', 'Russo', 'Ferrarri', 'Esposito', 'Bianchi', 'Romano', 'Columbo'];",
        "function isSorted (arr) {",
        "  const check = i => (i === arr.length - 1) ? true : (arr[i] > arr[i + 1]) ? false : check(i + 1);",
        "  return check(0);",
        "}"
      ],
      "tests": [
        "assert(typeof sortBooks === 'function', 'message: <code>sortBooks</code> is a function.');",
        "assert(isSorted(sortBooks(userProvidedArr)), 'message: <code>sortBooks</code> returns a sorted array.');",
        "assert.sameMembers(sortBooks(userProvidedArr), unmodifiedArr, 'message: <code>sortBooks</code> returns an array that is unchanged except for order.');",
        "assert.strictEqual(code.search(/\\.sort\\(/), -1, 'message: <code>sortBooks</code> should not use the built-in <code>.sort()</code> method.');"
      ],
      "id": 0
    }
  ]
}