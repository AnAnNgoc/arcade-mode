{
  "name": "ArcadeMode Interview Questions",
  "order": "",
  "time": "",
  "helpRoom": "",
  "challenges": [
    {
      "title": "Gittaca",
      "type": "arcade-mode",
      "categories": [
        "algorithms",
        "dynamic programming",
        "longest common subsequence"
      ],
      "difficulty": "8",
      "benchmark": "diff(benchmark[0], benchmark[1]);",
      "images": "public/img/challenges/pexels-photo-127556.jpeg",
      "description": [
        "<img class='challenge__image' src='public/img/challenges/pexels-photo-127556.jpeg'>",
        "With the arrival of precision genetic editing tools such as CRISPR/cas9 and the emerging field of nanoengineering, you wish to create a version control system for tracking modifications of genetic data. Instead of line-based diffing, your algorithm will be nucleotide (character) based. Knowing that most genomes are in the ballpark of billions of DNA base pairs (Gbp), diffing complete genomes cannot be completed in a reasonable amount of time or space given current technology levels. Therefore, you decide to focus on diffing genetic data at the gene level and lower in the ballpark of hundred thousands base pairs (Mbp). Since you just are just beginning, you test small strings first.",
        "Implement an algorithm that will output the diff of two provided strings",
        "Sample input",
        "diff('GTAGACA', 'GATTACA');",
        "Sample outputs (multiple answers possible)",
        "G +A T +T A -G -A C A",
        "G -T A +T +T -G A C A",
        "G -T A -G +T +T A C A"
      ],
      "challengeSeed": [
        "function diff (oldStr, newStr) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function createLCSTable (str1, str2, l1, l2) {\n  const arr = new Array(l1 + 1).fill(0).map(() => new Array(l2 + 1).fill(0));\n  for (let row = 1; row <= l1; row++) {\n    for (let col = 1; col <= l2; col++) {\n      if (str1[row - 1] === str2[col - 1]) {\n        arr[row][col] = arr[row - 1][col - 1] + 1;\n      }\n      else arr[row][col] = Math.max(arr[row - 1][col], arr[row][col - 1]);\n    }\n  }\n  return arr;\n}\n\nfunction generateDiff (oldStr, newStr, lcsTable, diffArr) {\n  const osl = oldStr.length;\n  const nsl = newStr.length;\n\n  if (osl > 0 && nsl > 0 && oldStr[osl - 1] === newStr[nsl - 1]) {\n    diffArr.unshift(oldStr[osl - 1]);\n    generateDiff(oldStr.slice(0, -1), newStr.slice(0, -1), lcsTable, diffArr);\n  }\n  else if (nsl > 0 && (osl === 0 || lcsTable[osl][nsl - 1] >= lcsTable[osl - 1][nsl])) {\n    diffArr.unshift(`+${newStr[nsl - 1]}`);\n    generateDiff(oldStr, newStr.slice(0, -1), lcsTable, diffArr);\n  }\n  else if (osl > 0 && (nsl === 0 || lcsTable[osl][nsl - 1] < lcsTable[osl - 1][nsl])) {\n    diffArr.unshift(`-${oldStr[osl - 1]}`);\n    generateDiff(oldStr.slice(0, -1), newStr, lcsTable, diffArr);\n  }\n}\n\nfunction diff (oldStr, newStr) {\n  const lcsTable = createLCSTable(oldStr, newStr, oldStr.length, newStr.length);\n  const diffArr = [];\n  generateDiff(oldStr, newStr, lcsTable, diffArr);\n\n  return diffArr.join(' ');\n}\n"
      ],
      "tail": [
        "const testCase1 = ['GTTG', 'GTTAC'];",
        "const tc1Answers = [['G', 'T', 'T', '+A', '+C', '-G'], ['G', 'T', 'T', '-G', '+A', '+C']].map(arr => arr.join(' '));",
        "const testCase2 = ['AACAGTGT', 'AGTGCAGC'];",
        "const tc2Answers = [",
        "  ['A', '-A', '-C', '-A', 'G', 'T', 'G', '-T', '+C', '+A', '+G', '+C'],",
        "  ['A', '-A', '-C', '-A', 'G', 'T', 'G', '+C', '+A', '+G', '+C', '-T']",
        "].map(arr => arr.join(' '));",
        "const benchmark = [",
        "  'TGTAGAAGTGTCAGCATCGATCGGTCCAATCGACAAATAAAGGTTTCAACACTGTTCTCTTAGGAATCGGTGGGCGATTAGAGCGTGGC',",
        "  'TCGATTCAAAATTGCCCTCCATAGGTAGACACATTATATCGATCGTGGTGCGTTGCCTAGTGTCACATCATAGGTAATTGCAGTAGAGT'",
        "];"
      ],
      "tests": [
        "assert(typeof diff === 'function', 'message: <code>diff</code> is a function.');",
        "assert.include(tc1Answers, diff(testCase1[0], testCase1[1]), 'message: diff(\"GTTG\", \"GTTAC\") should return either \"G T T +A +C -G\" or \"G T T -G +A +C\"');",
        "assert.include(tc2Answers, diff(testCase2[0], testCase2[1]), 'message: diff(\"AACAGTGT\", \"AGTGCAGC\") should return either \"A -A -C -A G T G -T +C +A +G +C\" or \"A -A -C -A G T G +C +A +G +C -T\"');"
      ],
      "id": 0
    },
    {
      "title": "Queue using two stacks",
      "type": "arcade-mode",
      "difficulty": "2",
      "categories": "data structures",
      "description": [
        "A queue is  a data structure with FIFO (first-in first-out) properties. Elements are removed in the same order as they are inserted. In this challenge, you need to implement Queue class using two Stack data structures.",
        "Implement a Queue class with two methods: enqueue() which inserts an element into a queue and dequeue() which removes an element in an insertion order."
      ],
      "head": [
        "function Stack() {",
        "  this.list = [];",
        "",
        "  this.size = function() {",
        "    return this.list.length;",
        "  };",
        "",
        "  this.pop = function() {",
        "    return this.list.pop();",
        "  };",
        "",
        "  this.push = function(elem) {",
        "    return this.list.push(elem);",
        "  };",
        "}"
      ],
      "challengeSeed": [
        "",
        "// You have the following data structure available",
        "// Stack:",
        "//    push(elem): Push new element to the top",
        "//    pop():  Remove and return the top element",
        "//    size(): Return the number of elements in Stack",
        "//",
        "// Don't declare any other variables or use arrays!",
        "// Good luck!",
        "",
        "function Queue () {",
        "  this.s1 = new Stack();",
        "  this.s2 = new Stack();",
        "",
        "  this.enqueue = function(elem) {",
        "    // Your solution",
        "  };",
        "",
        "  this.dequeue = function() {",
        "    // Your solution",
        "  };",
        "}"
      ],
      "solutions": [
        "function Queue () {\n  this.s1 = new Stack();\n  this.s2 = new Stack();\n\n  this.enqueue = function(elem) {\n    this.s1.push(elem);\n  };\n\n  this.dequeue = function() {\n    if (this.s2.size() > 0) {\n      return this.s2.pop();\n    }\n    while (this.s1.size() > 0) {\n      this.s2.push(this.s1.pop());\n    }\n    return this.s2.pop();\n  };\n}\n"
      ],
      "tail": [
        "const q = new Queue();",
        "q.enqueue(1); q.enqueue(2); q.enqueue(3);",
        "",
        "const q2 = new Queue();",
        "[1, 2, 3, 4, 5, 6].forEach(num => q2.enqueue(num));",
        "q2.dequeue(); q2.dequeue(); q2.dequeue(); q2.dequeue();",
        "[7, 8, 9, 10].forEach(num => q2.enqueue(num));",
        "",
        "const q3 = new Queue();",
        "q3.enqueue(1); q3.enqueue(2); q3.dequeue(); q3.dequeue();",
        "q3.enqueue('aaa'); q3.enqueue('bbb');"
      ],
      "tests": [
        "assert(typeof Queue === 'function', 'message: Queue must be a constructor function.');",
        "assert(q.dequeue() === 1, 'message: 1 is dequeued correctly');",
        "assert(q2.dequeue() === 5, 'message: 5 is dequeued correctly');",
        "assert(q3.dequeue() === 'aaa', 'message: aaa is dequeued correctly');",
        ""
      ],
      "id": 0
    },
    {
      "title": "Bookshop in Rome",
      "type": "arcade-mode",
      "catgories": [
        "algorithms",
        "sorting"
      ],
      "difficulty": "5",
      "images": "public/img/challenges/pexels-photo-358717.jpeg",
      "description": [
        "<img class='challenge__image' src='public/img/challenges/pexels-photo-358717.jpeg'>",
        "On your last day of vacation, a quaint used bookstore catches your eye on one of the smaller streets of Rome. \"Perhaps this bookstore will have that out of print book I have been looking for all these years,\" you think to yourself. As you walk inside, you note the large pile of books in the back of the store and the sparsely-furnished bookshelves throughout. The shopkeep, a thin elderly man with combed back white hair and spectacles, seems to be deep in the process of organizing one of the bookshelves. You browse each aisle with ease due to the sparseness, but also because of your familiarity with the cover design of the book. It is then that you finally notice it on the bookshelf with other aged books. \"They have it!\" you think estatically. Of course, you made sure multiple times.",
        "As you approach the shopkeep to purchase the book, he becomes visibly startled at your presence. \"Goodness! I thought I had locked the door. I apologize, but due to the recent earthquake most of the books need to be resorted before I can reopen the store.\"",
        "Noting the book you have in your hand, he continues. \"That's quite the rare book. I can offer it to you if you help me sort through all the books here. I cannot sell it for anything else at this point.\"",
        "Understanding that your flight is tomorrow, you only have today to sort through all the books. Luckily for you, you know a few sorting algorithms. You accept the shopkeep's offer.",
        "Given an array of book author last names, sort the books without using Array.prototype.sort()."
      ],
      "head": [
        "// Set Array.prototype.sort to null, prevents user from using it",
        "Array.prototype.sort = undefined;"
      ],
      "challengeSeed": [
        "function sortBooks (arr) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function sortBooks (arr) {\n  if (arr.length > 1) {\n    // quick sort implementation\n    const pivot = arr[Math.floor(arr.length / 2)]; // use approx middle element as pivot\n    let leftIndex = 0;\n    let rightIndex = arr.length - 1;\n    while (leftIndex < rightIndex) {\n      if (arr[leftIndex] >= pivot) {\n        if (arr[rightIndex] <= pivot) {\n          [arr[leftIndex], arr[rightIndex]] = [arr[rightIndex], arr[leftIndex]]; // swap\n          leftIndex++;\n        }\n        rightIndex--;\n      }\n      else leftIndex++;\n    }\n\n    const rightHalf = arr.splice(leftIndex);\n    const leftHalf = arr;\n\n    Array.prototype.push.apply(sortBooks(leftHalf), sortBooks(rightHalf));\n  }\n\n  return arr;\n}\n"
      ],
      "tail": [
        "const userProvidedArr = ['Rossi', 'Russo', 'Ferrarri', 'Esposito', 'Bianchi', 'Romano', 'Columbo'];",
        "const unmodifiedArr = ['Rossi', 'Russo', 'Ferrarri', 'Esposito', 'Bianchi', 'Romano', 'Columbo'];",
        "function isSorted (arr) {",
        "  const check = i => (i === arr.length - 1) ? true : (arr[i] > arr[i + 1]) ? false : check(i + 1);",
        "  return check(0);",
        "}"
      ],
      "tests": [
        "assert(typeof sortBooks === 'function', 'message: <code>sortBooks</code> is a function.');",
        "assert(isSorted(sortBooks(userProvidedArr)), 'message: <code>sortBooks</code> returns a sorted array.');",
        "assert.sameMembers(sortBooks(userProvidedArr), unmodifiedArr, 'message: <code>sortBooks</code> returns an array that is unchanged except for order.');",
        "assert.strictEqual(code.search(/\\.sort\\(/), -1, 'message: <code>sortBooks</code> should not use the built-in <code>.sort()</code> method.');"
      ],
      "id": 0
    }
  ]
}