{
  "name": "ArcadeMode Interview Questions",
  "order": "",
  "time": "",
  "helpRoom": "",
  "challenges": [
    {
      "title": "100 doors",
      "type": "rosetta-code",
      "categories": "?",
      "difficulty": "2",
      "benchmark": "getFinalOpenedDoors(10000);",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">There are 100 doors in a row that are all initially closed. You make 100 passes by the doors. The first time through, visit every door and 'toggle' the door (if the door is closed, open it; if it is open, close it). The second time, only visit every 2nd door (i.e., door #2, #4, #6, ...) and toggle it. The third time, visit every 3rd door (i.e., door #3, #6, #9, ...), etc., until you only visit the 100th door.</p><br/>",
        "<p class=\"rosetta__paragraph\">Implement a function to determine the state of the doors after the last pass. Return the final result in an array, with only the door number included in the array if it is open.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function getFinalOpenedDoors (numDoors) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function getFinalOpenedDoors (numDoors) {\n  // this is the final pattern (always squares).\n  // thus, the most efficient solution simply returns an array of squares up to numDoors).\n  const finalState = [];\n  let i = 1;\n  while (Math.pow(i, 2) <= numDoors) {\n    finalState.push(Math.pow(i, 2));\n    i++;\n  }\n  return finalState;\n}\n"
      ],
      "naive": "function getFinalOpenedDoors (numDoors) {\n  const doors = [];\n  const openedDoors = [];\n  for (let i = 0; i < numDoors; i++) {\n    doors[i] = false; // create doors\n  }\n  for (let i = 1; i <= numDoors; i++) {\n    for (let i2 = i - 1; i2 < numDoors; i2 += i) {\n      doors[i2] = !doors[i2]; // toggle doors\n    }\n  }\n  for (let i = 0; i < numDoors; i++) {\n    if (doors[i]) {\n      openedDoors.push(i + 1);\n    }\n  }\n\n  return openedDoors;\n}\n",
      "tail": "const solution = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100];",
      "tests": [
        "assert(typeof getFinalOpenedDoors === 'function', 'message: <code>getFinalOpenedDoors</code> is a function.');",
        "assert(Array.isArray(getFinalOpenedDoors(100)), 'message: <code>getFinalOpenedDoors</code> should return an array.');",
        "assert.deepEqual(getFinalOpenedDoors(100), solution, 'message: <code>getFinalOpenedDoors</code> did not produce the correct results.');"
      ],
      "id": "594810f028c0303b75339acb"
    },
    {
      "title": "24 game",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "5",
      "benchmark": "// solve24('1234');",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Implement a function that takes a string of four digits as its argument, with each digit from 1 ──► 9 (inclusive) with repetitions allowed, and returns an arithmetic expression that evaluates to the number 24. If no such solution exists, return \"no solution exists.\"</p><br/>",
        "<p class=\"rosetta__paragraph\">Rules:</p>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\"> Only the following operators/functions are allowed: multiplication, division, addition, subtraction</li>",
        "<li class=\"rosetta__list-item--unordered\"> Division should use floating point or rational arithmetic, etc, to preserve remainders.</li>",
        "<li class=\"rosetta__list-item--unordered\"> Forming multiple digit numbers from the supplied digits is <span class=\"rosetta__text--italic\">disallowed</span>. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).</li>",
        "<li class=\"rosetta__list-item--unordered\"> The order of the digits when given does not have to be preserved.</li>",
        "</ul><br/>",
        "<p class=\"rosetta__paragraph\">Example inputs:</p>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\"><code>solve24(\"4878\");</code></li>",
        "<li class=\"rosetta__list-item--unordered\"><code>solve24(\"1234\");</code></li>",
        "<li class=\"rosetta__list-item--unordered\"><code>solve24(\"6789\");</code></li>",
        "<li class=\"rosetta__list-item--unordered\"><code>solve24(\"1127\");</code></li>",
        "</ul><br/>",
        "<p class=\"rosetta__paragraph\">Example outputs (strings):</p>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\"><code>(7-8/8)*4</code></li>",
        "<li class=\"rosetta__list-item--unordered\"><code>3*1*4*2</code></li>",
        "<li class=\"rosetta__list-item--unordered\"><code>(6*8)/(9-7)</code></li>",
        "<li class=\"rosetta__list-item--unordered\"><code>(1+7)*(2+1)</code></li>",
        "</ul>",
        "</div>"
      ],
      "challengeSeed": [
        "function solve24 (numStr) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "// noprotect\n\nfunction solve24 (numStr) {\n  const digitsArr = numStr.split('');\n  const answers = [];\n\n  const digitPermutations = [];\n  const operatorPermutations = [];\n\n  function generateDigitPermutations (digits, permutations = []) {\n    if (digits.length === 0) {\n      digitPermutations.push(permutations);\n    }\n    else {\n      for (let i = 0; i < digits.length; i++) {\n        const curr = digits.slice();\n        const next = curr.splice(i, 1);\n        generateDigitPermutations(curr.slice(), permutations.concat(next));\n      }\n    }\n  }\n\n  function generateOperatorPermutations (permutations = []) {\n    const operators = ['+', '-', '*', '/'];\n    if (permutations.length === 3) {\n      operatorPermutations.push(permutations);\n    }\n    else {\n      for (let i = 0; i < operators.length; i++) {\n        const curr = permutations.slice();\n        curr.push(operators[i]);\n        generateOperatorPermutations(curr);\n      }\n    }\n  }\n\n  generateDigitPermutations(digitsArr);\n  generateOperatorPermutations();\n\n  interleave();\n\n  return answers[0];\n\n  function interleave () {\n    for (let i = 0; i < digitPermutations.length; i++) {\n      for (let j = 0; j < operatorPermutations.length; j++) {\n        const d = digitPermutations[i];\n        const o = operatorPermutations[j];\n        const perm = [\n          `${d[0]}${o[0]}${d[1]}${o[1]}${d[2]}${o[2]}${d[3]}`,\n          `(${d[0]}${o[0]}${d[1]})${o[1]}${d[2]}${o[2]}${d[3]}`,\n          `${d[0]}${o[0]}(${d[1]}${o[1]}${d[2]})${o[2]}${d[3]}`,\n          `${d[0]}${o[0]}${d[1]}${o[1]}(${d[2]}${o[2]}${d[3]})`,\n          `${d[0]}${o[0]}(${d[1]}${o[1]}${d[2]}${o[2]}${d[3]})`,\n          `(${d[0]}${o[0]}${d[1]}${o[1]}${d[2]})${o[2]}${d[3]}`,\n          `(${d[0]}${o[0]}${d[1]})${o[1]}(${d[2]}${o[2]}${d[3]})`\n        ];\n\n        perm.forEach(combination => {\n          const res = eval(combination);\n\n          if (res === 24) {\n            return answers.push(combination);\n          }\n        });\n      }\n    }\n  }\n}\n"
      ],
      "tail": [
        "const testCases = [",
        "  '4878',",
        "  '1234',",
        "  '6789',",
        "  '1127'",
        "];",
        "",
        "const answers = [",
        "  ['(7-8/8)*4', '4*(7-8/8)', '(4-8+7)*8', '(4+7-8)*8', '(7+4-8)*8', '(7-8+4)*8', '8*(4-8+7)', '8*(4+7-8)', '8*(7+4-8)', '8*(7-8+4)'],",
        "  ['1*2*3*4', '1*2*4*3', '1*3*2*4', '1*3*4*2', '1*4*2*3', '1*4*3*2', '2*1*3*4', '2*1*4*3', '2*3*1*4', '2*3*4*1', '2*4*3*1', '2*4*1*3', '3*1*2*4', '3*1*4*2', '3*2*1*4', '3*2*4*1', '3*4*1*2', '3*4*2*1', '4*1*2*3', '4*1*3*2', '4*2*1*3', '4*2*3*1', '4*3*1*2', '4*3*2*1', '(1+2+3)*4', '(1+3+2)*4', '(2+1+3)*4', '(2+3+1)*4', '(3+1+2)*4', '(3+2+1)*4', '4*(1+2+3)', '4*(2+1+3)', '4*(2+3+1)', '4*(3+1+2)', '4*(3+2+1)'],",
        "  ['(6*8)/(9-7)', '(8*6)/(9-7)', '6*8/(9-7)', '8*6/(9-7)'],",
        "  ['(1+7)*(2+1)', '(1+7)*(1+2)', '(1+2)*(1+7)', '(1+2)*(7+1)', '(2+1)*(1+7)', '(7+1)*(2+1)']",
        "];",
        "",
        "function include(ansArr, res) {",
        "  const index = ansArr.indexOf(res);",
        "  return index >= 0;",
        "}"
      ],
      "tests": [
        "assert(typeof solve24 === 'function', 'message: <code>solve24</code> is a function.');",
        "assert(include(answers[0], solve24(testCases[0])), 'message: <code>solve24(\"4878\")</code> should return <code>(7-8/8)*4</code> or <code>4*(7-8/8)</code>');",
        "assert(include(answers[1], solve24(testCases[1])), 'message: <code>solve24(\"1234\")</code> should return any arrangement of <code>1*2*3*4</code>');",
        "assert(include(answers[2], solve24(testCases[2])), 'message: <code>solve24(\"6789\")</code> should return <code>(6*8)/(9-7)</code> or <code>(8*6)/(9-7)</code>');",
        "assert(include(answers[3], solve24(testCases[3])), 'message: <code>solve24(\"1127\")</code> should return a permutation of <code>(1+7)*(1*2)</code>');"
      ],
      "id": "5951e88f64ebf159166a1176"
    },
    {
      "title": "9 billion names of God the integer",
      "type": "rosetta-code",
      "categories": [
        "math",
        "integer partition"
      ],
      "difficulty": "8",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">This task is a variation of the <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/The Nine Billion Names of God#Plot_summary\" title=\"wp: The Nine Billion Names of God#Plot_summary\">short story by Arthur C. Clarke</a>.</p><br/>",
        "<p class=\"rosetta__paragraph\">(Solvers should be aware of the consequences of completing this task.)</p><br/>",
        "<p class=\"rosetta__paragraph\">In detail, to specify what is meant by a  “name”:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">The integer 1 has 1 name “1”.</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">The integer 2 has 2 names “1+1”, and “2”.</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">The integer 3 has 3 names “1+1+1”, “2+1”,  and “3”.</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">The integer 4 has 5 names “1+1+1+1”, “2+1+1”, “2+2”, “3+1”, “4”.</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">The integer 5 has 7 names “1+1+1+1+1”, “2+1+1+1”, “2+2+1”, “3+1+1”, “3+2”, “4+1”, “5”.</span></p><br/>",
        "<p class=\"rosetta__paragraph\">This can be visualized in the following form:</p>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "          1",
        "        1   1",
        "      1   1   1",
        "    1   2   1   1",
        "  1   2   2   1   1",
        "1   3   3   2   1   1",
        "</pre></div>",
        "<p class=\"rosetta__paragraph\">Where row  $n$  corresponds to integer  $n$,  and each column  $C$  in row  $m$  from left to right corresponds to the number of names beginning with $C$.</p>",
        "<p class=\"rosetta__paragraph\">Optionally note that the sum of the  $n$-th  row  $P(n)$  is the   <a class=\"rosetta__link--wiki\" href=\"http://mathworld.wolfram.com/PartitionFunctionP.html\" title=\"link: http://mathworld.wolfram.com/PartitionFunctionP.html\">integer partition function</a>.</p>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task</dt></dl>",
        "<p class=\"rosetta__paragraph\">Implement a function that returns the sum of the  $n$-th  row.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function numberOfNames (num) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function numberOfNames (num) {\n  const cache = [\n    [1]\n  ];\n  for (let l = cache.length; l < num + 1; l++) {\n    let Aa;\n    let Mi;\n    const r = [0];\n    for (let x = 1; x < l + 1; x++) {\n      r.push(r[r.length - 1] + (Aa = cache[l - x < 0 ? cache.length - (l - x) : l - x])[(Mi = Math.min(x, l - x)) < 0 ? Aa.length - Mi : Mi]);\n    }\n    cache.push(r);\n  }\n  return cache[num][cache[num].length - 1];\n}\n"
      ],
      "tests": [
        "assert(typeof numberOfNames === 'function', 'message: <code>numberOfNames</code> is a function.');",
        "assert.equal(numberOfNames(5), 7, 'message: <code>numberOfNames(5)</code> should equal 7.');",
        "assert.equal(numberOfNames(12), 77, 'message: <code>numberOfNames(12)</code> should equal 77.');",
        "assert.equal(numberOfNames(18), 385, 'message: <code>numberOfNames(18)</code> should equal 385.');",
        "assert.equal(numberOfNames(23), 1255, 'message: <code>numberOfNames(23)</code> should equal 1255.');",
        "assert.equal(numberOfNames(42), 53174, 'message: <code>numberOfNames(42)</code> should equal 53174.');",
        "assert.equal(numberOfNames(123), 2552338241, 'message: <code>numberOfNames(123)</code> should equal 2552338241.');"
      ],
      "id": "5949b579404977fbaefcd736"
    },
    {
      "title": "ABC Problem",
      "type": "rosetta-code",
      "categories": "?",
      "difficulty": "3",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">You are given a collection of ABC blocks (e.g., childhood alphabet blocks). There are 20 blocks with two letters on each block. A complete alphabet is guaranteed amongst all sides of the blocks. The sample collection of blocks:</p>",
        "<p class=\"rosetta__paragraph\">(B O)</p>",
        "<p class=\"rosetta__paragraph\">(X K)</p>",
        "<p class=\"rosetta__paragraph\">(D Q)</p>",
        "<p class=\"rosetta__paragraph\">(C P)</p>",
        "<p class=\"rosetta__paragraph\">(N A)</p>",
        "<p class=\"rosetta__paragraph\">(G T)</p>",
        "<p class=\"rosetta__paragraph\">(R E)</p>",
        "<p class=\"rosetta__paragraph\">(T G)</p>",
        "<p class=\"rosetta__paragraph\">(Q D)</p>",
        "<p class=\"rosetta__paragraph\">(F S)</p>",
        "<p class=\"rosetta__paragraph\">(J W)</p>",
        "<p class=\"rosetta__paragraph\">(H U)</p>",
        "<p class=\"rosetta__paragraph\">(V I)</p>",
        "<p class=\"rosetta__paragraph\">(A N)</p>",
        "<p class=\"rosetta__paragraph\">(O B)</p>",
        "<p class=\"rosetta__paragraph\">(E R)</p>",
        "<p class=\"rosetta__paragraph\">(F S)</p>",
        "<p class=\"rosetta__paragraph\">(L Y)</p>",
        "<p class=\"rosetta__paragraph\">(P C)</p>",
        "<p class=\"rosetta__paragraph\">(Z M)</p><br/>",
        "<p class=\"rosetta__paragraph\">Some rules to keep in mind:</p>",
        "<ol class='rosetta__ordered-list'>",
        "<li class='rosetta__list-item--ordered'>Once a letter on a block is used, that block cannot be used again.</li>",
        "<li class='rosetta__list-item--ordered'>The function should be case-insensitive.</li>",
        "</ol>",
        "<p class=\"rosetta__paragraph\">Implement a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function canMakeWord (word) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function canMakeWord (word) {\n  const characters = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM';\n  const blocks = characters.split(' ').map(pair => pair.split(''));\n\n  const letters = [...word.toUpperCase()];\n  let length = letters.length;\n  const copy = new Set(blocks);\n\n  letters.forEach(letter => {\n    for (let block of copy) {\n      const index = block.indexOf(letter);\n\n      if (index !== -1) {\n        length--;\n        copy.delete(block);\n        break;\n      }\n    }\n  });\n  return !length;\n}\n"
      ],
      "tail": "const words = ['bark', 'BooK', 'TReAT', 'COMMON', 'squAD', 'conFUSE'];",
      "tests": [
        "assert(typeof canMakeWord === 'function', 'message: <code>canMakeWord</code> is a function.');",
        "assert(typeof canMakeWord('hi') === 'boolean', 'message: <code>canMakeWord</code> should return a boolean.');",
        "assert(canMakeWord(words[0]), 'message: <code>canMakeWord(\"bark\")</code> should return true.');",
        "assert(!canMakeWord(words[1]), 'message: <code>canMakeWord(\"BooK\")</code> should return false.');",
        "assert(canMakeWord(words[2]), 'message: <code>canMakeWord(\"TReAT\")</code> should return true.');",
        "assert(!canMakeWord(words[3]), 'message: <code>canMakeWord(\"COMMON\")</code> should return false.');",
        "assert(canMakeWord(words[4]), 'message: <code>canMakeWord(\"squAD\")</code> should return true.');",
        "assert(canMakeWord(words[5]), 'message: <code>canMakeWord(\"conFUSE\")</code> should return true.');"
      ],
      "id": "594810f028c0303b75339acc"
    },
    {
      "title": "Abundant, deficient and perfect number classifications",
      "type": "rosetta-code",
      "categories": "?",
      "difficulty": "4",
      "benchmark": "getDPA(20000);",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">These define three classifications of positive integers based on their <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Proper divisors\" title=\"Proper divisors\">proper divisors</a>.</p><br/>",
        "<p class=\"rosetta__paragraph\">Let $P(n)$ be the sum of the proper divisors of n where proper divisors are all positive integers n other than n itself.</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">If <code>P(n) < n</code> then n is classed as \"deficient\"</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">If <code>P(n) === n</code> then n is classed as \"perfect\"</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">If <code>P(n) > n</code> then n is classed as \"abundant\"</span></p><br/>",
        "<p class=\"rosetta__paragraph\">Example:</p>",
        "<p class=\"rosetta__paragraph\">6 has proper divisors of 1, 2, and 3.</p>",
        "<p class=\"rosetta__paragraph\">1 + 2 + 3 = 6, so 6 is classed as a perfect number.</p><br/>",
        "<p class=\"rosetta__paragraph\">Implement a function that calculates how many of the integers from 1 to 20,000 (inclusive) are in each of the three classes. Output the result as an array in the following format <code>[deficient, perfect, abundant]</code>.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function getDPA (num) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function getDPA (num) {\n  const dpa = [1, 0, 0];\n  for (let n = 2; n <= num; n += 1) {\n    let ds = 1;\n    const e = Math.sqrt(n);\n    for (let d = 2; d < e; d += 1) {\n      if (n % d === 0) {\n        ds += d + (n / d);\n      }\n    }\n    if (n % e === 0) {\n      ds += e;\n    }\n    dpa[ds < n ? 0 : ds === n ? 1 : 2] += 1;\n  }\n  return dpa;\n}\n"
      ],
      "tail": "const solution = [15043, 4, 4953];",
      "tests": [
        "assert(typeof getDPA === 'function', 'message: <code>getDPA</code> is a function.');",
        "assert(Array.isArray(getDPA(100)), 'message: <code>getDPA</code> should return an array.');",
        "assert(getDPA(100).length === 3, 'message: <code>getDPA</code> return value should have a length of 3.');",
        "assert.deepEqual(getDPA(20000), solution, 'message: <code>getDPA(20000)</code> should equal [15043, 4, 4953]');"
      ],
      "id": "594810f028c0303b75339acd"
    },
    {
      "title": "Accumulator factory",
      "type": "rosetta-code",
      "categories": "closures",
      "difficulty": "1",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Create a function that takes a single (numeric) argument and returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).</p><br/>",
        "<p class=\"rosetta__paragraph\">Rules:</p>",
        "<p class=\"rosetta__paragraph\">Do not use global variables.</p>",
        "<p class=\"rosetta__paragraph\">Hint:</p>",
        "<p class=\"rosetta__paragraph\">Closures save outer state.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function accumulator (sum) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function accumulator (sum) {\n  return function (n) {\n    return sum += n;\n  };\n}\n"
      ],
      "tail": [
        "const testFn = typeof accumulator(3) === 'function' && accumulator(3);",
        "if (testFn) {",
        "  testFn(-4);",
        "  testFn(1.5);",
        "}"
      ],
      "tests": [
        "assert(typeof accumulator === 'function', 'message: <code>accumulator</code> is a function.');",
        "assert(typeof accumulator(0) === 'function', 'message: <code>accumulator(0)</code> should return a function.');",
        "assert(typeof accumulator(0)(2) === 'number', 'message: <code>accumulator(0)(2)</code> should return a number.');",
        "assert(testFn(5) === 5.5, 'message: Passing in the values 3, -4, 1.5, and 5 should return 5.5.');"
      ],
      "id": "594810f028c0303b75339ace"
    },
    {
      "title": "Ackermann function",
      "type": "rosetta-code",
      "categories": "recursion",
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.</p>",
        "<p class=\"rosetta__paragraph\">The Ackermann function is usually defined as follows:</p>",
        "$$A(m, n) =",
        " \\begin{cases}",
        " n+1 & \\mbox{if } m = 0 \\\\",
        " A(m-1, 1) & \\mbox{if } m > 0 \\mbox{ and } n = 0 \\\\",
        " A(m-1, A(m, n-1)) & \\mbox{if } m > 0 \\mbox{ and } n > 0.",
        " \\end{cases}$$",
        "<p class=\"rosetta__paragraph\">Its arguments are never negative and it always terminates. Write a function which returns the value of $A(m, n)$. Arbitrary precision is preferred (since the function grows so quickly), but not required.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function ack (m, n) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function ack (m, n) {\n  return m === 0 ? n + 1 : ack(m - 1, n === 0 ? 1 : ack(m, n - 1));\n}\n"
      ],
      "tests": [
        "assert(typeof ack === 'function', 'message: <code>ack</code> is a function.');",
        "assert(ack(0, 0) === 1, 'message: <code>ack(0, 0)</code> should return 1.');",
        "assert(ack(1, 1) === 3, 'message: <code>ack(1, 1)</code> should return 3.');",
        "assert(ack(2, 5) === 13, 'message: <code>ack(2, 5)</code> should return 13.');",
        "assert(ack(3, 3) === 61, 'message: <code>ack(3, 3)</code> should return 61.');"
      ],
      "id": "594810f028c0303b75339acf"
    },
    {
      "title": "Align columns",
      "type": "rosetta-code",
      "categories": "closures",
      "difficulty": "3",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Given a text file of many lines, where fields within a line are delineated by a single <code>$</code> character, write a program that aligns each column of fields by ensuring that words in each column are separated by at least one space. Further, allow for each word in a column to be either left justified, right justified, or center justified within its column.</p><br/>",
        "<p class=\"rosetta__paragraph\">Use the following text to test your programs:</p>",
        "<div class=\"rosetta__pre-wrap\">",
        "<pre class=\"rosetta__pre\">",
        "Given$a$text$file$of$many$lines",
        "where$fields$within$a$line$",
        "are$delineated$by$a$single$'dollar'$character",
        "write$a$program",
        "that$aligns$each$column$of$fields",
        "by$ensuring$that$words$in$each$",
        "column$are$separated$by$at$least$one$space.",
        "Further,$allow$for$each$word$in$a$column$to$be$either$left$",
        "justified,$right$justified",
        "or$center$justified$within$its$column.",
        "</pre>",
        "</div>",
        "<p class=\"rosetta__paragraph\">Note that:</p>",
        "<ol class=\"rosetta__ordered-list\">",
        "<li class=\"rosetta__list-item--ordered\">The example input texts lines may, or may not, have trailing dollar characters.</li>",
        "<li class=\"rosetta__list-item--ordered\">All columns should share the same alignment.</li>",
        "<li class=\"rosetta__list-item--ordered\">Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.</li>",
        "<li class=\"rosetta__list-item--ordered\">Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal.</li>",
        "<li class=\"rosetta__list-item--ordered\">The minimum space between columns should be computed from the text and not hard-coded.</li>",
        "<li class=\"rosetta__list-item--ordered\">It is not a requirement to add separating characters between or around columns.</li>",
        "</ol>",
        "</div>"
      ],
      "challengeSeed": [
        "const testArr = [",
        "  'Given$a$text$file$of$many$lines',",
        "  'where$fields$within$a$line$',",
        "  'are$delineated$by$a$single$\"dollar\"$character',",
        "  'write$a$program',",
        "  'that$aligns$each$column$of$fields$',",
        "  'by$ensuring$that$words$in$each$',",
        "  'column$are$separated$by$at$least$one$space.',",
        "  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',",
        "  'justified,$right$justified',",
        "  'or$center$justified$within$its$column.'",
        "];",
        "",
        "function formatText (input, justification) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "const testArr = [\n  'Given$a$text$file$of$many$lines',\n  'where$fields$within$a$line$',\n  'are$delineated$by$a$single$\"dollar\"$character',\n  'write$a$program',\n  'that$aligns$each$column$of$fields$',\n  'by$ensuring$that$words$in$each$',\n  'column$are$separated$by$at$least$one$space.',\n  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',\n  'justified,$right$justified',\n  'or$center$justified$within$its$column.'\n];\n\nString.prototype.repeat = function (n) { return new Array(1 + parseInt(n)).join(this); };\n\nfunction formatText (input, justification) {\n  let x, y, max, cols = 0, diff, left, right;\n  for (x = 0; x < input.length; x++) {\n    input[x] = input[x].split('$');\n    if (input[x].length > cols) {\n      cols = input[x].length;\n    }\n  }\n  for (x = 0; x < cols; x++) {\n    max = 0;\n    for (y = 0; y < input.length; y++) {\n      if (input[y][x] && max < input[y][x].length) {\n        max = input[y][x].length;\n      }\n    }\n    for (y = 0; y < input.length; y++) {\n      if (input[y][x]) {\n        diff = (max - input[y][x].length) / 2;\n        left = ' '.repeat(Math.floor(diff));\n        right = ' '.repeat(Math.ceil(diff));\n        if (justification === 'left') {\n          right += left; left = '';\n        }\n        if (justification === 'right') {\n          left += right; right = '';\n        }\n        input[y][x] = left + input[y][x] + right;\n      }\n    }\n  }\n  for (x = 0; x < input.length; x++) {\n    input[x] = input[x].join(' ');\n  }\n  input = input.join('\\n');\n  return input;\n}\n"
      ],
      "tail": [
        "const testInput = [",
        "  'Given$a$text$file$of$many$lines',",
        "  'where$fields$within$a$line$',",
        "  'are$delineated$by$a$single$\"dollar\"$character',",
        "  'write$a$program',",
        "  'that$aligns$each$column$of$fields$',",
        "  'by$ensuring$that$words$in$each$',",
        "  'column$are$separated$by$at$least$one$space.',",
        "  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',",
        "  'justified,$right$justified',",
        "  'or$center$justified$within$its$column.'",
        "];",
        "",
        "const rightAligned = `     Given          a      text   file     of     many     lines",
        "     where     fields    within      a   line ",
        "       are delineated        by      a single \"dollar\" character",
        "     write          a   program",
        "      that     aligns      each column     of   fields ",
        "        by   ensuring      that  words     in     each ",
        "    column        are separated     by     at    least       one space.",
        "  Further,      allow       for   each   word       in         a column to be either left ",
        "justified,      right justified",
        "        or     center justified within    its  column.`;",
        "",
        "const leftAligned = `Given      a          text      file   of     many     lines    ",
        "where      fields     within    a      line   ",
        "are        delineated by        a      single \"dollar\" character",
        "write      a          program  ",
        "that       aligns     each      column of     fields   ",
        "by         ensuring   that      words  in     each     ",
        "column     are        separated by     at     least    one       space.",
        "Further,   allow      for       each   word   in       a         column to be either left ",
        "justified, right      justified",
        "or         center     justified within its    column. `;",
        "",
        "const centerAligned = `  Given        a        text     file    of     many     lines  ",
        "  where      fields    within     a     line  ",
        "   are     delineated    by       a    single \"dollar\" character",
        "  write        a       program ",
        "   that      aligns     each    column   of    fields  ",
        "    by      ensuring    that    words    in     each   ",
        "  column      are     separated   by     at    least      one    space.",
        " Further,    allow       for     each   word     in        a     column to be either left ",
        "justified,   right    justified",
        "    or       center   justified within  its   column. `;"
      ],
      "tests": [
        "assert(typeof formatText === 'function', 'message: <code>formatText</code> is a function.');",
        "assert.strictEqual(formatText(testInput, 'right'), rightAligned, 'message: <code>formatText</code> with the above input and \"right\" justification should produce the following: ');",
        "assert.strictEqual(formatText(testInput, 'left'), leftAligned, 'message: <code>formatText</code> with the above input and \"left\" justification should produce the following: ');",
        "assert.strictEqual(formatText(testInput, 'center'), centerAligned, 'message: <code>formatText</code> with the above input and \"center\" justification should produce the following: ');"
      ],
      "id": "594810f028c0303b75339ad0"
    },
    {
      "title": "Amicable pairs",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\">",
        "Two integers $N$ and $M$ are said to be <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Amicable numbers\" title=\"wp: Amicable numbers\">amicable pairs</a> if $N \\neq M$ and the sum of the <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Proper divisors\" title=\"Proper divisors\">proper divisors</a> of $N$ ($\\mathrm{sum}(\\mathrm{propDivs}(N))$) $= M$ as well as $\\mathrm{sum}(\\mathrm{propDivs}(M)) = N$.",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Example:</dt></dl>",
        "<span class=\"rosetta__text--bold\">1184</span> and <span class=\"rosetta__text--bold\">1210</span> are an amicable pair, with proper divisors:",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\"> 1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592  and </li>",
        "<li class=\"rosetta__list-item--unordered\"> 1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605   respectively.</li>",
        "</ul>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "Calculate and show here the Amicable pairs below 20,000 (there are eight).",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Related tasks</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\"><a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Proper divisors\" title=\"Proper divisors\">Proper divisors</a></li>",
        "<li class=\"rosetta__list-item--unordered\"><a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Abundant, deficient and perfect number classifications\" title=\"Abundant, deficient and perfect number classifications\">Abundant, deficient and perfect number classifications</a></li>",
        "<li class=\"rosetta__list-item--unordered\"><a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Aliquot sequence classifications\" title=\"Aliquot sequence classifications\">Aliquot sequence classifications</a> and its amicable <span class=\"rosetta__text--italic\">classification</span>.</li></ul>",
        "</div>"
      ],
      "challengeSeed": [
        "function amicablePairsUpTo (maxNum) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "// amicablePairsUpTo :: Int -> [(Int, Int)]\nfunction amicablePairsUpTo (maxNum) {\n  return range(1, maxNum)\n    .map(x => properDivisors(x)\n      .reduce((a, b) => a + b, 0))\n    .reduce((a, m, i, lst) => {\n      const n = i + 1;\n\n      return (m > n) && lst[m - 1] === n ?\n        a.concat([\n          [n, m]\n        ]) : a;\n    }, []);\n}\n\n// properDivisors :: Int -> [Int]\nfunction properDivisors (n) {\n  if (n < 2) return [];\n\n  const rRoot = Math.sqrt(n);\n  const intRoot = Math.floor(rRoot);\n  const blnPerfectSquare = rRoot === intRoot;\n  const lows = range(1, intRoot)\n  .filter(x => (n % x) === 0);\n\n  return lows.concat(lows.slice(1)\n    .map(x => n / x)\n    .reverse()\n    .slice(blnPerfectSquare | 0));\n}\n\n// Int -> Int -> Maybe Int -> [Int]\nfunction range (m, n, step) {\n  const d = (step || 1) * (n >= m ? 1 : -1);\n\n  return Array.from({\n    length: Math.floor((n - m) / d) + 1\n  }, (_, i) => m + (i * d));\n}\n"
      ],
      "tail": [
        "const answer300 = [[220, 284]];",
        "const answer3000 = [",
        "  [220, 284],",
        "  [1184, 1210],",
        "  [2620, 2924]",
        "];",
        "const answer20000 = [",
        "  [220, 284],",
        "  [1184, 1210],",
        "  [2620, 2924],",
        "  [5020, 5564],",
        "  [6232, 6368],",
        "  [10744, 10856],",
        "  [12285, 14595],",
        "  [17296, 18416]",
        "];"
      ],
      "tests": [
        "assert(typeof amicablePairsUpTo === 'function', 'message: <code>amicablePairsUpTo</code> is a function.');",
        "assert.deepEqual(amicablePairsUpTo(300), answer300, 'message: <code>amicablePairsUpTo(300)</code> should return <code>[[220,284]]</code>.');",
        "assert.deepEqual(amicablePairsUpTo(3000), answer3000, 'message: <code>amicablePairsUpTo(3000)</code> should return <code>[[220,284],[1184,1210],[2620,2924]]</code>.');",
        "assert.deepEqual(amicablePairsUpTo(20000), answer20000, 'message: <code>amicablePairsUpTo(20000)</code> should return <code>[[220,284],[1184,1210],[2620,2924],[5020,5564],[6232,6368],[10744,10856],[12285,14595],[17296,18416]]</code>.');"
      ],
      "id": "5949b579404977fbaefcd737"
    },
    {
      "title": "Averages/Mode",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "1",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Write a program to find the <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Mode (statistics)\" title=\"wp: Mode (statistics)\">mode</a> value of a collection.</p><br/><p class=\"rosetta__paragraph\">The case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.</p><br/><p class=\"rosetta__paragraph\">If it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.</p>"
      ],
      "challengeSeed": [
        "function mode (arr) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function mode(arr) {\n  const counter = {};\n  let result = [];\n  let max = 0;\n  // for (const i in arr) {\n  arr.forEach(el => {\n    if (!(el in counter)) {\n      counter[el] = 0;\n    }\n    counter[el]++;\n\n    if (counter[el] === max) {\n      result.push(el);\n    }\n    else if (counter[el] > max) {\n      max = counter[el];\n      result = [el];\n    }\n  });\n  return result;\n}\n"
      ],
      "tail": [
        "const arr1 = [1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17];",
        "const arr2 = [1, 2, 4, 4, 1];"
      ],
      "tests": [
        "assert(typeof mode === 'function', 'message: <code>mode</code> is a function.');",
        "assert.deepEqual(mode(arr1), [6], 'message: <code>mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])</code> should equal <code>[6]</code>');",
        "assert.deepEqual(mode(arr2).sort(), [1, 4], 'message <code>mode([1, 2, 4, 4, 1])</code> should equal <code>[1, 4]</code>.');"
      ],
      "id": "594d8d0ab97724821379b1e6"
    },
    {
      "title": "Averages/Pythagorean means",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "4",
      "description": [
        "<div class='rosetta'>",
        "<p class='rosetta__paragraph'>Compute all three of the <a class='rosetta__link--wiki' href='https://en.wikipedia.org/wiki/Pythagorean means' title='wp: Pythagorean means'>Pythagorean means</a> of the set of integers <big>1</big> through <big>10</big> (inclusive).</p><br/><p class='rosetta__paragraph'>Show that <big>$A(x_1,\\ldots,x_n) \\geq G(x_1,\\ldots,x_n) \\geq H(x_1,\\ldots,x_n)$</big> for this set of positive integers.</p><br/><ul class='rosetta__unordered-list'><li class='rosetta__list-item--unordered'> The most common of the three means, the <a class='rosetta__link--rosetta' href='http://rosettacode.org/wiki/Averages/Arithmetic mean' title='Averages/Arithmetic mean'>arithmetic mean</a>, is the sum of the list divided by its length:</li></ul><span class='rosetta__text--indented'> <big>$ A(x_1, \\ldots, x_n) = \\frac{x_1 + \\cdots + x_n}{n}$</big></span><br/><ul class='rosetta__unordered-list'><li class='rosetta__list-item--unordered'>The <a class='rosetta__link--wiki' href='https://en.wikipedia.org/wiki/Geometric mean' title='wp: Geometric mean'>geometric mean</a> is the $n$th root of the product of the list:</li></ul><span class='rosetta__text--indented'> <big>$ G(x_1, \\ldots, x_n) = \\sqrt[n]{x_1 \\cdots x_n} $</big></span><br/><ul class='rosetta__unordered-list'><li class='rosetta__list-item--unordered'>The <a class='rosetta__link--wiki' href='https://en.wikipedia.org/wiki/Harmonic mean' title='wp: Harmonic mean'>harmonic mean</a> is $n$ divided by the sum of the reciprocal of each item in the list:</li></ul><span class='rosetta__text--indented'> <big>$ H(x_1, \\ldots, x_n) = \\frac{n}{\\frac{1}{x_1} + \\cdots + \\frac{1}{x_n}} $</big></span>",
        "<br/><br/><p class='rosetta__paragraph'>Assume the input is an ordered array of all inclusive numbers.</p>",
        "<p class='rosetta__paragraph'>For the answer, please output an object in the following format:</p>",
        "<div class='rosetta__pre-wrap'><pre class='rosetta__pre'>",
        "{",
        "  values: {",
        "    Arithmetic: 5.5,",
        "    Geometric: 4.528728688116765,",
        "    Harmonic: 3.414171521474055",
        "  },",
        "  test: 'is A >= G >= H ? yes'",
        "}",
        "</pre></div>",
        "</div>"
      ],
      "challengeSeed": [
        "function pythagoreanMeans (rangeArr) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function pythagoreanMeans (rangeArr) {\n  // arithmeticMean :: [Number] -> Number\n  const arithmeticMean = xs =>\n    foldl((sum, n) => sum + n, 0, xs) / length(xs);\n\n  // geometricMean :: [Number] -> Number\n  const geometricMean = xs =>\n    raise(foldl((product, x) => product * x, 1, xs), 1 / length(xs));\n\n  // harmonicMean :: [Number] -> Number\n  const harmonicMean = xs =>\n    length(xs) / foldl((invSum, n) => invSum + (1 / n), 0, xs);\n\n  // GENERIC FUNCTIONS ------------------------------------------------------\n\n  // A list of functions applied to a list of arguments\n  // <*> :: [(a -> b)] -> [a] -> [b]\n  const ap = (fs, xs) => //\n    Array.prototype.concat(...fs.map(f => //\n      Array.prototype.concat(...xs.map(x => [f(x)]))));\n\n  // foldl :: (b -> a -> b) -> b -> [a] -> b\n  const foldl = (f, a, xs) => xs.reduce(f, a);\n\n  // length :: [a] -> Int\n  const length = xs => xs.length;\n\n  // mapFromList :: [(k, v)] -> Dictionary\n  const mapFromList = kvs =>\n    foldl((a, [k, v]) =>\n      (a[(typeof k === 'string' && k)] = v, a), {}, kvs);\n\n  // raise :: Num -> Int -> Num\n  const raise = (n, e) => Math.pow(n, e);\n/*\n  // show :: a -> String\n  // show :: a -> Int -> String\n  const show = (...x) =>\n    JSON.stringify.apply(\n      null, x.length > 1 ? [x[0], null, x[1]] : x\n    );\n*/\n  // zip :: [a] -> [b] -> [(a,b)]\n  const zip = (xs, ys) =>\n    xs.slice(0, Math.min(xs.length, ys.length))\n      .map((x, i) => [x, ys[i]]);\n\n  // TEST -------------------------------------------------------------------\n  // mean :: Dictionary\n  const mean = mapFromList(zip(\n    ['Arithmetic', 'Geometric', 'Harmonic'],\n    ap([arithmeticMean, geometricMean, harmonicMean], [\n      rangeArr\n    ])\n  ));\n\n  return {\n    values: mean,\n    test: `is A >= G >= H ? ${mean.Arithmetic >= mean.Geometric &&\n      mean.Geometric >= mean.Harmonic ? 'yes' : 'no'}`\n  };\n}\n"
      ],
      "tail": [
        "const range1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
        "const answer1 = {",
        "  values: {",
        "    Arithmetic: 5.5,",
        "    Geometric: 4.528728688116765,",
        "    Harmonic: 3.414171521474055",
        "  },",
        "  test: 'is A >= G >= H ? yes'",
        "};",
        ""
      ],
      "tests": [
        "assert(typeof pythagoreanMeans === 'function', 'message: <code>pythagoreanMeans</code> is a function.');",
        "assert.deepEqual(pythagoreanMeans(range1), answer1, 'message: <code>pythagoreanMeans([1, 2, ..., 10])</code> should equal the same output above.');"
      ],
      "id": "594d966a1467eb84194f0086"
    },
    {
      "title": "Averages/Root mean square",
      "type": "rosetta-code",
      "categories": [],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Compute the  <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Root mean square\" title=\"wp: Root mean square\">Root mean square</a>  of the numbers 1 through 10 inclusive.</p>",
        "<br/><p class=\"rosetta__paragraph\">The  <span class=\"rosetta__text--italic\">root mean square</span>  is also known by its initials RMS (or rms), and as the <span class=\"rosetta__text--bold\">quadratic mean</span>.</p><br/><p class=\"rosetta__paragraph\">The RMS is calculated as the mean of the squares of the numbers, square-rooted:</p>",
        "<p class=\"rosetta__paragraph\"><big>$$x_{\\mathrm{rms}} = \\sqrt {{{x_1}^2 + {x_2}^2 + \\cdots + {x_n}^2} \\over n}. $$</big></p>",
        "</div>"
      ],
      "challengeSeed": [
        "function rms (arr) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function rms (arr) {\n  const sumOfSquares = arr.reduce((s, x) => s + x * x, 0);\n  return Math.sqrt(sumOfSquares / arr.length);\n}\n"
      ],
      "tail": [
        "const arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
        "const answer1 = 6.2048368229954285;"
      ],
      "tests": [
        "assert(typeof rms === 'function', 'message: <code>rms</code> is a function.');",
        "assert.equal(rms(arr1), answer1, 'message: <code>rms([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</code> should equal <code>6.2048368229954285</code>.');"
      ],
      "id": "594da033de4190850b893874"
    },
    {
      "title": "Babbage problem",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\"><a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Charles_Babbage\" title=\"wp: Charles_Babbage\">Charles Babbage</a>, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:</p><br/>",
        "<blockquote class=\"rosetta__blockquote\">What is the smallest positive integer whose square ends in the digits 269,696?</blockquote>",
        " <p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> - Babbage, letter to Lord Bowden, 1837; see Hollingdale and Tootill, <i>Electronic Computers</i>, second edition, 1970, p. 125.</span></p><br/>",
        "<p class=\"rosetta__paragraph\">He thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.</p><br/>",
        "<p class=\"rosetta__paragraph\">The task is to find out if Babbage had the right answer.</p><br/>",
        "<p class=\"rosetta__paragraph\">Implement a function to return the lowest integer that satisfies the Babbage problem. If Babbage was right, return Babbage's number.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function babbage (babbageNum, endDigits) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function babbage (babbageAns, endDigits) {\n  const babbageNum = Math.pow(babbageAns, 2);\n  const babbageStartDigits = parseInt(babbageNum.toString().replace('269696', ''));\n  let answer = 99736;\n\n  // count down from this answer and save any sqrt int result. return lowest one\n  for (let i = babbageStartDigits; i >= 0; i--) {\n    const num = parseInt(i.toString().concat('269696'));\n    const result = Math.sqrt(num);\n    if (result === Math.floor(Math.sqrt(num))) {\n      answer = result;\n    }\n  }\n\n  return answer;\n}\n"
      ],
      "tail": [
        "const babbageAns = 99736;",
        "const endDigits = 269696;",
        "const answer = 25264;"
      ],
      "tests": [
        "assert(typeof babbage === 'function', 'message: <code>babbage</code> is a function.');",
        "assert.equal(babbage(babbageAns, endDigits), answer, 'message: <code>babbage(99736, 269696)</code> should not return 99736 (there is a smaller answer).');"
      ],
      "id": "594db4d0dedb4c06a2a4cefd"
    },
    {
      "title": "Balanced brackets",
      "type": "rosetta-code",
      "categories": [],
      "difficulty": "2",
      "description": [
        "<div class='rosetta'>",
        "<p class=\"rosetta__paragraph\">Determine whether a generated string of brackets is <span class='rosetta__text--italic'>balanced</span>; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.</p><br/>",
        "<dl class='rosetta__description-list'><dt class='rosetta__description-title'>Examples:</dt></dl>",
        "<p class='rosetta__paragraph'>(empty) true</p>",
        "<p class='rosetta__paragraph'><code>[]</code> true</p>",
        "<p class='rosetta__paragraph'><code>][</code> false</p>",
        "<p class='rosetta__paragraph'><code>[][]</code> true</p>",
        "<p class='rosetta__paragraph'><code>][][</code> false</p>",
        "<p class='rosetta__paragraph'><code>[]][[]</code> false</p>",
        "<p class='rosetta__paragraph'><code>[[[[]]]]</code> true</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function isBalanced (str) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function isBalanced (str) {\n  if (str === '') return true;\n  let a = str;\n  let b;\n  do {\n    b = a;\n    a = a.replace(/\\[\\]/g, '');\n  } while (a !== b);\n  return !a;\n}\n"
      ],
      "tail": [
        "const testCases = [",
        "  '[]',",
        "  ']][[[][][][]][',",
        "  '[][[[[][][[[]]]]]]',",
        "  '][',",
        "  '[[[]]]][[]',",
        "  '][[]',",
        "  '][[][]][[[]]',",
        "  '[[][]]][',",
        "  '[[[]]][[]]]][][[',",
        "  '[]][[]]][[[[][]]',",
        "  '][]][[][',",
        "  '[[]][[][]]',",
        "  '[[]]',",
        "  ']][]][[]][[[',",
        "  '][]][][[',",
        "  '][][',",
        "  '[[]]][][][[]][',",
        "  ''",
        "];"
      ],
      "tests": [
        "assert(typeof isBalanced === 'function', 'message: <code>isBalanced</code> is a function.');",
        "assert(isBalanced(testCases[0]), 'message: <code>isBalanced(\"[]\")</code> should return true.');",
        "assert(!isBalanced(testCases[1]), 'message: <code>isBalanced(\"]][[[][][][]][\")</code> should return false.');",
        "assert(isBalanced(testCases[2]), 'message: <code>isBalanced(\"[][[[[][][[[]]]]]]\")</code> should return true.');",
        "assert(!isBalanced(testCases[3]), 'message: <code>isBalanced(\"][\")</code> should return true.');",
        "assert(!isBalanced(testCases[4]), 'message: <code>isBalanced(\"[[[]]]][[]\")</code> should return true.');",
        "assert(!isBalanced(testCases[5]), 'message: <code>isBalanced(\"][[]\")</code> should return true.');",
        "assert(!isBalanced(testCases[6]), 'message: <code>isBalanced(\"][[][]][[[]]\")</code> should return true.');",
        "assert(!isBalanced(testCases[7]), 'message: <code>isBalanced(\"[[][]]][\")</code> should return true.');",
        "assert(!isBalanced(testCases[8]), 'message: <code>isBalanced(\"[[[]]][[]]]][][[\")</code> should return true.');",
        "assert(!isBalanced(testCases[9]), 'message: <code>isBalanced(\"[]][[]]][[[[][]]\")</code> should return true.');",
        "assert(!isBalanced(testCases[10]), 'message: <code>isBalanced(\"][]][[][\")</code> should return true.');",
        "assert(isBalanced(testCases[11]), 'message: <code>isBalanced(\"[[]][[][]]\")</code> should return true.');",
        "assert(isBalanced(testCases[12]), 'message: <code>isBalanced(\"[[]]\")</code> should return true.');",
        "assert(!isBalanced(testCases[13]), 'message: <code>isBalanced(\"]][]][[]][[[\")</code> should return true.');",
        "assert(!isBalanced(testCases[14]), 'message: <code>isBalanced(\"][]][][[\")</code> should return true.');",
        "assert(!isBalanced(testCases[15]), 'message: <code>isBalanced(\"][][\")</code> should return true.');",
        "assert(!isBalanced(testCases[16]), 'message: <code>isBalanced(\"[[]]][][][[]][\")</code> should return true.');",
        "assert(isBalanced(testCases[17]), 'message: <code>isBalanced(\"\")</code> should return true.');"
      ],
      "id": "594dc6c729e5700999302b45"
    },
    {
      "title": "Circles of given radius through two points",
      "type": "rosetta-code",
      "categories": [],
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><p class=\"rosetta__paragraph\">Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.</p>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Exceptions:</dt></dl>",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">A radius of zero should be treated as never describing circles (except in the case where the points are coincident).</li>",
        "<li class=\"rosetta__list-item--ordered\">If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless the radius is equal to zero as well which then collapses the circles to a point.</li>",
        "<li class=\"rosetta__list-item--ordered\">If the points form a diameter then return a single circle.</li>",
        "<li class=\"rosetta__list-item--ordered\">If the points are too far apart then no circles can be drawn.</li></ol><br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">Implement a function that takes two points and a radius and returns the two circles through those points. For each resulting circle, provide the coordinates for the center of each circle rounded to four decimal digits. Return each coordinate as an array, and coordinates as an array of arrays.<br/><br/>",
        "For edge cases, return the following:<br/>",
        "If points are on the diameter, return one point. If the radius is also zero however, return <code>\"Radius Zero\"</code>.<br/>",
        "If points are coincident, return <code>\"Coincident point. Infinite solutions\"</code>.<br/>",
        "If points are farther apart than the diameter, return <code>\"No intersection. Points further apart than circle diameter\"</code>.<br/><br/>",
        "<li class=\"rosetta__list-item--unordered\">Sample inputs:</li></ul><br/>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "      p1                p2           r",
        "0.1234, 0.9876    0.8765, 0.2345    2.0",
        "0.0000, 2.0000    0.0000, 0.0000    1.0",
        "0.1234, 0.9876    0.1234, 0.9876    2.0",
        "0.1234, 0.9876    0.8765, 0.2345    0.5",
        "0.1234, 0.9876    0.1234, 0.9876    0.0",
        "</pre></div>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Ref:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\"><a class=\"rosetta__link--wiki\" href=\"http://mathforum.org/library/drmath/view/53027.html\" title=\"link: http://mathforum.org/library/drmath/view/53027.html\">Finding the Center of a Circle from 2 Points and Radius</a> from Math forum @ Drexel</li></ul></div>"
      ],
      "challengeSeed": [
        "function getCircles (...args) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "const hDist = (p1, p2) => Math.hypot(...p1.map((e, i) => e - p2[i])) / 2;\nconst pAng = (p1, p2) => Math.atan(p1.map((e, i) => e - p2[i]).reduce((p, c) => c / p, 1));\nconst solveF = (p, r) => t => [parseFloat((r * Math.cos(t) + p[0]).toFixed(4)), parseFloat((r * Math.sin(t) + p[1]).toFixed(4))];\nconst diamPoints = (p1, p2) => p1.map((e, i) => parseFloat((e + (p2[i] - e) / 2).toFixed(4)));\n\nfunction getCircles (...args) {\n  const [p1, p2, s] = args;\n  const solve = solveF(p1, s);\n  const halfDist = hDist(p1, p2);\n\n  let msg = [];\n  switch (Math.sign(s - halfDist)) {\n    case 0:\n      msg = s ? diamPoints(p1, p2) :\n        'Radius Zero';\n      break;\n    case 1:\n      if (!halfDist) {\n        msg = 'Coincident point. Infinite solutions';\n      }\n      else {\n        const theta = pAng(p1, p2);\n        const theta2 = Math.acos(halfDist / s);\n        [1, -1].map(e => solve(theta + e * theta2)).forEach(\n          e => msg.push(e));\n      }\n      break;\n    case -1:\n      msg = 'No intersection. Points further apart than circle diameter';\n      break;\n    default:\n      msg = 'Reached the default';\n  }\n  return msg;\n}\n"
      ],
      "tail": [
        "const testCases = [",
        "  [[0.1234, 0.9876], [0.8765, 0.2345], 2.0],",
        "  [[0.0000, 2.0000], [0.0000, 0.0000], 1.0],",
        "  [[0.1234, 0.9876], [0.1234, 0.9876], 2.0],",
        "  [[0.1234, 0.9876], [0.8765, 0.2345], 0.5],",
        "  [[0.1234, 0.9876], [0.1234, 0.9876], 0.0]",
        "];",
        "const answers = [",
        "  [[1.8631, 1.9742], [-0.8632, -0.7521]],",
        "  [0, 1],",
        "  'Coincident point. Infinite solutions',",
        "  'No intersection. Points further apart than circle diameter',",
        "  'Radius Zero'",
        "];"
      ],
      "tests": [
        "assert(typeof getCircles === 'function', 'message: <code>getCircles</code> is a function.');",
        "assert.deepEqual(getCircles(...testCases[0]), answers[0], 'message: <code>getCircles([0.1234, 0.9876], [0.8765, 0.2345], 2.0)</code> should return <code>[[1.8631, 1.9742], [-0.8632, -0.7521]]</code>.');",
        "assert.deepEqual(getCircles(...testCases[1]), answers[1], 'message: <code>getCircles([0.0000, 2.0000], [0.0000, 0.0000], 1.0)</code> should return <code>[0, 1]</code>');",
        "assert.deepEqual(getCircles(...testCases[2]), answers[2], 'message: <code>getCircles([0.1234, 0.9876], [0.1234, 0.9876], 2.0)</code> should return <code>Coincident point. Infinite solutions</code>');",
        "assert.deepEqual(getCircles(...testCases[3]), answers[3], 'message: <code>getCircles([0.1234, 0.9876], [0.8765, 0.2345], 0.5)</code> should return <code>No intersection. Points further apart than circle diameter</code>');",
        "assert.deepEqual(getCircles(...testCases[4]), answers[4], 'message: <code>getCircles([0.1234, 0.9876], [0.1234, 0.9876], 0.0)</code> should return <code>Radius Zero</code>');"
      ],
      "id": "5951815dd895584b06884620"
    },
    {
      "title": "Closest-pair problem",
      "type": "rosetta-code",
      "categories": [],
      "difficulty": "4",
      "benchmark": "getClosestPair(benchmarkPoints);",
      "description": [
        "<div class=\"rosetta\">",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Provide a function to find the closest two points among a set of given points in two dimensions,  i.e. to solve the  <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Closest pair of points problem\" title=\"wp: Closest pair of points problem\">Closest pair of points problem</a>  in the  <span class=\"rosetta__text--italic\">planar</span>  case.</p><br/><p class=\"rosetta__paragraph\">The straightforward solution is a  O(n<sup>2</sup>)  algorithm  (which we can call <span class=\"rosetta__text--italic\">brute-force algorithm</span>);  the pseudo-code (using indexes) could be simply:</p><br/>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "<span class=\"rosetta__text--bold\">bruteForceClosestPair</span> of P(1), P(2), ... P(N)",
        "<span class=\"rosetta__text--bold\">if</span> N &lt; 2 <span class=\"rosetta__text--bold\">then</span>",
        "<span class=\"rosetta__text--bold\">  return</span> ∞",
        "<span class=\"rosetta__text--bold\">else</span>",
        "  minDistance ← |P(1) - P(2)|",
        "  minPoints ← { P(1), P(2) }",
        "<span class=\"rosetta__text--bold\">  foreach</span> i ∈ [1, N-1]",
        "<span class=\"rosetta__text--bold\">    foreach</span> j ∈ [i+1, N]",
        "<span class=\"rosetta__text--bold\">      if</span> |P(i) - P(j)| < minDistance <span class=\"rosetta__text--bold\">then</span>",
        "        minDistance ← |P(i) - P(j)|",
        "        minPoints ← { P(i), P(j) }",
        "<span class=\"rosetta__text--bold\">      endif</span>",
        "<span class=\"rosetta__text--bold\">    endfor</span>",
        "<span class=\"rosetta__text--bold\">  endfor</span>",
        "<span class=\"rosetta__text--bold\">  return</span> minDistance, minPoints",
        "<span class=\"rosetta__text--bold\">endif</span>",
        "</pre></div>",
        "<p class=\"rosetta__paragraph\">A better algorithm is based on the recursive divide&amp;conquer approach, as explained also at  <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Closest pair of points problem#Planar_case\" title=\"wp: Closest pair of points problem#Planar_case\">Wikipedia's Closest pair of points problem</a>,  which is  O(<span class=\"rosetta__text--italic\">n</span> log <span class=\"rosetta__text--italic\">n</span>);  a pseudo-code could be:</p><br/>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "<span class=\"rosetta__text--bold\">closestPair</span> of (xP, yP)",
        "  where xP is P(1) .. P(N) sorted by x coordinate, and",
        "  yP is P(1) .. P(N) sorted by y coordinate (ascending order)",
        "<span class=\"rosetta__text--bold\">if</span> N ≤ 3 <span class=\"rosetta__text--bold\">then</span>",
        "  <span class=\"rosetta__text--bold\">return</span> closest points of xP using brute-force algorithm",
        "<span class=\"rosetta__text--bold\">else</span>",
        "  xL ← points of xP from 1 to ⌈N/2⌉",
        "  xR ← points of xP from ⌈N/2⌉+1 to N",
        "  xm ← xP(⌈N/2⌉)<sub>x</sub>",
        "  yL ← { p ∈ yP : p<sub>x</sub> ≤ xm }",
        "  yR ← { p ∈ yP : p<sub>x</sub> &gt; xm }",
        "  (dL, pairL) ← <span class=\"rosetta__text--italic\">closestPair</span> of (xL, yL)",
        "  (dR, pairR) ← <span class=\"rosetta__text--italic\">closestPair</span> of (xR, yR)",
        "  (dmin, pairMin) ← (dR, pairR)",
        "  <span class=\"rosetta__text--bold\">if</span> dL &lt; dR <span class=\"rosetta__text--bold\">then</span>",
        "    (dmin, pairMin) ← (dL, pairL)",
        "  <span class=\"rosetta__text--bold\">endif</span>",
        "  yS ← { p ∈ yP : |xm - p<sub>x</sub>| &lt; dmin }",
        "  nS ← number of points in yS",
        "  (closest, closestPair) ← (dmin, pairMin)",
        "<span class=\"rosetta__text--bold\">  for</span> i <span class=\"rosetta__text--bold\">from</span> 1 <span class=\"rosetta__text--bold\">to</span> nS - 1",
        "    k ← i + 1",
        "    <span class=\"rosetta__text--bold\">while</span> k ≤ nS <span class=\"rosetta__text--bold\">and</span> yS(k)<sub>y</sub> - yS(i)<sub>y</sub> &lt; dmin",
        "      <span class=\"rosetta__text--bold\">if</span> |yS(k) - yS(i)| &lt; closest <span class=\"rosetta__text--bold\">then</span>",
        "        (closest, closestPair) ← (|yS(k) - yS(i)|, {yS(k), yS(i)})",
        "      <span class=\"rosetta__text--bold\">endif</span>",
        "      k ← k + 1",
        "    <span class=\"rosetta__text--bold\">endwhile</span>",
        "  <span class=\"rosetta__text--bold\">endfor</span>",
        "  <span class=\"rosetta__text--bold\">return</span> closest, closestPair",
        "<span class=\"rosetta__text--bold\">endif</span>",
        "</pre></div>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">References and further readings:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Closest pair of points problem\" title=\"wp: Closest pair of points problem\">Closest pair of points problem</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--wiki\" href=\"http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairDQ.html\" title=\"link: http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairDQ.html\">Closest Pair (McGill)</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--wiki\" href=\"http://www.cs.ucsb.edu/~suri/cs235/ClosestPair.pdf\" title=\"link: http://www.cs.ucsb.edu/~suri/cs235/ClosestPair.pdf\">Closest Pair (UCSB)</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--wiki\" href=\"http://classes.cec.wustl.edu/~cse241/handouts/closestpair.pdf\" title=\"link: http://classes.cec.wustl.edu/~cse241/handouts/closestpair.pdf\">Closest pair (WUStL)</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--wiki\" href=\"http://www.cs.iupui.edu/~xkzou/teaching/CS580/Divide-and-conquer-closestPair.ppt\" title=\"link: http://www.cs.iupui.edu/~xkzou/teaching/CS580/Divide-and-conquer-closestPair.ppt\">Closest pair (IUPUI)</a> </li></ul><br/>",
        "<p class=\"rosetta__paragraph\">For the input, expect the argument to be an array of objects (points) with <code>x</code> and <code>y</code> members set to numbers. For the output, return an object containing the key:value pairs for  <code>distance</code> and <code>pair</code> (i.e., the pair of two closest points).</p><br/>",
        "</div>"
      ],
      "challengeSeed": [
        "const Point = function (x, y) {",
        "  this.x = x;",
        "  this.y = y;",
        "};",
        "Point.prototype.getX = function () {",
        "  return this.x;",
        "};",
        "Point.prototype.getY = function () {",
        "  return this.y;",
        "};",
        "",
        "function getClosestPair (pointsArr) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "const Point = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function () {\n  return this.x;\n};\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nconst mergeSort = function mergeSort(points, comp) {\n\tif(points.length < 2) return points;\n\n\tvar n = points.length,\n\t\ti = 0,\n\t\tj = 0,\n\t\tleftN = Math.floor(n / 2),\n\t\trightN = leftN;\n\n\tvar leftPart = mergeSort( points.slice(0, leftN), comp),\n\t\trightPart = mergeSort( points.slice(rightN), comp );\n\n\tvar sortedPart = [];\n\n\twhile((i < leftPart.length) && (j < rightPart.length)) {\n\t\tif(comp(leftPart[i], rightPart[j]) < 0) {\n\t\t\tsortedPart.push(leftPart[i]);\n\t\t\ti += 1;\n\t\t}\n\t\telse {\n\t\t\tsortedPart.push(rightPart[j]);\n\t\t\tj += 1;\n\t\t}\n\t}\n\twhile(i < leftPart.length) {\n\t\tsortedPart.push(leftPart[i]);\n\t\ti += 1;\n\t}\n\twhile(j < rightPart.length) {\n\t\tsortedPart.push(rightPart[j]);\n\t\tj += 1;\n\t}\n\treturn sortedPart;\n};\n\nconst closestPair = function _closestPair(Px, Py) {\n\tif(Px.length < 2) return { distance: Infinity, pair: [ new Point(0, 0), new Point(0, 0) ] };\n\tif(Px.length < 3) {\n\t\t//find euclid distance\n\t\tvar d = Math.sqrt( Math.pow(Math.abs(Px[1].x - Px[0].x), 2) + Math.pow(Math.abs(Px[1].y - Px[0].y), 2) );\n\t\treturn {\n\t\t\tdistance: d,\n\t\t\tpair: [ Px[0], Px[1] ]\n\t\t};\n\t}\n\n\tvar\tn = Px.length,\n\t\tleftN = Math.floor(n / 2),\n\t\trightN = leftN;\n\n\tvar Xl = Px.slice(0, leftN),\n\t\tXr = Px.slice(rightN),\n\t\tXm = Xl[leftN - 1],\n\t\tYl = [],\n\t\tYr = [];\n\t//separate Py\n\tfor(var i = 0; i < Py.length; i += 1) {\n\t\tif(Py[i].x <= Xm.x)\n\t\t\tYl.push(Py[i]);\n\t\telse\n\t\t\tYr.push(Py[i]);\n\t}\n\n\tvar dLeft = _closestPair(Xl, Yl),\n\t\tdRight = _closestPair(Xr, Yr);\n\n\tvar minDelta = dLeft.distance,\n\t\tclosestPair = dLeft.pair;\n\tif(dLeft.distance > dRight.distance) {\n\t\tminDelta = dRight.distance;\n\t\tclosestPair = dRight.pair;\n\t}\n\n\t//filter points around Xm within delta (minDelta)\n\tvar closeY = [];\n\tfor(i = 0; i < Py.length; i += 1) {\n\t\tif(Math.abs(Py[i].x - Xm.x) < minDelta) closeY.push(Py[i]);\n\t}\n\t//find min within delta. 8 steps max\n\tfor(i = 0; i < closeY.length; i += 1) {\n\t\tfor(var j = i + 1; j < Math.min( (i + 8), closeY.length ); j += 1) {\n\t\t\tvar d = Math.sqrt( Math.pow(Math.abs(closeY[j].x - closeY[i].x), 2) + Math.pow(Math.abs(closeY[j].y - closeY[i].y), 2) );\n\t\t\tif(d < minDelta) {\n\t\t\t\tminDelta = d;\n\t\t\t\tclosestPair = [ closeY[i], closeY[j] ]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tdistance: minDelta,\n\t\tpair: closestPair\n\t};\n};\n\nfunction getClosestPair (points) {\n  const sortX = function (a, b) { return (a.x < b.x) ? -1 : ((a.x > b.x) ? 1 : 0); }\n  const sortY = function (a, b) { return (a.y < b.y) ? -1 : ((a.y > b.y) ? 1 : 0); }\n\n  const Px = mergeSort(points, sortX);\n  const Py = mergeSort(points, sortY);\n\n  return closestPair(Px, Py);\n}\n"
      ],
      "tail": [
        "const points1 = [",
        "\tnew Point(0.748501, 4.09624),",
        "\tnew Point(3.00302, 5.26164),",
        "\tnew Point(3.61878,  9.52232),",
        "\tnew Point(7.46911,  4.71611),",
        "\tnew Point(5.7819,   2.69367),",
        "\tnew Point(2.34709,  8.74782),",
        "\tnew Point(2.87169,  5.97774),",
        "\tnew Point(6.33101,  0.463131),",
        "\tnew Point(7.46489,  4.6268),",
        "\tnew Point(1.45428,  0.087596)",
        "];",
        "",
        "const points2 = [",
        "  new Point(37100, 13118),",
        "  new Point(37134, 1963),",
        "  new Point(37181, 2008),",
        "  new Point(37276, 21611),",
        "  new Point(37307, 9320)",
        "];",
        "",
        "const answer1 = {",
        "  distance: 0.0894096443343775,",
        "  pair: [",
        "    {",
        "      x: 7.46489,",
        "      y: 4.6268",
        "    },",
        "    {",
        "      x: 7.46911,",
        "      y: 4.71611",
        "    }",
        "  ]",
        "};",
        "",
        "const answer2 = {",
        "  distance: 65.06919393998976,",
        "  pair: [",
        "    {",
        "      x: 37134,",
        "      y: 1963",
        "    },",
        "    {",
        "      x: 37181,",
        "      y: 2008",
        "    }",
        "  ]",
        "};",
        "",
        "const benchmarkPoints = [",
        "  new Point(16909, 54699),",
        "  new Point(14773, 61107),",
        "  new Point(95547, 45344),",
        "  new Point(95951, 17573),",
        "  new Point(5824, 41072),",
        "  new Point(8769, 52562),",
        "  new Point(21182, 41881),",
        "  new Point(53226, 45749),",
        "  new Point(68180, 887),",
        "  new Point(29322, 44017),",
        "  new Point(46817, 64975),",
        "  new Point(10501, 483),",
        "  new Point(57094, 60703),",
        "  new Point(23318, 35472),",
        "  new Point(72452, 88070),",
        "  new Point(67775, 28659),",
        "  new Point(19450, 20518),",
        "  new Point(17314, 26927),",
        "  new Point(98088, 11164),",
        "  new Point(25050, 56835),",
        "  new Point(8364, 6892),",
        "  new Point(37868, 18382),",
        "  new Point(23723, 7701),",
        "  new Point(55767, 11569),",
        "  new Point(70721, 66707),",
        "  new Point(31863, 9837),",
        "  new Point(49358, 30795),",
        "  new Point(13041, 39745),",
        "  new Point(59635, 26523),",
        "  new Point(25859, 1292),",
        "  new Point(1551, 53890),",
        "  new Point(70316, 94479),",
        "  new Point(48549, 86338),",
        "  new Point(46413, 92747),",
        "  new Point(27186, 50426),",
        "  new Point(27591, 22655),",
        "  new Point(10905, 46153),",
        "  new Point(40408, 84202),",
        "  new Point(52821, 73520),",
        "  new Point(84865, 77388),",
        "  new Point(99819, 32527),",
        "  new Point(34404, 75657),",
        "  new Point(78457, 96615),",
        "  new Point(42140, 5564),",
        "  new Point(62175, 92342),",
        "  new Point(54958, 67112),",
        "  new Point(4092, 19709),",
        "  new Point(99415, 60298),",
        "  new Point(51090, 52158),",
        "  new Point(48953, 58567)",
        "];"
      ],
      "naive": "const Point = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function () {\n  return this.x;\n};\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nfunction distance(p1, p2) {\n  var dx = Math.abs(p1.x - p2.x);\n  var dy = Math.abs(p1.y - p2.y);\n  return Math.sqrt(dx*dx + dy*dy);\n}\n\nfunction getClosestPair(arr) {\n  if (arr.length < 2) {\n    return Infinity;\n  } else {\n    var minDist = distance(arr[0], arr[1]);\n    var minPoints = arr.slice(0, 2);\n    \n    for (var i=0; i<arr.length-1; i++) {\n      for (var j=i+1; j<arr.length; j++) {\n        if (distance(arr[i], arr[j]) < minDist) {\n          minDist = distance(arr[i], arr[j]);\n          minPoints = [ arr[i], arr[j] ];\n        }\n      }\n    }\n    return {\n      distance: minDist,\n      pair: minPoints\n    };\n  }\n}\n",
      "tests": [
        "assert(typeof getClosestPair === 'function', 'message: <code>getClosestPair</code> is a function.');",
        "assert.equal(getClosestPair(points1).distance, answer1.distance, 'message: Distance should be the following.');",
        "assert.deepEqual(JSON.parse(JSON.stringify(getClosestPair(points1))).pair, answer1.pair, 'message: Points should be the following.');",
        "assert.equal(getClosestPair(points2).distance, answer2.distance, 'message: Distance should be the following.');",
        "assert.deepEqual(JSON.parse(JSON.stringify(getClosestPair(points2))).pair, answer2.pair, 'message: Points should be the following.');"
      ],
      "id": "5951a53863c8a34f02bf1bdc"
    },
    {
      "title": "Combinations",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "3",
      "benchmark": "combinations(4, 6);",
      "description": [
        "<div class=\"rosetta\">",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Given non-negative integers  <big> <span class=\"rosetta__text--bold\">m</span> </big>  and  <big> <span class=\"rosetta__text--bold\">n</span></big>,  generate all size  <big> <span class=\"rosetta__text--bold\">m</span> </big>  <a class=\"rosetta__link--wiki\" href=\"http://mathworld.wolfram.com/Combination.html\" title=\"link: http://mathworld.wolfram.com/Combination.html\">combinations</a>  of the integers from  <big> <span class=\"rosetta__text--bold\">0</span></big>  (zero)  to  <big> <span class=\"rosetta__text--bold\">n-1</span> </big>  in sorted order  (each combination is sorted and the entire table is sorted).</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Example:</dt></dl>",
        "<p class=\"rosetta__paragraph\"><big><span class=\"rosetta__text--bold\">3</span></big>  comb  <big> <span class=\"rosetta__text--bold\">5</span> </big>is:</p>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "0 1 2",
        "0 1 3",
        "0 1 4",
        "0 2 3",
        "0 2 4",
        "0 3 4",
        "1 2 3",
        "1 2 4",
        "1 3 4",
        "2 3 4",
        "</pre></div>",
        "</div>"
      ],
      "challengeSeed": [
        "function combinations (m, n) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function combinations (m, n) {\n  const nArr = [...Array(n).keys()];\n\n  return (function generateCombinations (size, numArr) {\n    const ret = [];\n\n    for (let i = 0; i < numArr.length; i++) {\n      if (size === 1) {\n        ret.push([numArr[i]]);\n      }\n      else {\n        const sub = generateCombinations(size - 1, numArr.slice(i + 1, numArr.length));\n        for (let subI = 0; subI < sub.length; subI++) {\n          const next = sub[subI];\n          next.unshift(numArr[i]);\n          ret.push(next);\n        }\n      }\n    }\n    return ret;\n  }(m, nArr));\n}\n"
      ],
      "tail": [
        "const testInput1 = [3, 5];",
        "const testOutput1 = [[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]];",
        "",
        "const testInput2 = [4, 6];",
        "const testOutput2 = [[0, 1, 2, 3], [0, 1, 2, 4], [0, 1, 2, 5], [0, 1, 3, 4], [0, 1, 3, 5], [0, 1, 4, 5], [0, 2, 3, 4], [0, 2, 3, 5], [0, 2, 4, 5], [0, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]];"
      ],
      "tests": [
        "assert(typeof combinations === 'function', 'message: <code>combinations</code> is a function.');",
        "assert.deepEqual(combinations(testInput1[0], testInput1[1]), testOutput1, 'message: <code>combinations(3, 5)</code> should return <code>[[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]</code>.');",
        "assert.deepEqual(combinations(testInput2[0], testInput2[1]), testOutput2, 'message: <code>combinations(4, 6)</code> should return <code>[[0,1,2,3],  [0,1,2,4],  [0,1,2,5],  [0,1,3,4],  [0,1,3,5],  [0,1,4,5],  [0,2,3,4],  [0,2,3,5],  [0,2,4,5],  [0,3,4,5],  [1,2,3,4],  [1,2,3,5],  [1,2,4,5],  [1,3,4,5],  [2,3,4,5]]</code>');"
      ],
      "id": "5958469238c0d8d2632f46db"
    },
    {
      "title": "Comma quibbling",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "1",
      "benchmark": "//poorcandidateforbenchmarking",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Comma quibbling is a task originally set by Eric Lippert in his <a class=\"rosetta__link--wiki\" href=\"http://blogs.msdn.com/b/ericlippert/archive/2009/04/15/comma-quibbling.aspx\" title=\"link: http://blogs.msdn.com/b/ericlippert/archive/2009/04/15/comma-quibbling.aspx\">blog</a>.</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl><br/><p class=\"rosetta__paragraph\">Write a function to generate a string output which is the concatenation of input words from a list/sequence where:</p>",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">An input of no words produces the output string of just the two brace characters \"{}\".</li>",
        "<li class=\"rosetta__list-item--ordered\">An input of just one word, e.g. [\"ABC\"], produces the output string of the word inside the two braces, e.g. \"{ABC}\".</li>",
        "<li class=\"rosetta__list-item--ordered\">An input of two words, e.g. [\"ABC\", \"DEF\"], produces the output string of the two words inside the two braces with the words separated by the string \" and \", e.g. \"{ABC and DEF}\".</li>",
        "<li class=\"rosetta__list-item--ordered\">An input of three or more words, e.g. [\"ABC\", \"DEF\", \"G\", \"H\"], produces the output string of all but the last word separated by \", \" with the last word separated by \" and \" and all within braces; e.g. \"{ABC, DEF, G and H}\".</li></ol>",
        "<br>",
        "<p class=\"rosetta__paragraph\">Test your function with the following series of inputs showing your output here on this page:</p>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">[]                       # (No input words).</li>",
        "<li class=\"rosetta__list-item--unordered\">[\"ABC\"]</li>",
        "<li class=\"rosetta__list-item--unordered\">[\"ABC\", \"DEF\"]</li>",
        "<li class=\"rosetta__list-item--unordered\">[\"ABC\", \"DEF\", \"G\", \"H\"]</li></ul>",
        "<br>",
        "<p class=\"rosetta__paragraph\">Note: Assume words are non-empty strings of uppercase characters for this task.</p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function quibble (words) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function quibble (words) {\n  return \"{\" +\n    words.slice(0, words.length - 1).join(\",\") +\n   (words.length > 1 ? \" and \" : \"\") +\n   (words[words.length - 1] || '') +\n  \"}\";\n}\n"
      ],
      "tail": [
        "const testCases = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]];",
        "const results = [\"{}\", \"{ABC}\", \"{ABC and DEF}\", \"{ABC,DEF,G and H}\"];"
      ],
      "tests": [
        "assert(typeof quibble === 'function', 'message: <code>quibble</code> is a function.');",
        "assert(typeof quibble([\"ABC\"]) === 'string', 'message: <code>quibble([\"ABC\"])</code> should return a string.');",
        "assert.equal(quibble(testCases[0]), results[0], 'message: <code>quibble([])</code> should return \"{}\".');",
        "assert.equal(quibble(testCases[1]), results[1], 'message: <code>quibble([\"ABC\"])</code> should return \"{ABC}\".');",
        "assert.equal(quibble(testCases[2]), results[2], 'message: <code>quibble([\"ABC\", \"DEF\"])</code> should return \"{ABC and DEF}\".');",
        "assert.equal(quibble(testCases[3]), results[3], 'message: <code>quibble([\"ABC\", \"DEF\", \"G\", \"H\"])</code> should return \"{ABC,DEF,G and H}\".');"
      ],
      "id": "596e414344c3b2872167f0fe"
    },
    {
      "title": "Compare a list of strings",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "1",
      "benchmark": "//replaceWithActualFunctionHere;",
      "description": [
        "<div class=\"rosetta\"><br/>",
        "<p class=\"rosetta__paragraph\">Given a  <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/List_(abstract_data_type)\" title=\"wp: List_(abstract_data_type)\">list</a>  of arbitrarily many strings, implement a function for each of the following conditions:</p><br/><ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\"> test if they are all lexically <span class=\"rosetta__text--bold\">equal</span></li>",
        "<li class=\"rosetta__list-item--unordered\"> test if every string is lexically <span class=\"rosetta__text--bold\">less than</span> the one after it  <span class=\"rosetta__text--italic\">(i.e. whether the list is in strict ascending order)</span></li></ul>",
        "</div>"
      ],
      "challengeSeed": [
        "function allEqual (arr) {",
        "  // Good luck!",
        "  return true;",
        "}",
        "",
        "function azSorted (arr) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function allEqual(a) {\n  let out = true;\n  let i = 0;\n  while (++i < a.length) {\n    out = out && (a[i - 1] === a[i]);\n  } return out;\n}\n\nfunction azSorted(a) {\n  let out = true;\n  let i = 0;\n  while (++i < a.length) {\n    out = out && (a[i - 1] < a[i]);\n  } return out;\n}\n"
      ],
      "tail": "const testCases = [['AA', 'AA', 'AA', 'AA'], ['AA', 'ACB', 'BB', 'CC'], [], ['AA'], ['BB', 'AA']];",
      "tests": [
        "assert(typeof allEqual === 'function', 'message: <code>allEqual</code> is a function.');",
        "assert(typeof azSorted === 'function', 'message: <code>azSorted</code> is a function.');",
        "assert(allEqual(testCases[0]), 'message: <code>allEqual([\"AA\", \"AA\", \"AA\", \"AA\"])</code> returns true.');",
        "assert(!azSorted(testCases[0]), 'message: <code>azSorted([\"AA\", \"AA\", \"AA\", \"AA\"])</code> returns false.');",
        "assert(!allEqual(testCases[1]), 'message: <code>allEqual([\"AA\", \"ACB\", \"BB\", \"CC\"])</code> returns false.');",
        "assert(azSorted(testCases[1]), 'message: <code>azSorted([\"AA\", \"ACB\", \"BB\", \"CC\"])</code> returns true.');",
        "assert(allEqual(testCases[2]), 'message: <code>allEqual([])</code> returns true.');",
        "assert(azSorted(testCases[2]), 'message: <code>azSorted([])</code> returns true.');",
        "assert(allEqual(testCases[3]), 'message: <code>allEqual([\"AA\"])</code> returns true.');",
        "assert(azSorted(testCases[3]), 'message: <code>azSorted([\"AA\"])</code> returns true.');",
        "assert(!allEqual(testCases[4]), 'message: <code>allEqual([\"BB\", \"AA\"])</code> returns false.');",
        "assert(!azSorted(testCases[4]), 'message: <code>azSorted([\"BB\", \"AA\"])</code> returns false.');"
      ],
      "id": "596e457071c35c882915b3e4"
    },
    {
      "title": "Convert seconds to compound duration",
      "type": "rosetta-code",
      "categories": "Date and time",
      "difficulty": "1",
      "benchmark": "//replaceWithActualFunctionHere;",
      "description": [
        "<div class=\"rosetta\"><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Implement a function which:</p>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">takes a positive integer representing a duration in seconds as input (e.g., <code>100</code>), and</li>",
        "<li class=\"rosetta__list-item--unordered\">returns a string which shows the same duration decomposed into weeks, days, hours, minutes, and seconds as detailed below (e.g., \"<code>1 min, 40 sec</code>\").</li></ul><br>",
        "<p class=\"rosetta__paragraph\">Demonstrate that it passes the following three test-cases:</p><p class=\"rosetta__paragraph\" style=\"font-size:115%; margin:1em 0 0 0\"><span class=\"rosetta__text--bold\"><span class=\"rosetta__text--italic\">Test Cases</span></span></p><br/>",
        "<table class=\"rosetta__wikitable\">",
        "<tbody>",
        "<tr>",
        "<th>input number</th>",
        "<th>output number</th>",
        "</tr>",
        "<tr>",
        "<td>7259</td>",
        "<td><code>2 hr, 59 sec</code></td>",
        "</tr>",
        "<tr>",
        "<td>86400</td>",
        "<td><code>1 d</code></td>",
        "</tr>",
        "<tr>",
        "<td>6000000</td>",
        "<td><code>9 wk, 6 d, 10 hr, 40 min</code></td>",
        "</tr>",
        "</tbody>",
        "</table>",
        "<br/><p class=\"rosetta__paragraph\" style=\"font-size:115%; margin:1em 0 0 0\"><span class=\"rosetta__text--bold\"><span class=\"rosetta__text--italic\">Details</span></span></p><br/>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\">The following five units should be used:",
        "<table class=\"rosetta__wikitable\">",
        "<tbody>",
        "<tr>",
        "<th>unit</th>",
        "<th>suffix used in output</th>",
        "<th>conversion</th>",
        "</tr>",
        "<tr>",
        "<td>week</td>",
        "<td><code>wk</code></td>",
        "<td>1 week = 7 days</td>",
        "</tr>",
        "<tr>",
        "<td>day</td>",
        "<td><code>d</code></td>",
        "<td>1 day = 24 hours</td>",
        "</tr>",
        "<tr>",
        "<td>hour</td>",
        "<td><code>hr</code></td>",
        "<td>1 hour = 60 minutes</td>",
        "</tr>",
        "<tr>",
        "<td>minute</td>",
        "<td><code>min</code></td>",
        "<td>1 minute = 60 seconds</td>",
        "</tr>",
        "<tr>",
        "<td>second</td>",
        "<td><code>sec</code></td>",
        "<td></td>",
        "</tr>",
        "</tbody>",
        "</table>",
        "</li><br/><li class=\"rosetta__list-item--unordered\">However, <span class=\"rosetta__text--bold\">only</span> include quantities with non-zero values in the output (e.g., return \"<code>1 d</code>\" and not \"<code>0 wk, 1 d, 0 hr, 0 min, 0 sec</code>\").</li><br/><li class=\"rosetta__list-item--unordered\">Give larger units precedence over smaller ones as much as possible (e.g., return <code>2 min, 10 sec</code> and not <code>1 min, 70 sec</code> or <code>130 sec</code>)</li><br/><li class=\"rosetta__list-item--unordered\">Mimic the formatting shown in the test-cases (quantities sorted from largest unit to smallest and separated by comma+space; value and unit of each quantity separated by space).</li>",
        "</ul><br/><p class=\"rosetta__paragraph\"><hr style=\"margin:1em 0;\"/></p>",
        "</div>"
      ],
      "challengeSeed": [
        "function convertSeconds (sec) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function convertSeconds (sec) {\n  const localNames = ['wk', 'd', 'hr', 'min', 'sec'];\n  // compoundDuration :: [String] -> Int -> String\n  const compoundDuration = (labels, intSeconds) =>\n    weekParts(intSeconds)\n    .map((v, i) => [v, labels[i]])\n    .reduce((a, x) =>\n      a.concat(x[0] ? [`${x[0]} ${x[1] || '?'}`] : []), []\n    )\n    .join(', ');\n\n    // weekParts :: Int -> [Int]\n  const weekParts = intSeconds => [0, 7, 24, 60, 60]\n    .reduceRight((a, x) => {\n      const r = a.rem;\n      const mod = x !== 0 ? r % x : r;\n\n      return {\n        rem: (r - mod) / (x || 1),\n        parts: [mod].concat(a.parts)\n      };\n    }, {\n      rem: intSeconds,\n      parts: []\n    })\n    .parts;\n\n  return compoundDuration(localNames, sec);\n}\n"
      ],
      "tail": [
        "const testCases = [7259, 86400, 6000000];",
        "const results = ['2 hr, 59 sec', '1 d', '9 wk, 6 d, 10 hr, 40 min'];"
      ],
      "tests": [
        "assert(typeof convertSeconds === 'function', 'message: <code>convertSeconds</code> is a function.');",
        "assert.equal(convertSeconds(testCases[0]), results[0], 'message: <code>convertSeconds(7259)</code> should return <code>2 hr, 59 sec</code>.');",
        "assert.equal(convertSeconds(testCases[1]), results[1], 'message: <code>convertSeconds(86400)</code> should return <code>1 d</code>.');",
        "assert.equal(convertSeconds(testCases[2]), results[2], 'message: <code>convertSeconds(6000000)</code> should return <code>9 wk, 6 d, 10 hr, 40 min</code>.');"
      ],
      "id": "596fd036dc1ab896c5db98b1"
    },
    {
      "title": "Count occurrences of a substring",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "benchmark": "//replaceWithActualFunctionHere;",
      "description": [
        "<div class=\"rosetta\"><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Create a function,  or show a built-in function,  to count the number of non-overlapping occurrences of a substring inside a string.</p><br/><p class=\"rosetta__paragraph\">The function should take two arguments:</p>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\">the first argument being the string to search,  and</li>",
        "<li class=\"rosetta__list-item--unordered\">the second a substring to be searched for.</li>",
        "</ul>",
        "<br/><p class=\"rosetta__paragraph\">It should return an integer count.</p>",
        "<br/><p class=\"rosetta__paragraph\">The matching should yield the highest number of non-overlapping matches.</p><br/><p class=\"rosetta__paragraph\">In general, this essentially means matching from left-to-right or right-to-left.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function countSubstring (str, subStr) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function countSubstring(str, subStr) {\n  const escapedSubStr = subStr.replace(/[.+*?^$[\\]{}()|/]/g, '\\\\$&');\n  const matches = str.match(new RegExp(escapedSubStr, 'g'));\n  return matches ? matches.length : 0;\n}\n"
      ],
      "tail": [
        "const testCases = ['the three truths', 'ababababab', 'abaabba*bbaba*bbab'];",
        "const searchString = ['th', 'abab', 'a*b'];",
        "const results = [3, 2, 2];"
      ],
      "tests": [
        "assert(typeof countSubstring === 'function', 'message: <code>countSubstring</code> is a function.');",
        "assert.equal(countSubstring(testCases[0], searchString[0]), results[0], 'message: <code>countSubstring(\"the three truths\", \"th\")</code> should return <code>3</code>.');",
        "assert.equal(countSubstring(testCases[1], searchString[1]), results[1], 'message: <code>countSubstring(\"ababababab\", \"abab\")</code> should return <code>2</code>.');",
        "assert.equal(countSubstring(testCases[2], searchString[2]), results[2], 'message: <code>countSubstring(\"abaabba*bbaba*bbab\", \"a*b\")</code> should return <code>2</code>.');"
      ],
      "id": "596fda99c69f779975a1b67d"
    },
    {
      "title": "Count the coins",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "1",
      "benchmark": "//replaceWithActualFunctionHere;",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">There are four types of common coins in <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/United_States\" title=\"link: https://en.wikipedia.org/wiki/United_States\">US</a> currency:</p>",
        "<ol class=\"rosetta__ordered-list\">",
        "<li class=\"rosetta__list-item--ordered\">quarters (25 cents)</li>",
        "<li class=\"rosetta__list-item--ordered\">dimes (10 cents)</li>",
        "<li class=\"rosetta__list-item--ordered\">nickels (5 cents),  and </li>",
        "<li class=\"rosetta__list-item--ordered\">pennies (1 cent)  </li>",
        "</ol>",
        "<br/><p class=\"rosetta__paragraph\">There are six ways to make change for 15 cents:</p>",
        "<ol class=\"rosetta__ordered-list\">",
        "<li class=\"rosetta__list-item--ordered\">A dime and a nickel </li>",
        "<li class=\"rosetta__list-item--ordered\">A dime and 5 pennies</li>",
        "<li class=\"rosetta__list-item--ordered\">3 nickels</li>",
        "<li class=\"rosetta__list-item--ordered\">2 nickels and 5 pennies</li>",
        "<li class=\"rosetta__list-item--ordered\">A nickel and 10 pennies</li>",
        "<li class=\"rosetta__list-item--ordered\">15 pennies</li>",
        "<br><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Implement a function to determine how many ways there are to make change for a dollar using these common coins? (1 dollar = 100 cents).</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Reference:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--wiki\" href=\"http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_Temp_52\" title=\"link: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_Temp_52\">an algorithm from MIT Press</a>. </li></ul></div>"
      ],
      "challengeSeed": [
        "function countCoins () {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function countCoins () {\n  let t = 100;\n  const operands = [1, 5, 10, 25];\n  const targetsLength = t + 1;\n  const operandsLength = operands.length;\n  t = [1];\n\n  for (let a = 0; a < operandsLength; a++) {\n    for (let b = 1; b < targetsLength; b++) {\n      // initialise undefined target\n      t[b] = t[b] ? t[b] : 0;\n\n      // accumulate target + operand ways\n      t[b] += (b < operands[a]) ? 0 : t[b - operands[a]];\n    }\n  }\n\n  return t[targetsLength - 1];\n}\n"
      ],
      "tests": [
        "assert(typeof countCoins === 'function', 'message: <code>countCoins</code> is a function.');",
        "assert.equal(countCoins(), 242, 'message: <code>countCoints()</code> should return 242.');"
      ],
      "id": "59713bd26bdeb8a594fb9413"
    },
    {
      "title": "Cramer's rule",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "7",
      "benchmark": "//replaceWithActualFunctionHere;",
      "description": [
        "<div class=\"rosetta\"><p class=\"rosetta__paragraph\">In <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/linear algebra\" title=\"wp: linear algebra\">linear algebra</a>, <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Cramer's rule\" title=\"wp: Cramer's rule\">Cramer's rule</a> is an explicit formula for the solution of a <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/system of linear equations\" title=\"wp: system of linear equations\">system of linear equations</a> with as many equations as unknowns, valid whenever the system has a unique solution. It expresses the solution in terms of the determinants of the (square) coefficient matrix and of matrices obtained from it by replacing one column by the vector of right hand sides of the equations.</p>",
        "<br/><p class=\"rosetta__paragraph\">Given</p>",
        "<p class=\"rosetta__paragraph\"><big></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> $\\left\\{\\begin{matrix}a_1x + b_1y + c_1z&= {\\color{red}d_1}\\\\a_2x + b_2y + c_2z&= {\\color{red}d_2}\\\\a_3x + b_3y + c_3z&= {\\color{red}d_3}\\end{matrix}\\right.$</span></p>",
        "</big><br/><p class=\"rosetta__paragraph\">which in matrix format is</p><br/><p class=\"rosetta__paragraph\"><big></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> $\\begin{bmatrix} a_1 & b_1 & c_1 \\\\ a_2 & b_2 & c_2 \\\\ a_3 & b_3 & c_3 \\end{bmatrix}\\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}=\\begin{bmatrix} {\\color{red}d_1} \\\\ {\\color{red}d_2} \\\\ {\\color{red}d_3} \\end{bmatrix}.$</span></p>",
        "</big><br/><p class=\"rosetta__paragraph\">Then the values of $x, y$ and $z$ can be found as follows:</p><br/><p class=\"rosetta__paragraph\"><big></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">$x = \\frac{\\begin{vmatrix} {\\color{red}d_1} & b_1 & c_1 \\\\ {\\color{red}d_2} & b_2 & c_2 \\\\ {\\color{red}d_3} & b_3 & c_3 \\end{vmatrix} } { \\begin{vmatrix} a_1 & b_1 & c_1 \\\\ a_2 & b_2 & c_2 \\\\ a_3 & b_3 & c_3 \\end{vmatrix}}, \\quad y = \\frac {\\begin{vmatrix} a_1 & {\\color{red}d_1} & c_1 \\\\ a_2 & {\\color{red}d_2} & c_2 \\\\ a_3 & {\\color{red}d_3} & c_3 \\end{vmatrix}} {\\begin{vmatrix} a_1 & b_1 & c_1 \\\\ a_2 & b_2 & c_2 \\\\ a_3 & b_3 & c_3 \\end{vmatrix}}, \\text{ and }z = \\frac { \\begin{vmatrix} a_1 & b_1 & {\\color{red}d_1} \\\\ a_2 & b_2 & {\\color{red}d_2} \\\\ a_3 & b_3 & {\\color{red}d_3} \\end{vmatrix}} {\\begin{vmatrix} a_1 & b_1 & c_1 \\\\ a_2 & b_2 & c_2 \\\\ a_3 & b_3 & c_3 \\end{vmatrix} }.$</span></p>",
        "</big>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task</dt></dl>",
        "<p class=\"rosetta__paragraph\">Given the following system of equations:</p><br/><p class=\"rosetta__paragraph\"><big>",
        "<span class=\"rosetta__text--indented\">",
        "$\\begin{cases}",
        "2w-x+5y+z=-3 \\\\",
        "3w+2x+2y-6z=-32 \\\\",
        "w+3x+3y-z=-47 \\\\",
        "5w-2x-3y+3z=49 \\\\",
        "\\end{cases}$",
        "</span>",
        "</big></p><br>",
        "<p class=\"rosetta__paragraph\">solve for <big>$w$, $x$, $y$</big> and <big>$z$</big>, using Cramer's rule.</p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function cramersRule (matrix, freeTerms) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "/**\n * Compute Cramer's Rule\n * @param  {array} matrix    x,y,z, etc. terms\n * @param  {array} freeTerms\n * @return {array}           solution for x,y,z, etc.\n */\nfunction cramersRule(matrix, freeTerms) {\n  const det = detr(matrix);\n  const returnArray = [];\n  let i;\n\n  for (i = 0; i < matrix[0].length; i++) {\n    const tmpMatrix = insertInTerms(matrix, freeTerms, i);\n    returnArray.push(detr(tmpMatrix) / det);\n  }\n  return returnArray;\n}\n\n/**\n * Inserts single dimensional array into\n * @param  {array} matrix multidimensional array to have ins inserted into\n * @param  {array} ins single dimensional array to be inserted vertically into matrix\n * @param  {array} at  zero based offset for ins to be inserted into matrix\n * @return {array}     New multidimensional array with ins replacing the at column in matrix\n */\nfunction insertInTerms(matrix, ins, at) {\n  const tmpMatrix = clone(matrix);\n  let i;\n  for (i = 0; i < matrix.length; i++) {\n    tmpMatrix[i][at] = ins[i];\n  }\n  return tmpMatrix;\n}\n/**\n * Compute the determinate of a matrix.  No protection, assumes square matrix\n * function borrowed, and adapted from MIT Licensed numericjs library (www.numericjs.com)\n * @param  {array} m Input Matrix (multidimensional array)\n * @return {number}   result rounded to 2 decimal\n */\nfunction detr(m) {\n  let ret = 1;\n  let j;\n  let k;\n  const A = clone(m);\n  const n = m[0].length;\n  let alpha;\n\n  for (j = 0; j < n - 1; j++) {\n    k = j;\n    for (let i = j + 1; i < n; i++) { if (Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }\n    if (k !== j) {\n      const temp = A[k]; A[k] = A[j]; A[j] = temp;\n      ret *= -1;\n    }\n    const Aj = A[j];\n    for (let i = j + 1; i < n; i++) {\n      const Ai = A[i];\n      alpha = Ai[j] / Aj[j];\n      for (k = j + 1; k < n - 1; k += 2) {\n        const k1 = k + 1;\n        Ai[k] -= Aj[k] * alpha;\n        Ai[k1] -= Aj[k1] * alpha;\n      }\n      if (k !== n) { Ai[k] -= Aj[k] * alpha; }\n    }\n    if (Aj[j] === 0) { return 0; }\n    ret *= Aj[j];\n  }\n  return Math.round(ret * A[j][j] * 100) / 100;\n}\n\n/**\n * Clone two dimensional Array using ECMAScript 5 map function and EcmaScript 3 slice\n * @param  {array} m Input matrix (multidimensional array) to clone\n * @return {array}   New matrix copy\n */\nfunction clone(m) {\n  return m.map(a => a.slice());\n}\n"
      ],
      "tail": [
        "const matrices = [",
        "  [",
        "    [2, -1, 5, 1],",
        "    [3, 2, 2, -6],",
        "    [1, 3, 3, -1],",
        "    [5, -2, -3, 3]",
        "  ],",
        "  [",
        "    [3, 1, 1],",
        "    [2, 2, 5],",
        "    [1, -3, -4]",
        "  ]",
        "];",
        "const freeTerms = [[-3, -32, -47, 49], [3, -1, 2]];",
        "",
        "const answers = [[2, -12, -4, 1], [1, 1, -1]];"
      ],
      "tests": [
        "assert(typeof cramersRule === 'function', 'message: <code>cramersRule</code> is a function.');",
        "assert.deepEqual(cramersRule(matrices[0], freeTerms[0]), answers[0], 'message: <code>cramersRule([[2, -1, 5, 1], [3, 2, 2, -6], [1, 3, 3, -1], [5, -2, -3, 3]], [-3, -32, -47, 49])</code> should return <code>[2, -12, -4, 1]</code>.');",
        "assert.deepEqual(cramersRule(matrices[1], freeTerms[1]), answers[1], 'message: <code>cramersRule([[3, 1, 1], [2, 2, 5], [1, -3, -4]], [3, -1, 2])</code> should return <code>[1, 1, -1]</code>.');"
      ],
      "id": "59713da0a428c1a62d7db430"
    },
    {
      "title": "Date format",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "1",
      "benchmark": "/* no benchmark expected as there were no \"optimal\" solutions in the solution list */",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Return an array with the current date in the formats:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">-   <span class=\"rosetta__text--bold\">2007-11-23</span>   and </span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">-   <span class=\"rosetta__text--bold\">Sunday, November 23, 2007</span></span></p>",
        "<br>",
        "<p class=\"rosetta__paragraph\">Example output: <span class=\"rosetta__text--bold\"><code>['2007-11-23', 'Sunday, November 23, 2007']</code></span></p>",
        "<br/></div>"
      ],
      "challengeSeed": [
        "function getDateFormats () {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function getDateFormats () {\n  const date = new Date();\n  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  const fmt1 = `${date.getFullYear()}-${(1 + date.getMonth())}-${date.getDate()}`;\n  const fmt2 = `${weekdays[date.getDay()]}, ${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;\n  return [fmt1, fmt2];\n}\n"
      ],
      "tail": [
        "const getDateSolution = () => {",
        "  const date = new Date();",
        "  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];",
        "  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];",
        "  const fmt1 = `${date.getFullYear()}-${(1 + date.getMonth())}-${date.getDate()}`;",
        "  const fmt2 = `${weekdays[date.getDay()]}, ${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;",
        "  return [fmt1, fmt2];",
        "};",
        "",
        "const dates = getDateSolution();",
        "const equalsMessage = `message: <code>getDataFormats()</code> should return <code>[\"${dates[0]}\", \"${dates[1]}\"]</code>.`;"
      ],
      "tests": [
        "assert(typeof getDateFormats === 'function', 'message: <code>getDateFormats</code> is a function.');",
        "assert(typeof getDateFormats() === 'object', 'message: Should return an object.');",
        "assert(getDateFormats().length === 2, 'message: Should returned an array with 2 elements.');",
        "assert.deepEqual(getDateFormats(), dates, equalsMessage);"
      ],
      "id": "59669d08d75b60482359409f"
    },
    {
      "title": "Date manipulation",
      "type": "rosetta-code",
      "categories": "Date and time",
      "difficulty": "3",
      "benchmark": [],
      "description": [
        "<div class=\"rosetta\">",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Given a date string in EST, output the given date as a string with 12 hours added to the time. <br></p>",
        "<p class=\"rosetta__paragraph\">Time zone should be preserved.<br><br></p>",
        "<p class=\"rosetta__paragraph\">Example input: <br></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"><code>\"March 7 2009 7:30pm EST\"</code></span></p>",
        "<p class=\"rosetta__paragraph\">Example output: <br></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"><code>\"March 8 2009 7:30am EST\"</code></span></p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function add12Hours (dateString) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function add12Hours (dateString) {\n  const months = ['January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December'];\n  // Get the parts of the string\n  const parts = dateString.split(' ');\n  const month = months.indexOf(parts[0]);\n  const day = parseInt(parts[1], 10);\n  const year = parseInt(parts[2], 10);\n  const time = parts[3].split(':');\n  let hours = parseInt(time[0], 10);\n  if (time[1].slice(-2) === 'pm') {\n    hours += 12;\n  }\n  const minutes = parseInt(time[1].slice(0, -2), 10);\n\n  // Create a date with given parts, and updated hours\n  const date = new Date();\n  date.setFullYear(year, month, day);\n  date.setHours(hours + 12);  // Add 12 hours\n  date.setMinutes(minutes);\n\n  let hoursOutput = date.getHours();\n  let abbreviation = 'am';\n  if (hoursOutput > 12) {\n    hoursOutput -= 12;\n    abbreviation = 'pm';\n  }\n\n  return `${months[date.getMonth()]} ${date.getDate()} ${date.getFullYear()} ${hoursOutput}:${date.getMinutes()}${abbreviation} EST`;\n}\n"
      ],
      "tail": [
        "const tests = [",
        "  'January 17 2017 11:43am EST',",
        "  'March 7 2009 7:30pm EST',",
        "  'February 29 2004 9:15pm EST',",
        "  'February 28 1999 3:15pm EST',",
        "  'December 31 2020 1:45pm EST'",
        "];",
        "const answers = [",
        "  'January 17 2017 11:43pm EST',",
        "  'March 8 2009 7:30am EST',",
        "  'March 1 2004 9:15am EST',",
        "  'March 1 1999 3:15am EST',",
        "  'January 1 2021 1:45am EST'",
        "];"
      ],
      "tests": [
        "assert(typeof add12Hours === 'function', 'message: <code>add12Hours</code> is a function.');",
        "assert(typeof add12Hours(tests[0]) === 'string', 'message: <code>add12Hours(dateString)</code> should return a string.');",
        "assert(add12Hours(tests[0]) === answers[0], 'message: <code>add12Hours(\"' + tests[0] + '\")</code> should return <code>\"' + answers[0] + '\"</code>');",
        "assert(add12Hours(tests[1]) === answers[1], 'message: Should handel day change. <code>add12Hours(\"' + tests[1] + '\")</code> should return <code>\"' + answers[1] + '\"</code>');",
        "assert(add12Hours(tests[2]) === answers[2], 'message: Should handel month change in a leap years. <code>add12Hours(\"' + tests[2] + '\")</code> should return <code>\"' + answers[2] + '\"</code>');",
        "assert(add12Hours(tests[3]) === answers[3], 'message: Should handel month change in a common years. <code>add12Hours(\"' + tests[3] + '\")</code> should return <code>\"' + answers[3] + '\"</code>');",
        "assert(add12Hours(tests[4]) === answers[4], 'message: Should handel year change. <code>add12Hours(\"' + tests[4] + '\")</code> should return <code>\"' + answers[4] + '\"</code>');"
      ],
      "id": "5966c21cf732a95f1b67dd28"
    },
    {
      "title": "Day of the week",
      "type": "rosetta-code",
      "categories": "Date",
      "difficulty": "1",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><br/>",
        "<p class=\"rosetta__paragraph\">A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).</p>",
        "<br/>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--bold\">Task:</span></p>",
        "<p class=\"rosetta__paragraph\">Write a function that takes a start year and an end year and return an array of all the years where the 25th of December will be a Sunday.</p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function findXmasSunday (start, end) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function findXmasSunday (start, end) {\n  const xmasSunday = [];\n  for (let year = start; year <= end; year++) {\n    const xmas = new Date(year, 11, 25);\n    if (xmas.getDay() === 0) {\n      xmasSunday.push(year);\n    }\n  }\n  return xmasSunday;\n}\n"
      ],
      "tail": [
        "const firstSolution = [1977, 1983, 1988, 1994, 2005, 2011, 2016];",
        "const secondSolution = [2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118];"
      ],
      "tests": [
        "assert(typeof findXmasSunday === 'function', 'message: <code>findXmasSunday</code> is a function.');",
        "assert(typeof findXmasSunday(2000, 2100) === 'object', 'message: <code>findChristmasSunday(2000, 2100)</code> should return an array.');",
        "assert.deepEqual(findXmasSunday(1970, 2017), firstSolution, 'message: <code>findChristmasSunday(2008, 2121</code> should return [1977, 1983, 1988, 1994, 2005, 2011, 2016]');",
        "assert.deepEqual(findXmasSunday(2008, 2121), secondSolution, 'message: <code>findChristmasSunday(2008, 2121</code> should return [2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]');"
      ],
      "id": "5966f99c45e8976909a85575"
    },
    {
      "title": "Deal cards for FreeCell",
      "type": "rosetta-code",
      "categories": "Cards",
      "difficulty": "4",
      "benchmark": [],
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--italic\">Free Cell</span> is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to <span class=\"rosetta__text--italic\">FreeCell</span> and reimplemented the game for <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/DOS\" title=\"DOS\">DOS</a>, then <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Windows\" title=\"Windows\">Windows</a>. <br></p>",
        "<p class=\"rosetta__paragraph\">This version introduced 32000 numbered deals. (The <a class=\"rosetta__link--wiki\" href=\"http://www.solitairelaboratory.com/fcfaq.html\" title=\"link: http://www.solitairelaboratory.com/fcfaq.html\">FreeCell FAQ</a> tells this history.)</p><br/><p class=\"rosetta__paragraph\">As the game became popular, Jim Horne disclosed <a class=\"rosetta__link--wiki\" href=\"http://www.solitairelaboratory.com/mshuffle.txt\" title=\"link: http://www.solitairelaboratory.com/mshuffle.txt\">the algorithm</a>, and other implementations of FreeCell began to reproduce the Microsoft deals. <br></p>",
        "<p class=\"rosetta__paragraph\">These deals are numbered from 1 to 32000.</p>",
        "<p class=\"rosetta__paragraph\">Newer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.</p><br/><p class=\"rosetta__paragraph\">The algorithm uses this <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/linear congruential generator\" title=\"linear congruential generator\">linear congruential generator</a> from Microsoft C:</p><br/><ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">$state_{n + 1} \\equiv 214013 \\times state_n + 2531011 \\pmod{2^{31}}$</li>",
        "<li class=\"rosetta__list-item--unordered\">$rand_n = state_n \\div 2^{16}$</li>",
        "<li class=\"rosetta__list-item--unordered\">$rand_n$ is in range 0 to 32767.</li>",
        "<br>",
        "<p class=\"rosetta__paragraph\">The algorithm follows:</p><br/><ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Seed the RNG with the number of the deal.</li>",
        "<li class=\"rosetta__list-item--ordered\">Create an <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/array\" title=\"array\">array</a> of 52 cards: Ace of Clubs, Ace of Diamonds, Ace of Hearts, Ace of Spades, 2 of Clubs, 2 of Diamonds, and so on through the ranks: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King. The array indexes are 0 to 51, with Ace of Clubs at 0, and King of Spades at 51.</li>",
        "<li class=\"rosetta__list-item--ordered\">Until the array is empty:</li>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\"> Choose a random card at <span class=\"rosetta__text--italic\">index</span> &equiv; <span class=\"rosetta__text--italic\">next random number</span> (mod <span class=\"rosetta__text--italic\">array length</span>). </li>",
        "<li class=\"rosetta__list-item--unordered\"> Swap this random card with the last card of the array.</li>",
        "<li class=\"rosetta__list-item--unordered\"> Remove this random card from the array. (Array length goes down by 1.)</li>",
        "<li class=\"rosetta__list-item--unordered\"> Deal this random card.</li>",
        "</ul>",
        "<li class=\"rosetta__list-item--ordered\">Deal all 52 cards, face up, across 8 columns. The first 8 cards go in 8 columns, the next 8 cards go on the first 8 cards, and so on.</li></ol>",
        "<br />",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Example:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Order to deal cards</p>",
        "<p class=\"rosetta__paragraph\"><div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\"> 1  2  3  4  5  6  7  8",
        " 9 10 11 12 13 14 15 16",
        "17 18 19 20 21 22 23 24",
        "25 26 27 28 29 30 31 32",
        "33 34 35 36 37 38 39 40",
        "41 42 43 44 45 46 47 48",
        "49 50 51 52</pre></div></p>",
        "<p class=\"rosetta__paragraph\">Game #1</p>",
        "<p class=\"rosetta__paragraph\"><div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">[",
        "['JD', '2D', '9H', 'JC', '5D', '7H', '7C', '5H'],",
        "['KD', 'KC', '9S', '5S', 'AD', 'QC', 'KH', '3H'],",
        "['2S', 'KS', '9D', 'QD', 'JS', 'AS', 'AH', '3C'],",
        "['4C', '5C', 'TS', 'QH', '4H', 'AC', '4D', '7S'],",
        "['3S', 'TD', '4S', 'TH', '8H', '2C', 'JH', '7D'],",
        "['6D', '8S', '8D', 'QS', '6C', '3D', '8C', 'TC'],",
        "['6S', '9C', '2H', '6H']",
        "]</pre></div></p>",
        "<p class=\"rosetta__paragraph\">Game #617</p>",
        "<p class=\"rosetta__paragraph\"><div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">[",
        "['7D', 'AD', '5C', '3S', '5S', '8C', '2D', 'AH'],",
        "['TD', '7S', 'QD', 'AC', '6D', '8H', 'AS', 'KH'],",
        "['TH', 'QC', '3H', '9D', '6S', '8D', '3D', 'TC'],",
        "['KD', '5H', '9S', '3C', '8S', '7H', '4D', 'JS'],",
        "['4C', 'QS', '9C', '9H', '7C', '6H', '2C', '2S'],",
        "['4S', 'TS', '2H', '5D', 'JC', '6C', 'JH', 'QH'],",
        "['JD', 'KS', 'KC', '4H']",
        "]</pre></div></p>",
        "<br />",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Write a function to take a deal number and deal cards in the same order as this algorithm.</p>",
        "<p class=\"rosetta__paragraph\">The function must return a two dimentional array representing the FreeCell board.</p>",
        "<br/>",
        "<p class=\"rosetta__paragraph\">Deals can also be checked against <a class=\"rosetta__link--wiki\" href=\"http://freecellgamesolutions.com/\" title=\"link: http://freecellgamesolutions.com/\">FreeCell solutions to 1000000 games</a>.</p>",
        "<p class=\"rosetta__paragraph\">(Summon a video solution, and it displays the initial deal.)</p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function dealFreeCell (seed) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "// RNG\nfunction FreeCellRNG (seed) {\n  return {\n    lastNum: seed,\n    next() {\n      this.lastNum = ((214013 * this.lastNum) + 2531011) % (Math.pow(2, 31));\n      return this.lastNum >> 16;\n    }\n  };\n}\n// Get cards\nfunction getDeck() {\n  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'];\n  const suits = ['C', 'D', 'H', 'S'];\n  const cards = [];\n  for (let i = 0; i < ranks.length; i += 1) {\n    for (let j = 0; j < suits.length; j += 1) {\n      cards.push(`${ranks[i]}${suits[j]}`);\n    }\n  }\n  return cards;\n}\nfunction dealFreeCell(seed) {\n  const rng = FreeCellRNG(seed);\n  const deck = getDeck();\n\n  const deltCards = [[], [], [], [], [], [], []];\n  let currentColumn = 0;\n  let currentRow = 0;\n\n  let rand;\n  let temp;\n  let card;\n  while (deck.length > 0) {\n    // Choose a random card\n    rand = rng.next() % deck.length;\n\n    // Swap this random card with the last card in the array\n    temp = deck[deck.length - 1];\n    deck[deck.length - 1] = deck[rand];\n    deck[rand] = temp;\n\n    // Remove this card from the array\n    card = deck.pop();\n\n    // Deal this card\n    deltCards[currentRow].push(card);\n    currentColumn += 1;\n    if (currentColumn === 8) {\n      currentColumn = 0;\n      currentRow += 1;\n    }\n  }\n\n  return deltCards;\n}\n"
      ],
      "tail": [
        "const replaceThis = 3;",
        "const game1 = [",
        "  ['JD', '2D', '9H', 'JC', '5D', '7H', '7C', '5H'],",
        "  ['KD', 'KC', '9S', '5S', 'AD', 'QC', 'KH', '3H'],",
        "  ['2S', 'KS', '9D', 'QD', 'JS', 'AS', 'AH', '3C'],",
        "  ['4C', '5C', 'TS', 'QH', '4H', 'AC', '4D', '7S'],",
        "  ['3S', 'TD', '4S', 'TH', '8H', '2C', 'JH', '7D'],",
        "  ['6D', '8S', '8D', 'QS', '6C', '3D', '8C', 'TC'],",
        "  ['6S', '9C', '2H', '6H']",
        "];",
        "const game617 = [",
        "  ['7D', 'AD', '5C', '3S', '5S', '8C', '2D', 'AH'],",
        "  ['TD', '7S', 'QD', 'AC', '6D', '8H', 'AS', 'KH'],",
        "  ['TH', 'QC', '3H', '9D', '6S', '8D', '3D', 'TC'],",
        "  ['KD', '5H', '9S', '3C', '8S', '7H', '4D', 'JS'],",
        "  ['4C', 'QS', '9C', '9H', '7C', '6H', '2C', '2S'],",
        "  ['4S', 'TS', '2H', '5D', 'JC', '6C', 'JH', 'QH'],",
        "  ['JD', 'KS', 'KC', '4H']",
        "];"
      ],
      "tests": [
        "assert(typeof dealFreeCell === 'function', 'message: <code>dealFreeCell</code> is a function.');",
        "assert(typeof dealFreeCell(1) === 'object', 'message: <code>dealFreeCell(seed)</code> should return an object.');",
        "assert(dealFreeCell(1).length === 7, 'message: <code>dealFreeCell(seed)</code> should return an array of length 7.');",
        "assert.deepEqual(dealFreeCell(1), game1, 'message: <code>dealFreeCell(1)</code> should return an array identical to example \"Game #1\"');",
        "assert.deepEqual(dealFreeCell(617), game617, 'message: <code>dealFreeCell(617)</code> should return an array identical to example \"Game #617\"');"
      ],
      "id": "59694356a6e7011f7f1c5f4e"
    },
    {
      "title": "Deepcopy",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "benchmark": [],
      "description": [
        "<div class=\"rosetta\"><br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Write a function that returns a deep copy of a given object.</p>",
        "<p class=\"rosetta__paragraph\">The copy must not be the same object that was given.</p>",
        "<br /><p class=\"rosetta__paragraph\">This task will not test for: </p>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\">Objects with properties that are functions</li>",
        "<li class=\"rosetta__list-item--unordered\">Date objects or object with properties that are Date objects</li>",
        "<li class=\"rosetta__list-item--unordered\">RegEx or object with properties that are RegEx objects</li>",
        "<li class=\"rosetta__list-item--unordered\">Prototype copying</li>",
        "</ul>",
        "<br /><br />"
      ],
      "null": [],
      "challengeSeed": [
        "function deepcopy (obj) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function deepcopy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n"
      ],
      "tail": [
        "const obj1 = { test: 'test' };",
        "const obj2 = {",
        "  t: 'test',",
        "  a: ['an', 'array']",
        "};",
        "const obj3 = {",
        "  t: 'try',",
        "  o: obj2",
        "};"
      ],
      "tests": [
        "assert(typeof deepcopy === 'function', 'message: <code>deepcopy</code> should be a function.');",
        "assert(typeof deepcopy(obj1) === 'object', 'message: <code>deepcopy({test: \"test\"})</code> should return an object.');",
        "assert(deepcopy(obj2) != obj2, 'message: Should not return the same object that was provided.');",
        "assert.deepEqual(deepcopy(obj2), obj2, 'message: When passed an object containing an array, should return a deep copy of the object.');",
        "assert.deepEqual(deepcopy(obj3), obj3, 'message: When passed an object containing another object, should return a deep copy of the object.');"
      ],
      "id": "596a8888ab7c01048de257d5"
    },
    {
      "title": "Define a primitive data type",
      "type": "rosetta-code",
      "categories": "Type System",
      "difficulty": "3",
      "benchmark": [],
      "description": [
        "<div class=\"rosetta\"><br/>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Define a type that behaves like an integer but has a lowest valid value of 1 and a highest valid value of 10.</p>",
        "<br/>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Errors:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\">If you try to instantiate a <code>Num</code> with a value outside of 1 - 10",
        "it should throw a <code>TypeError</code> with an error message of <code>'Out of range'</code>.</li>",
        "<li class=\"rosetta__list-item--unordered\">If you try to instantiate a <code>Num</code> with a value that is not a number",
        "it should throw a <code>TypeError</code> with an error message of <code>'Not a Number'</code>.</li>",
        "</ul>",
        "<br />",
        "</div>"
      ],
      "challengeSeed": [
        "function Num (n) {",
        "  // Good luck!",
        "  return n;",
        "}"
      ],
      "solutions": [
        "function Num(n) {\n  const num = Math.floor(n);\n  if (isNaN(num)) {\n    throw new TypeError('Not a Number');\n  }\n  if (num < 1 || num > 10) {\n    throw new TypeError('Out of range');\n  }\n\n  this._value = num;\n}\nNum.prototype.valueOf = function() { return this._value; };\nNum.prototype.toString = function () { return this._value.toString(); };\n\nfunction throws(func, errorType, msg) {\n  let hasThrown = false;\n  let errorMsg = '';\n  let correctType = false;\n  try {\n    func();\n  }\n  catch (e) {\n    hasThrown = true;\n    errorMsg = e.message;\n    if (e instanceof errorType) {\n      correctType = true;\n    }\n  }\n  return hasThrown && correctType && msg === errorMsg;\n}\n"
      ],
      "tail": [],
      "tests": [
        "assert(typeof Num === 'function', 'message: <code>Num</code> should be a function.');",
        "assert(typeof (new Num(4)) === 'object', 'message: <code>new Num(4)</code> should return an object.');",
        "assert(throws(() => new Num('test'), TypeError, 'Not a Number'), 'message: <code>new Num(\\'test\\')</code> should throw a TypeError with message \\'Not a Number\\'.');",
        "assert(throws(() => new Num(0), TypeError, 'Out of range'), 'message: <code>new Num(0)</code> should throw a TypeError with message \\'Out of range\\'.');",
        "assert(throws(() => new Num(-5), TypeError, 'Out of range'), 'message: <code>new Num(-5)</code> should throw a TypeError with message \\'Out of range\\'.');",
        "assert(throws(() => new Num(11), TypeError, 'Out of range'), 'message: <code>new Num(10)</code> should throw a TypeError with message \\'Out of range\\'.');",
        "assert(throws(() => new Num(20), TypeError, 'Out of range'), 'message: <code>new Num(20)</code> should throw a TypeError with message \\'Out of range\\'.');",
        "assert.equal(new Num(3) + new Num(4), 7, 'message: <code>new Num(3) + new Num(4)</code> should equal 7.');",
        "assert.equal(new Num(3) - new Num(4), -1, 'message: <code>new Num(3) - new Num(4)</code> should equal -1.');",
        "assert.equal(new Num(3) * new Num(4), 12, 'message: <code>new Num(3) * new Num(4)</code> should equal 12.');",
        "assert.equal(new Num(3) / new Num(4), 0.75, 'message: <code>new Num(3) / new Num(4)</code> should equal 0.75.');",
        "assert(new Num(3) < new Num(4), 'message: <code>new Num(3) < new Num(4)</code> should be true.');",
        "assert(!(new Num(3) > new Num(4)), 'message: <code>new Num(3) > new Num(4)</code> should be false.');",
        "assert.equal((new Num(5)).toString(), '5', 'message: <code>(new Num(5)).toString()</code> should return \\'5\\'');"
      ],
      "id": "597089c87eec450c68aa1643"
    },
    {
      "title": "Department Numbers",
      "type": "rosetta-code",
      "categories": "Puzzles",
      "difficulty": "3",
      "benchmark": [],
      "description": [
        "<div class=\"rosetta\">",
        "<br/><p class=\"rosetta__paragraph\">There is a highly organized city that has decided to assign a number to each of their departments:</p>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\">Police department</li>",
        "<li class=\"rosetta__list-item--unordered\">Sanitation department</li>",
        "<li class=\"rosetta__list-item--unordered\">Fire department </li>",
        "</ul>",
        "<br/><p class=\"rosetta__paragraph\">Each department can have a number between <span class=\"rosetta__text--bold\">1</span> and <span class=\"rosetta__text--bold\">7</span>  (inclusive).</p><br/><p class=\"rosetta__paragraph\">The three department numbers are to be unique (different from each other) and must add up to the number <span class=\"rosetta__text--bold\">12</span>.</p><br/><p class=\"rosetta__paragraph\">The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Write a program which outputs all valid combinations:</p>",
        "<br/><p class=\"rosetta__paragraph\">[2, 3, 7]<br></p>",
        "<p class=\"rosetta__paragraph\">[2, 4, 6]</p>",
        "<p class=\"rosetta__paragraph\">[2, 6, 4]</p>",
        "<p class=\"rosetta__paragraph\">[2, 7, 3]</p>",
        "<p class=\"rosetta__paragraph\">[4, 1, 7]</p>",
        "<p class=\"rosetta__paragraph\">[4, 2, 6]</p>",
        "<p class=\"rosetta__paragraph\">[4, 3, 5]</p>",
        "<p class=\"rosetta__paragraph\">[4, 5, 3]</p>",
        "<p class=\"rosetta__paragraph\">[4, 6, 2]</p>",
        "<p class=\"rosetta__paragraph\">[4, 7, 1]</p>",
        "<p class=\"rosetta__paragraph\">[6, 1, 5]</p>",
        "<p class=\"rosetta__paragraph\">[6, 2, 4]</p>",
        "<p class=\"rosetta__paragraph\">[6, 4, 2]</p>",
        "<p class=\"rosetta__paragraph\">[6, 5, 1]</p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function combinations (possibleNumbers, total) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function combinations (possibleNumbers, total) {\n  let firstNumber;\n  let secondNumber;\n  let thridNumber;\n  const allCombinations = [];\n\n  for (let i = 0; i < possibleNumbers.length; i += 1) {\n    firstNumber = possibleNumbers[i];\n\n    if (firstNumber % 2 === 0) {\n      for (let j = 0; j < possibleNumbers.length; j += 1) {\n        secondNumber = possibleNumbers[j];\n\n        if (j !== i && firstNumber + secondNumber <= total) {\n          thridNumber = total - firstNumber - secondNumber;\n\n          if (thridNumber !== firstNumber && thridNumber !== secondNumber && possibleNumbers.includes(thridNumber)) {\n            allCombinations.push([firstNumber, secondNumber, thridNumber]);\n          }\n        }\n      }\n    }\n  }\n  return allCombinations;\n}\n"
      ],
      "tail": [
        "const nums = [1, 2, 3, 4, 5, 6, 7];",
        "const total = 12;",
        "const len = 14;",
        "const result = [",
        "  [2, 3, 7],",
        "  [2, 4, 6],",
        "  [2, 6, 4],",
        "  [2, 7, 3],",
        "  [4, 1, 7],",
        "  [4, 2, 6],",
        "  [4, 3, 5],",
        "  [4, 5, 3],",
        "  [4, 6, 2],",
        "  [4, 7, 1],",
        "  [6, 1, 5],",
        "  [6, 2, 4],",
        "  [6, 4, 2],",
        "  [6, 5, 1]",
        "];"
      ],
      "tests": [
        "assert(typeof combinations === 'function', 'message: <code>combinations</code> should be a function.');",
        "assert(Array.isArray(combinations([1, 2, 3], 6)), 'message: <code>combinations([1, 2, 3], 6)</code> should return an Array.');",
        "assert(combinations(nums, total).length === len, 'message: <code>combinations([1, 2, 3, 4, 5, 6, 7], 12)</code> should return an array of length 14.');",
        "assert.deepEqual(combinations(nums, total), result, 'message: <code>combinations([1, 2, 3, 4, 5, 6, 7], 12)</code> should return all valid combinations.');"
      ],
      "id": "59f40b17e79dbf1ab720ed7a"
    },
    {
      "title": "Determine if a string is numeric",
      "type": "rosetta-code",
      "categories": "Simple",
      "difficulty": "1",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included).</p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function isNumeric (n) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n"
      ],
      "tests": [
        "assert(typeof isNumeric === 'function', 'message: <code>isNumeric</code> should be a function.');",
        "assert(typeof isNumeric('20') === 'boolean', 'message: <code>isNumeric(\"20\")</code> should return a boolean');",
        "assert(isNumeric('-27.3'), 'message: <code>isNumeric(\"-27.3\")</code> should return true');",
        "assert(isNumeric('123.45e7'), 'message: <code>isNumeric(\"123.45e7\")</code> should return true');",
        "assert(isNumeric('testing') === false, 'message: <code>isNumeric(\"testing\")</code> should return false');",
        "assert(isNumeric('123.45e') === false, 'message: <code>isNumeric(\"123.45e7\")</code> should return false');"
      ],
      "id": "59f4d879ea42e9248e4c3152"
    },
    {
      "title": "Digital root",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "3",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">The digital root, $X$, of a number, $n$, is calculated:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> find $X$ as the sum of the digits of $n$</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> find a new $X$ by summing the digits of $X$, repeating until $X$ has only one digit.</span></p><br/><p class=\"rosetta__paragraph\">The additive persistence is the number of summations required to obtain the single digit.</p><br/><p class=\"rosetta__paragraph\">The task is to calculate the additive persistence and the digital root of a number, e.g.:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">$627615$ has additive persistence $2$ and digital root of $9$;</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">$39390$ has additive persistence $2$ and digital root of $6$;</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">$588225$ has additive persistence $2$ and digital root of $3$;</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">$393900588225$ has additive persistence $2$ and digital root of $9$;</span></p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function digitalRootBase (x) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function digitalRootBase(x) {\n  if (x < 10) {\n    return { additivePersistence: 0, digitalRoot: x };\n  }\n\n  let fauxroot = 0;\n  const numString = x.toString();\n  for (let i = 0; i < numString.length; i += 1) {\n    fauxroot += parseInt(numString[i], 10);\n  }\n\n  const rootobj = digitalRootBase(fauxroot);\n  rootobj.additivePersistence += 1;\n  return rootobj;\n}\n\n"
      ],
      "tests": [
        "assert(typeof digitalRootBase === 'function', 'message: <code>digitalRootBase</code> should be a function.');",
        "assert(typeof digitalRootBase(20) === 'object', 'message: <code>digitalRootBase(20)</code> should return an object.');",
        "assert.deepEqual(digitalRootBase(20), { additivePersistence: 1, digitalRoot: 2 }, 'message: <code>digitalRootBase(20)</code> should return <code>{ additivePersistence: 1, digitalRoot: 2 }</code>');",
        "assert.deepEqual(digitalRootBase(627615), { additivePersistence: 2, digitalRoot: 9 }, 'message: <code>digitalRootBase(627615)</code> should return <code>{ additivePersistence: 2, digitalRoot: 9 }</code>');",
        "assert.deepEqual(digitalRootBase(393900588228), { additivePersistence: 3, digitalRoot: 3 }, 'message: <code>digitalRootBase(393900588225)</code> should return <code>{ additivePersistence: 3, digitalRoot: 3 }</code>');"
      ],
      "id": "59f4dcf8c1e17225b8e6828b"
    },
    {
      "title": "Discordian date",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "5",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Convert a given date from the  <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Gregorian calendar\" title=\"wp: Gregorian calendar\">Gregorian calendar</a>  to the  <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Discordian calendar\" title=\"wp: Discordian calendar\">Discordian calendar</a>.</p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function discordianDate (date) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "/**\n * All Hail Discordia! - this script prints Discordian date using system date.\n *\n * lang: JavaScript\n * author: jklu\n * contributors: JamesMcGuigan\n *\n * source: https://rosettacode.org/wiki/Discordian_date#JavaScript\n */\nconst seasons = [\n  'Chaos', 'Discord', 'Confusion',\n  'Bureaucracy', 'The Aftermath'\n];\nconst weekday = [\n  'Sweetmorn', 'Boomtime', 'Pungenday',\n  'Prickle-Prickle', 'Setting Orange'\n];\n\nconst apostle = [\n  'Mungday', 'Mojoday', 'Syaday',\n  'Zaraday', 'Maladay'\n];\n\nconst holiday = [\n  'Chaoflux', 'Discoflux', 'Confuflux',\n  'Bureflux', 'Afflux'\n];\n\n\nDate.prototype.isLeapYear = function() {\n  const year = this.getFullYear();\n  if ((year & 3) !== 0) { return false; }\n  return ((year % 100) !== 0 || (year % 400) === 0);\n};\n\n// Get Day of Year\nDate.prototype.getDOY = function() {\n  const dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n  const mn = this.getMonth();\n  const dn = this.getDate();\n  let dayOfYear = dayCount[mn] + dn;\n  if (mn > 1 && this.isLeapYear()) { dayOfYear += 1; }\n  return dayOfYear;\n};\n\nDate.prototype.isToday = function() {\n  const today = new Date();\n  return this.getDate() === today.getDate()\n      && this.getMonth() === today.getMonth()\n      && this.getFullYear() === today.getFullYear()\n  ;\n};\n\nfunction discordianDate(date) {\n  if (!date) { date = new Date(); }\n\n  const y = date.getFullYear();\n  const yold = y + 1166;\n  let dayOfYear = date.getDOY();\n  let celebrateHoliday = null;\n\n  if (date.isLeapYear()) {\n    if (dayOfYear === 60) {\n      celebrateHoliday = 'St. Tib\\'s Day';\n    }\n    else if (dayOfYear > 60) {\n      dayOfYear--;\n    }\n  }\n  dayOfYear--;\n\n  const divDay = Math.floor(dayOfYear / 73);\n\n  const seasonDay = (dayOfYear % 73) + 1;\n  if (seasonDay === 5) {\n    celebrateHoliday = apostle[divDay];\n  }\n  if (seasonDay === 50) {\n    celebrateHoliday = holiday[divDay];\n  }\n\n  const season = seasons[divDay];\n  const dayOfWeek = weekday[dayOfYear % 5];\n\n  const nth = (seasonDay % 10 === 1) ? 'st'\n          : (seasonDay % 10 === 2) ? 'nd'\n          : (seasonDay % 10 === 3) ? 'rd'\n                                  : 'th';\n\n  return ''\n         + dayOfWeek\n         + ', the ' + seasonDay + nth\n         + ' day of ' + season\n         + ' in the YOLD ' + yold\n         + (celebrateHoliday ? '. Celebrate ' + celebrateHoliday + '!' : '')\n    ;\n}\n\n"
      ],
      "tests": [
        "assert(typeof discordianDate === 'function', 'message: <code>discordianDate</code> is a function.');",
        "assert(discordianDate(new Date(2010, 6, 22)) === 'Pungenday, the 57th day of Confusion in the YOLD 3176', 'message: <code>discordianDate(new Date(2010, 6, 22))</code> should return <code>\"Pungenday, the 57th day of Confusion in the YOLD 3176\"</code>.');",
        "assert(discordianDate(new Date(2012, 1, 28)) === 'Prickle-Prickle, the 59th day of Chaos in the YOLD 3178', 'message: <code>discordianDate(new Date(2012, 1, 28))</code> should return <code>\"Prickle-Prickle, the 59th day of Chaos in the YOLD 3178\"</code>.');",
        "assert(discordianDate(new Date(2012, 1, 29)) === 'Setting Orange, the 60th day of Chaos in the YOLD 3178. Celebrate St. Tib\\'s Day!', 'message: <code>discordianDate(new Date(2012, 1, 29))</code> should return <code>\"Setting Orange, the 60th day of Chaos in the YOLD 3178. Celebrate St. Tib\\'s Day!\"</code>.');",
        "assert(discordianDate(new Date(2012, 2, 1)) === 'Setting Orange, the 60th day of Chaos in the YOLD 3178', 'message: <code>discordianDate(new Date(2012, 2, 1))</code> should return <code>\"Setting Orange, the 60th day of Chaos in the YOLD 3178\"</code>.');",
        "assert(discordianDate(new Date(2010, 0, 5)) === 'Setting Orange, the 5th day of Chaos in the YOLD 3176. Celebrate Mungday!', 'message: <code>discordianDate(new Date(2010, 0, 5))</code> should return <code>\"Setting Orange, the 5th day of Chaos in the YOLD 3176. Celebrate Mungday!\"</code>.');",
        "assert(discordianDate(new Date(2011, 4, 3)) === 'Pungenday, the 50th day of Discord in the YOLD 3177. Celebrate Discoflux!', 'message: <code>discordianDate(new Date(2011, 4, 3))</code> should return <code>\"Pungenday, the 50th day of Discord in the YOLD 3177. Celebrate Discoflux!\"</code>.');",
        "assert(discordianDate(new Date(2015, 9, 19)) === 'Boomtime, the 73rd day of Bureaucracy in the YOLD 3181', 'message: <code>discordianDate(new Date(2015, 9, 19))</code> should return <code>\"Boomtime, the 73rd day of Bureaucracy in the YOLD 3181\"</code>.');"
      ],
      "id": "59f4eafba0343628bb682785"
    },
    {
      "title": "Element-wise operations",
      "type": "rosetta-code",
      "categories": "Mathematics",
      "difficulty": "3",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Implement basic element-wise matrix-matrix and scalar-matrix operations.</p><p class=\"rosetta__paragraph\">Implement:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  addition</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  subtraction</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  multiplication</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  division</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  exponentiation</span></p>",
        "<p>The first parameter will be the operation to be performed, for example : \"m_add\" for matrix addition and \"s_add\" for scalar addition. The second and third parameters will be the matrices on which the operations are to be performed.",
        "</div>"
      ],
      "challengeSeed": [
        "function operation (op, arr1, arr2) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function operation(op, arr1, arr2) {\n  const ops = {\n    add: ((a, b) => a + b),\n    sub: ((a, b) => a - b),\n    mult: ((a, b) => a * b),\n    div: ((a, b) => a / b),\n    exp: ((a, b) => Math.pow(a, b))\n  };\n  const ifm = op.startsWith('m');\n  const doOp = ops[op.substring(2)];\n  for (let i = 0; i < arr1.length; i++) {\n    for (let j = 0; j < arr1[0].length; j++) {\n      arr1[i][j] = doOp(arr1[i][j], (ifm) ? (arr2[i][j]) : (arr2));\n    }\n  }\n  return arr1;\n}\n"
      ],
      "tests": [
        "assert(typeof operation === 'function', 'message: <code>operation</code> is a function.');",
        "assert.deepEqual(operation('m_add', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[2, 4], [6, 8]], 'message: <code>operation(\"m_add\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[2,4],[6,8]]</code>.');",
        "assert.deepEqual(operation('s_add', [[1, 2], [3, 4]], 2), [[3, 4], [5, 6]], 'message: <code>operation(\"s_add\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[3,4],[5,6]]</code>.');",
        "assert.deepEqual(operation('m_sub', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[0, 0], [0, 0]], 'message: <code>operation(\"m_sub\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[0,0],[0,0]]</code>.');",
        "assert.deepEqual(operation('m_mult', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[1, 4], [9, 16]], 'message: <code>operation(\"m_mult\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[1,4],[9,16]]</code>.');",
        "assert.deepEqual(operation('m_div', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[1, 1], [1, 1]], 'message: <code>operation(\"m_div\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[1,1],[1,1]]</code>.');",
        "assert.deepEqual(operation('m_exp', [[1, 2], [3, 4]], [[1, 2], [3, 4]]), [[1, 4], [27, 256]], 'message: <code>operation(\"m_exp\",[[1,2],[3,4]],[[1,2],[3,4]])</code> should return <code>[[1,4],[27,256]]</code>.');",
        "assert.deepEqual(operation('m_add', [[1, 2, 3, 4], [5, 6, 7, 8]], [[9, 10, 11, 12], [13, 14, 15, 16]]), [[10, 12, 14, 16], [18, 20, 22, 24]], 'message: <code>operation(\"m_add\",[[1,2,3,4],[5,6,7,8]],[[9,10,11,12],[13,14,15,16]])</code> should return <code>[[10,12,14,16],[18,20,22,24]]</code>.');"
      ],
      "id": "599c333915e0ea32d04d4bec"
    },
    {
      "title": "Emirp primes",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "4",
      "benchmark": "emirps(10000);",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">An  <span class=\"rosetta__text--italic\">emirp</span>  (<span class=\"rosetta__text--bold\">prime</span> spelled backwards)  are primes that when reversed  (in their decimal representation)  are a different prime.</p>",
        "<p class=\"rosetta__paragraph\">Write a function that should be able to : <ul><li>Show the first <b>n</b> eprimes numbers.</li><li>Show the eprimes numbers in a range.</li><li>Show the number of eprimes in a range.</li><li>Show the <b>n<sup>th</sup></b> eprimes number.</li></ul><p>The function should have two paramters. The first will recieve <b>n</b> or the range as an array. The second will recieve a boolean, that specifies if the function returns the eprimes as an array or a single number(the number of primes in the range or the <b>n<sup>th</sup></b> prime). According to the parameters the function should return an array or a number.</div>"
      ],
      "null": [],
      "challengeSeed": [
        "function emirps(n) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "// noprotect\nfunction emirps(num, showEmirps)\n{\n  const is_prime = function(n)\n\t{\n    if (!(n % 2) || !(n % 3)) return false;\n    let p = 1;\n    while (p * p < n)\n\t\t\t        { if (n % (p += 4) == 0 || n % (p += 2) == 0)\n\t\t\t                { return false; } }\n    return true;\n  };\n  const is_emirp = function(n) {\n    const r = parseInt(n.toString().split('').reverse().join(''));\n    return r != n && is_prime(n) && is_prime(r);\n  };\n\n  let i,\n    arr = [];\n  if (typeof num === 'number') {\n    for (i = 0; arr.length < num; i++) if (is_emirp(i)) arr.push(i);\n    // first x emirps\n    if (showEmirps) return arr;\n    // xth emirp\n    return arr.pop();\n  }\n\n  if (Array.isArray(num)) {\n    for (i = num[0]; i <= num[1]; i++) if (is_emirp(i)) arr.push(i);\n    // emirps between x .. y\n    if (showEmirps) return arr;\n    // number of emirps between x .. y\n    return arr.length;\n  }\n}\n"
      ],
      "tests": [
        "assert(typeof emirps === 'function', 'message: <code>emirps</code> is a function.');",
        "assert.deepEqual(emirps(20, true), [13, 17, 31, 37, 71, 73, 79, 97, 107, 113, 149, 157, 167, 179, 199, 311, 337, 347, 359, 389], 'message:<code>emirps(20,true)</code> should return <code>[13,17,31,37,71,73,79,97,107,113,149,157,167,179,199,311,337,347,359,389]</code>');",
        "assert.deepEqual(emirps(10000), 948349, 'message:<code>emirps(10000)</code> should return <code>948349</code>');",
        "assert.deepEqual(emirps([7700, 8000], true), [7717, 7757, 7817, 7841, 7867, 7879, 7901, 7927, 7949, 7951, 7963], 'message:<code>emirps([7700,8000],true)</code> should return <code>[7717,7757,7817,7841,7867,7879,7901,7927,7949,7951,7963]</code>');",
        "assert.deepEqual(emirps([7700, 8000], false), 11, 'message:<code>emirps([7700,8000],true)</code> should return <code>11</code>');"
      ],
      "id": "599d0ba974141b0f508b37d5"
    },
    {
      "title": "Entropy",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\"><br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Calculate the Shannon entropy  H  of a given input string.</p><br/><p class=\"rosetta__paragraph\">Given the discreet random variable $X$ that is a string of $N$ \"symbols\" (total characters) consisting of $n$ different characters (n=2 for binary), the Shannon entropy of X in <span class=\"rosetta__text--bold\">bits/symbol</span> is :</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">$H_2(X) = -\\sum_{i=1}^n \\frac{count_i}{N} \\log_2 \\left(\\frac{count_i}{N}\\right)$</span></p><br/><p class=\"rosetta__paragraph\">where $count_i$ is the count of character $n_i$.</p><br/></div>"
      ],
      "challengeSeed": [
        "function entropy (s) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function entropy(s) {\n\t// Create a dictionary of character frequencies and iterate over it.\n  function process(s, evaluator) {\n    let h = Object.create(null),\n      k;\n    s.split('').forEach(c => {\n      h[c] && h[c]++ || (h[c] = 1); });\n    if (evaluator) for (k in h) evaluator(k, h[k]);\n    return h;\n  }\n\t// Measure the entropy of a string in bits per symbol.\n\n  let sum = 0,\n    len = s.length;\n  process(s, (k, f) => {\n    const p = f / len;\n    sum -= p * Math.log(p) / Math.log(2);\n  });\n  return sum;\n}\n"
      ],
      "tests": [
        "assert(typeof entropy === 'function', 'message: <code>entropy</code> is a function.');",
        "assert.equal(entropy('0'), 0, 'message: <code>entropy(\"0\")</code> should return <code>0</code>');",
        "assert.equal(entropy('01'), 1, 'message: <code>entropy(\"01\")</code> should return <code>1</code>');",
        "assert.equal(entropy('0123'), 2, 'message: <code>entropy(\"0123\")</code> should return <code>2</code>');",
        "assert.equal(entropy('01234567'), 3, 'message: <code>entropy(\"01234567\")</code> should return <code>3</code>');",
        "assert.equal(entropy('0123456789abcdef'), 4, 'message: <code>entropy(\"0123456789abcdef\")</code> should return <code>4</code>');",
        "assert.equal(entropy('1223334444'), 1.8464393446710154, 'message: <code>entropy(\"1223334444\")</code> should return <code>1.8464393446710154</code>');"
      ],
      "id": "599d15309e88c813a40baf58"
    },
    {
      "title": "Equilibrium index",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.</p>",
        "<br/><p class=\"rosetta__paragraph\">For example, in a sequence  <big>$A$</big>:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::::  <big>$A_0 = -7$</big></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::::  <big>$A_1 =  1$</big></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::::  <big>$A_2 =  5$</big></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::::  <big>$A_3 =  2$</big></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::::  <big>$A_4 = -4$</big></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::::  <big>$A_5 =  3$</big></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::::  <big>$A_6 =  0$</big></span></p><br/><p class=\"rosetta__paragraph\">3  is an equilibrium index, because:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::::  <big>$A_0 + A_1 + A_2 = A_4 + A_5 + A_6$</big></span></p><br/><p class=\"rosetta__paragraph\">6  is also an equilibrium index, because:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::::  <big>$A_0 + A_1 + A_2 + A_3 + A_4 + A_5 = 0$</big></span></p><br/><p class=\"rosetta__paragraph\">(sum of zero elements is zero)</p><br/><p class=\"rosetta__paragraph\">7  is not an equilibrium index, because it is not a valid index of sequence <big>$A$</big>.</p>",
        "<br/>",
        "<p class=\"rosetta__paragraph\">Write a function that, given a sequence, returns its equilibrium indices (if any).</p><br/><p class=\"rosetta__paragraph\">Assume that the sequence may be very long.</p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function equilibrium (a) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function equilibrium(a) {\n  let N = a.length,\n    i,\n    l = [],\n    r = [],\n    e = [];\n  for (l[0] = a[0], r[N - 1] = a[N - 1], i = 1; i < N; i++)\n    { l[i] = l[i - 1] + a[i], r[N - i - 1] = r[N - i] + a[N - i - 1]; }\n  for (i = 0; i < N; i++)\n    { if (l[i] === r[i]) e.push(i); }\n  return e;\n}\n"
      ],
      "tail": [
        "const tests =",
        "  [[-7, 1, 5, 2, -4, 3, 0], // 3, 6",
        "  [2, 4, 6], // empty",
        "  [2, 9, 2], // 1",
        "  [1, -1, 1, -1, 1, -1, 1], // 0,1,2,3,4,5,6",
        "  [1], // 0",
        "  [] // empty",
        "  ];",
        "const ans = [[3, 6], [], [1], [0, 1, 2, 3, 4, 5, 6], [0], []];"
      ],
      "tests": [
        "assert(typeof equilibrium === 'function', 'message: <code>equilibrium</code> is a function.');",
        "assert.deepEqual(equilibrium(tests[0]), ans[0], 'message: <code>equilibrium([-7, 1, 5, 2, -4, 3, 0])</code> should return <code>[3,6]</code>.');",
        "assert.deepEqual(equilibrium(tests[1]), ans[1], 'message: <code>equilibrium([2, 4, 6])</code> should return <code>[]</code>.');",
        "assert.deepEqual(equilibrium(tests[2]), ans[2], 'message: <code>equilibrium([2, 9, 2])</code> should return <code>[1]</code>.');",
        "assert.deepEqual(equilibrium(tests[3]), ans[3], 'message: <code>equilibrium([1, -1, 1, -1, 1, -1, 1])</code> should return <code>[0,1,2,3,4,5,6]</code>.');",
        "assert.deepEqual(equilibrium(tests[4]), ans[4], 'message: <code>equilibrium([1])</code> should return <code>[0]</code>.');",
        "assert.deepEqual(equilibrium(tests[5]), ans[5], 'message: <code>equilibrium([])</code> should return <code>[]</code>.');"
      ],
      "id": "5987fd532b954e0f21b5d3f6"
    },
    {
      "title": "Ethiopian multiplication",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.</p>",
        "<br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--bold\">Method:</span> <br></p>",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Take two numbers to be multiplied and write them down at the top of two columns.</li>",
        "<li class=\"rosetta__list-item--ordered\">In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1.</li>",
        "<li class=\"rosetta__list-item--ordered\">In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1.</li>",
        "<li class=\"rosetta__list-item--ordered\">Examine the table produced and discard any row where the value in the left column is even.</li>",
        "<li class=\"rosetta__list-item--ordered\">Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together</li></ol>",
        "<br>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--bold\">For example:</span>  17 &times; 34</p>",
        "<p class=\"rosetta__paragraph\">17    34</p>",
        "<p class=\"rosetta__paragraph\">Halving the first column:</p>",
        "<p class=\"rosetta__paragraph\">17    34</p>",
        "<p class=\"rosetta__paragraph\">8</p>",
        "<p class=\"rosetta__paragraph\">4</p>",
        "<p class=\"rosetta__paragraph\">2</p>",
        "<p class=\"rosetta__paragraph\">1</p>",
        "<p class=\"rosetta__paragraph\">Doubling the second column:</p>",
        "<p class=\"rosetta__paragraph\">17    34</p>",
        "<p class=\"rosetta__paragraph\">8    68</p>",
        "<p class=\"rosetta__paragraph\">4   136</p>",
        "<p class=\"rosetta__paragraph\">2   272</p>",
        "<p class=\"rosetta__paragraph\">1   544</p>",
        "<p class=\"rosetta__paragraph\">Strike-out rows whose first cell is even:</p>",
        "<p class=\"rosetta__paragraph\">17    34</p>",
        "<p class=\"rosetta__paragraph\">8    <strike>68</strike></p>",
        "<p class=\"rosetta__paragraph\">4   <strike>136</strike></p>",
        "<p class=\"rosetta__paragraph\">2   <strike>272</strike></p>",
        "<p class=\"rosetta__paragraph\">1   544</p>",
        "<p class=\"rosetta__paragraph\">Sum the remaining numbers in the right-hand column:</p>",
        "<p class=\"rosetta__paragraph\">17    34</p>",
        "<p class=\"rosetta__paragraph\">8    --</p>",
        "<p class=\"rosetta__paragraph\">4   ---</p>",
        "<p class=\"rosetta__paragraph\">2   ---</p>",
        "<p class=\"rosetta__paragraph\">1   544</p>",
        "<p class=\"rosetta__paragraph\">====</p>",
        "<p class=\"rosetta__paragraph\">578</p>",
        "<p class=\"rosetta__paragraph\">So 17 multiplied by 34, by the Ethiopian method is 578.</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">The task is to <span class=\"rosetta__text--bold\">define three named functions</span>/methods/procedures/subroutines:</p>",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">one to <span class=\"rosetta__text--bold\">halve an integer</span>,</li>",
        "<li class=\"rosetta__list-item--ordered\">one to <span class=\"rosetta__text--bold\">double an integer</span>, and</li>",
        "<li class=\"rosetta__list-item--ordered\">one to <span class=\"rosetta__text--bold\">state if an integer is even</span>.</li></ol>",
        "<br>",
        "<p class=\"rosetta__paragraph\">Use these functions to <span class=\"rosetta__text--bold\">create a function that does Ethiopian multiplication</span>.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function eth_mult (a, b) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function eth_mult(a, b) {\n  let sum = 0; a = [a]; b = [b];\n\n  let half = a => a / 2,\n    double = a => a * 2,\n    is_even = a => a % 2 == 0;\n\n  while (a[0] !== 1) {\n    a.unshift(Math.floor(half(a[0])));\n    b.unshift(double(b[0]));\n  }\n\n  for (let i = a.length - 1; i > 0; i -= 1) {\n    if (!is_even(a[i])) {\n      sum += b[i];\n    }\n  }\n  return sum + b[0];\n}"
      ],
      "tests": [
        "assert(typeof eth_mult === 'function', 'message: <code>eth_mult</code> is a function.');",
        "assert.equal(eth_mult(17, 34), 578, 'message: <code>eth_mult(17,34)</code> should return <code>578</code>.');",
        "assert.equal(eth_mult(23, 46), 1058, 'message: <code>eth_mult(23,46)</code> should return <code>1058</code>.');",
        "assert.equal(eth_mult(12, 27), 324, 'message: <code>eth_mult(12,27)</code> should return <code>324</code>.');",
        "assert.equal(eth_mult(56, 98), 5488, 'message: <code>eth_mult(56,98)</code> should return <code>5488</code>.');",
        "assert.equal(eth_mult(63, 74), 4662, 'message: <code>eth_mult(63,74)</code> should return <code>4662</code>.');"
      ],
      "id": "599d1566a02b571412643b84"
    },
    {
      "title": "Euler method",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">Euler's method numerically approximates solutions of first-order ordinary differential equations (ODEs) with a given initial value.  It is an explicit method for solving initial value problems (IVPs), as described in <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Euler method\" title=\"wp: Euler method\">the wikipedia page</a>.</p><br/><p class=\"rosetta__paragraph\">The ODE has to be provided in the following form:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">:: <big>$\\frac{dy(t)}{dt} = f(t,y(t))$</big></span></p><br/><p class=\"rosetta__paragraph\">with an initial value</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">:: <big>$y(t_0) = y_0$</big></span></p><br/><p class=\"rosetta__paragraph\">To get a numeric solution, we replace the derivative on the  LHS  with a finite difference approximation:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">:: <big>$\\frac{dy(t)}{dt}  \\approx \\frac{y(t+h)-y(t)}{h}$</big></span></p><br/><p class=\"rosetta__paragraph\">then solve for $y(t+h)$:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">:: <big>$y(t+h) \\approx y(t) + h \\, \\frac{dy(t)}{dt}$</big></span></p><br/><p class=\"rosetta__paragraph\">which is the same as</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">:: <big>$y(t+h) \\approx y(t) + h \\, f(t,y(t))$</big></span></p><br/><p class=\"rosetta__paragraph\">The iterative solution rule is then:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">:: <big>$y_{n+1} = y_n + h \\, f(t_n, y_n)$</big></span></p><br/><p class=\"rosetta__paragraph\">where  <big>$h$</big>  is the step size, the most relevant parameter for accuracy of the solution.  A smaller step size increases accuracy but also the computation cost, so it has always has to be hand-picked according to the problem at hand.</p>",
        "<br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--bold\">Example: Newton's Cooling Law</span></p><br/><p class=\"rosetta__paragraph\">Newton's cooling law describes how an object of initial temperature  <big>$T(t_0) = T_0$</big>  cools down in an environment of temperature  <big>$T_R$</big>:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">:: <big>$\\frac{dT(t)}{dt} = -k \\, \\Delta T$</big></span></p>",
        "<p class=\"rosetta__paragraph\">or</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">:: <big>$\\frac{dT(t)}{dt} = -k \\, (T(t) - T_R)$</big></span></p><br/><br>",
        "<p class=\"rosetta__paragraph\">It says that the cooling rate  <big>$\\frac{dT(t)}{dt}$</big>  of the object is proportional to the current temperature difference  <big>$\\Delta T = (T(t) - T_R)$</big>  to the surrounding environment.</p><br/><p class=\"rosetta__paragraph\">The analytical solution, which we will compare to the numerical approximation, is</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">:: <big>$T(t) = T_R + (T_0 - T_R) \\; e^{-k t}$</big></span></p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Implement a routine of Euler's method and then to use it to solve the given example of Newton's cooling law with it for three different step sizes of:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  2 s</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  5 s    and </span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  10 s </span></p>",
        "<p class=\"rosetta__paragraph\">and to compare with the analytical solution.</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Initial values:</dt></dl>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  initial temperature  <big>$T_0$</big>  shall be  100 °C</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  room temperature  <big>$T_R$</big>  shall be  20 °C</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  cooling constant   <big>$k$</big>   shall be  0.07  </span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  time interval to calculate shall be from  0 s  ──►  100 s</span></p></div>"
      ],
      "challengeSeed": [
        "function eulersMethod (x1, y1, x2, h) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function eulersMethod(x1, y1, x2, h) {\n  let x = x1;\n  let y = y1;\n\n  while ((x < x2 && x1 < x2) || (x > x2 && x1 > x2)) {\n    y += h * (-0.07 * (y - 20));\n    x += h;\n  }\n\n  return y;\n}\n"
      ],
      "tests": [
        "assert(typeof eulersMethod === 'function', 'message: <code>eulersMethod</code> is a function.');",
        "assert(typeof eulersMethod(0, 100, 100, 10) === 'number', 'message: <code>eulersMethod(0, 100, 100, 10)</code> should return a number.');",
        "assert.equal(eulersMethod(0, 100, 100, 2), 20.0424631833732, 'message: <code>eulersMethod(0, 100, 100, 10)</code> should return 20.0424631833732.');",
        "assert.equal(eulersMethod(0, 100, 100, 5), 20.01449963666907, 'message: <code>eulersMethod(0, 100, 100, 10)</code> should return 20.01449963666907.');",
        "assert.equal(eulersMethod(0, 100, 100, 10), 20.000472392, 'message: <code>eulersMethod(0, 100, 100, 10)</code> should return 20.000472392.');"
      ],
      "id": "59880443fb36441083c6c20e"
    },
    {
      "title": "Evaluate binomial coefficients",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Write a function to calculate the binomial coefficient for the given value of n and k.</p><br/><p class=\"rosetta__paragraph\">This formula is recommended:</p>",
        "$\\binom{n}{k} = \\frac{n!}{(n-k)!k!} = \\frac{n(n-1)(n-2)\\ldots(n-k+1)}{k(k-1)(k-2)\\ldots 1}$</div>"
      ],
      "challengeSeed": [
        "function binom (n, k) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function binom(n, k) {\n  let coeff = 1;\n  for (let i = n - k + 1; i <= n; i++) coeff *= i;\n  for (let i = 1; i <= k; i++) coeff /= i;\n  return coeff;\n}\n"
      ],
      "tests": [
        "assert(typeof binom === 'function', 'message: <code>binom</code> is a function.');",
        "assert.equal(binom(5, 3), 10, 'message: <code>binom(5,3)</code> should return 10.');",
        "assert.equal(binom(7, 2), 21, 'message: <code>binom(7,2)</code> should return 21.');",
        "assert.equal(binom(10, 4), 210, 'message: <code>binom(10,4)</code> should return 210.');",
        "assert.equal(binom(6, 1), 6, 'message: <code>binom(6,1)</code> should return 6.');",
        "assert.equal(binom(12, 8), 495, 'message: <code>binom(12,8)</code> should return 495.');"
      ],
      "id": "598de241872ef8353c58a7a2"
    },
    {
      "title": "Execute Brain****",
      "type": "rosetta-code",
      "categories": "Compilers and Interpreters",
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\"><br/>",
        "<p class=\"rosetta_paragraph\">Write a function to implement a Brain**** interpreter. The function will take a string as a parameter and should return a string as the output. More details are given below : </p>",
        "<p class=\"rosetta__paragraph\">RCBF is a set of <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Brainf***\" title=\"Brainf***\">Brainf***</a> compilers and interpreters written for Rosetta Code in a variety of languages.</p><br/><p class=\"rosetta__paragraph\">Below are links to each of the versions of RCBF.</p><br/><p class=\"rosetta__paragraph\">An implementation need only properly implement the following instructions:</p>",
        "<p class=\"rosetta__paragraph\">{| class=\"wikitable\"</p>",
        "<p class=\"rosetta__paragraph\">!Command</p>",
        "<p class=\"rosetta__paragraph\">!Description</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">| style=\"text-align:center\"| <code>&gt;</code> || Move the pointer to the right</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">| style=\"text-align:center\"| <code>&lt;</code> || Move the pointer to the left</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">| style=\"text-align:center\"| <code>+</code> || Increment the memory cell under the pointer</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">| style=\"text-align:center\"| <code>-</code> || Decrement the memory cell under the pointer</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">| style=\"text-align:center\"| <code>.</code> || Output the character signified by the cell at the pointer</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">| style=\"text-align:center\"| <code>,</code> || Input a character and store it in the cell at the pointer</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">| style=\"text-align:center\"| <code>[</code> || Jump past the matching <code>]</code> if the cell under the pointer is 0</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">| style=\"text-align:center\"| <code>]</code> || Jump back to the matching <code>[</code> if the cell under the pointer is nonzero</p>",
        "<p class=\"rosetta__paragraph\">|}</p>",
        "<p class=\"rosetta__paragraph\">Any cell size is allowed,  EOF   (<u>E</u>nd-<u>O</u>-<u>F</u>ile)  support is optional, as is whether you have bounded or unbounded memory.</p>",
        "<br><br> <br/></div>"
      ],
      "challengeSeed": [
        "function brain (prog) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function brain(prog){\n  var output=\"\";\n\tvar code; // formatted code\n  var ip = 0; // current instruction within code\n  var nest = 0; // current bracket nesting (for Out button)\n  var ahead = []; // locations of matching brackets\n\n  var data = [0]; // data array (mod by +, -)\n  var dp = 0; // index into data (mod by <, >)\n\n  var inp = 0; // current input character (fetch with ,)\n  var quit = 0;\n\tvar commands = {\n\t'>':function() { if (++dp >= data.length) data[dp]=0 },\n\t'<':function() { if (--dp < 0) quit++ },\n\t'+':function() { ++data[dp] },\n\t'-':function() { --data[dp] },\n\t'[':function() { if (!data[dp]) ip = ahead[ip]; else ++nest },\n\t']':function() { if ( data[dp]) ip = ahead[ip]; else --nest },\n\t',':function() {\n\t\tvar c = document.getElementById(\"input\").value.charCodeAt(inp++);\n\t\tdata[dp] = isNaN(c) ? 0 : c; // EOF: other options are -1 or no change\n\t},\n\t'.':function() {\n    \t\toutput+=String.fromCharCode(data[dp]);\n    \t\t/*var s = document.getElementById(\"output\").innerHTML)\n    \t\t + String.fromCharCode(data[dp]);\n    \t\ts = s.replace(/\\n/g,\"<br>\").replace(/ /g,\"&amp;nbsp;\");\n    \t\tdocument.getElementById(\"output\").innerHTML = s;*/\n    \t},\n    };\n\n\tlet ar=prog.split('');\n\tvar st = [], back, error = -1;\n\tfor (ip=0; ip<ar.length; ip++) {\n\t\tswitch(ar[ip]) {\n\t\tcase '[':\n\t\t\tst.push(ip);\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tif (st.length == 0) error = ip;\n\t\t\tback = st.pop();\n\t\t\tahead[ip] = back;\n\t\t\tahead[back] = ip;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(ip=0;ip<ar.length;ip++){\n    if(commands.hasOwnProperty(ar[ip]))\n\t\t  commands[ar[ip]]();\n\t}\n\n\treturn output;\n}\n\n// tail:\nlet bye=\"++++++++++[>+>+++>++++>+++++++>++++++++>+++++++++>++++++++++>+++++++++++>++++++++++++<<<<<<<<<-]>>>>+.>>>>+..<.<++++++++.>>>+.<<+.<<<<++++.<++.>>>+++++++.>>>.+++.<+++++++.--------.<<<<<+.<+++.---.\";\nlet hello=\"++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.\";\nlet fib=`+\n\n++\n\n+++\n\n++++\n\n+>+>>\n\n>>++++\n\n+++++++\n\n++++++++\n\n+++++++++\n\n++++++++++\n\n++++++>++++\n\n++++++++++++\n\n+++++++++++++\n\n+++<<<<<<[>[>>\n\n>>>>+>+<<<<<<<-\n\n]>>>>>>>[<<<<<<<\n\n+>>>>>>>-]<[>++++\n\n++++++[-<-[>>+>+<<\n\n<-]>>>[<<<+>>>-]+<[\n\n>[-]<[-]]>[<<[>>>+<<\n\n<-]>>[-]]<<]>>>[>>+>+\n\n<<<-]>>>[<<<+>>>-]+<[>\n\n[-]<[-]]>[<<+>>[-]]<<<<\n\n<<<]>>>>>[++++++++++++++\n\n+++++++++++++++++++++++++\n\n+++++++++.[-]]++++++++++<[\n\n->-<]>+++++++++++++++++++++\n\n+++++++++++++++++++++++++++.\n\n[-]<<<<<<<<<<<<[>>>+>+<<<<-]>\n\n>>>[<<<<+>>>>-]<-[>>.>.<<<[-]]\n\n<<[>>+>+<<<-]>>>[<<<+>>>-]<<[<+\n\n>-]>[<+>-]<<<-]`;\n"
      ],
      "tests": [
        "assert(typeof brain(bye)=='string','');",
        "assert(typeof brain(hello)=='string','');",
        "assert.equal(brain(\"++++++[>++++++++++<-]>+++++.\"),\"A\",'');",
        "assert.equal(brain(bye),\"Goodbye, World!\\r\\n\",'<code>brain('+bye+')</code> should return <code>Goodbye, World!\\\\r\\\\n</code>');",
        "assert.equal(brain(hello),\"Hello World!\\n\",'<code>brain('+hello+')</code> should return <code>Hello World!\\n</code>');",
        "assert.equal(brain(fib),\"1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89\",'<code>brain('+fib+')</code> should return <code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</code>');"
      ],
      "id": "59e0a8df964e4540d5abe599"
    },
    {
      "title": "Execute SNUSP",
      "type": "rosetta-code",
      "categories": "Compilers and Interpreters",
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">SNUSP (SNUSP's Not Unix, but a Structured Path) is a language with a two-dimensional code space, inspired by PATH. SNUSP is more orthogonal, specifies semantics more concretely, and optionally allows more advanced features.</p>",
        "<p>Write a function that takes a string as input. This string will be SNUSP code and the function should return the output of the SNUSP code as another string. You can read about SNUSP <a href=\"https://esolangs.org/wiki/SNUSP\">here</a>.</p>",
        "<p>Note : <ol><li>You need not implement the ',' command.<li>For the last test case, the input has newline characters at appropriate places. Also the output \"Hello world\" also have a newline character at the end.</ol></p></div>"
      ],
      "null": [],
      "challengeSeed": [
        "function snuspfcc (codestr) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function snusp(codestr){\n  codestr.replace(\"\\\\\",\"\\\\\\\\\");\n  var code = \"#\";     // formatted code\n  var width;          // length of each line in code\n  var ip = 0;         // current instruction within code (mod by $, ?, !, #)\n  var dir = 1;        // current direction (mod by /, \\, #)\n\n  var data = [0];     // data array (mod by +, -)\n  var dp = 0;         // index into data (mod by <, >)\n\n  var inp = 0;        // current input character (fetch with ,)\n  var quit = 0;       // termination flag\n\n  var stack = [];     // call stack (mod by @, #)\n  var snout=\"\";\n  var commands = {\n    '>':function() { if (++dp >= data.length) data[dp]=0 },\n    '<':function() { if (--dp < 0) quit++ },\n    '+':function() { ++data[dp] },\n    '-':function() { --data[dp] },\n    '/':function() { dir = -width / dir },\n    '\\\\':function() { dir = width / dir },\n    '!':function() { ip += dir },\n    '?':function() { if (!data[dp]) ip += dir },\n    ',':function() {\n      if (isNaN(data[dp])) {   // EOF\n        --inp;\n        data[dp] = 0;\n      }\n    },\n    '.':function() {\n      snout += String.fromCharCode(data[dp]);\n    },\n    '@':function() { stack.push(ip+dir, dir) },\n    '#':function() { if (stack.length) { dir=stack.pop(); ip=stack.pop(); } else quit++; },\n    '\\n':function() { quit++ }\n  };\n\n  var spaces = \"  \";\n  function format(codet) {\n    var value = codet;\n    var lines = value.split('\\n');\n    width = 0;\n    for (var i in lines)\n      width = Math.max(width, lines[i].length);\n    while (spaces.length < width)\n      spaces += spaces;\n    for (var i in lines)\n      lines[i] += spaces.substring(0, width - lines[i].length);\n    code = lines.join('\\n');\n    width++;\n\n    init();\n    dump();\n  }\n  function init() {\n    inp = 0; quit = 0; dp = 0; dir = 1;\n    data = [0];\n    stack = [];\n    ip = code.indexOf('$');  if (ip<0) ip=0;\n  }\n  function encode(s) {\n    var e = s.replace(/&/g, \"&amp;\");\n        e = e.replace(/</g, \"&lt;\");\n      e = e.replace(/>/g, \"&gt;\");\n      e = e.replace(/ /g, \"&nbsp;\");\n    return  e.replace(/\\n/g, \"<br>\");\n  }\n  function dump() {\n    return data.join();\n  }\n  function body() {\n    var fn = commands[code.charAt(ip)];\n    if (fn) fn();\n    ip += dir;\n  }\n  function done() {\n    return quit || ip<0 || ip>=code.length;\n  }\n  function out() {\n    var d = stack.length;\n    while (stack.length>=d && !done())\n      body();\n    dump();\n  }\n  format(codestr);\n  out();\n  return snout;\n}\n"
      ],
      "tail": [
        "var test1=`+++++++++++++++++++++++++++++++++++.`;",
        "var test2=`++++++++++++++++++++++++++++++++++++.`;",
        "var test3=`+++++++++++++++++++++++++++++++++++.>++++++++++++++++++++++++++++++++++++.<.>.`;",
        "var test4=`+++++++++++++++++++++++++++++++++++++++.>++++++++++++++++++++++++++++++++++++.<.>.<.>.`;",
        "var test5=`/++++!/===========?\\\\>++.>+.+++++++..+++\\\\",
        "\\\\+++\\\\ | /+>+++++++>/ /++++++++++<<.++>./",
        "$+++/ | \\\\+++++++++>\\\\ \\\\+++++.>.+++.-----\\\\",
        "      \\\\==-<<<<+>+++/ /=.>.+>.--------.-/`;"
      ],
      "tests": [
        "assert.equal(snusp(test1),\"#\",'message : <code>snusp(\"+++++++++++++++++++++++++++++++++++.\")</code> should return <code>#</code>');",
        "assert.equal(snusp(test2),\"$\",'message : <code>snusp(\"++++++++++++++++++++++++++++++++++++.\")</code> should return <code>$</code>');",
        "assert.equal(snusp(test3),\"#$#$\",'message : <code>snusp(\"+++++++++++++++++++++++++++++++++++.>++++++++++++++++++++++++++++++++++++.<.>.\")</code> should return <code>#$#$</code>');",
        "assert.equal(snusp(test4),\"'$'$'$\",\"message : <code>snusp('+++++++++++++++++++++++++++++++++++++++.>++++++++++++++++++++++++++++++++++++.<.>.<.>.')</code> should return <code>'$'$'$</code>\");",
        "assert.equal(snusp(test5),\"Hello World!\\n\",'message : <code>snusp(\"'+test5+'\")</code> should return <code>Hello World!\\n</code>');"
      ],
      "id": "59e0ad64214afc42b6a8547b"
    },
    {
      "title": "Execute a Markov algorithm",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Create an interpreter for a <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Markov algorithm\" title=\"wp: Markov algorithm\">Markov Algorithm</a>.</p><br/><p class=\"rosetta__paragraph\">Rules have the syntax:</p>",
        "<p class=\"rosetta__paragraph\"><ruleset> ::= ((<comment> | <rule>) <newline>+)*</p>",
        "<p class=\"rosetta__paragraph\"><comment> ::= # {<any character>}</p>",
        "<p class=\"rosetta__paragraph\"><rule> ::= <pattern> <whitespace> -> <whitespace> [.] <replacement></p>",
        "<p class=\"rosetta__paragraph\"><whitespace> ::= (<tab> | <space>) [<whitespace>]</p>",
        "<p class=\"rosetta__paragraph\">There is one rule per line.</p><br/><p class=\"rosetta__paragraph\">If there is a  <b>.</b>  (period)  present before the  <span class=\"rosetta__text--bold\"><replacement></span>,  then this is a terminating rule in which case the interpreter must halt execution.</p><br/><p class=\"rosetta__paragraph\">A ruleset consists of a sequence of rules, with optional comments.</p>",
        "<br/><p class=\"rosetta__paragraph\"><big><big> Rulesets </big></big></p><br/><p class=\"rosetta__paragraph\">Use the following tests on entries:</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Ruleset 1:</dt></dl>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">This rules file is extracted from Wikipedia:</li>",
        "<li class=\"rosetta__list-item--ordered\">http://en.wikipedia.org/wiki/Markov_Algorithm</li></ol>A -> apple",
        "B -> bag",
        "S -> shop",
        "T -> the",
        "the shop -> my brother",
        "a never used -> .terminating rule",
        "</pre></div>",
        "<p class=\"rosetta__paragraph\">Sample text of:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code> I bought a B of As from T S. </code></span></p>",
        "<p class=\"rosetta__paragraph\">Should generate the output:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code> I bought a bag of apples from my brother. </code></span></p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Ruleset 2:</dt></dl>",
        "<p class=\"rosetta__paragraph\">A test of the terminating rule</p>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Slightly modified from the rules on Wikipedia</li></ol>A -> apple",
        "B -> bag",
        "S -> .shop",
        "T -> the",
        "the shop -> my brother",
        "a never used -> .terminating rule</pre></div>",
        "<p class=\"rosetta__paragraph\">Sample text of:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code>I bought a B of As from T S.</code></span></p>",
        "<p class=\"rosetta__paragraph\">Should generate:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code>I bought a bag of apples from T shop.</code></span></p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Ruleset 3:</dt></dl>",
        "<p class=\"rosetta__paragraph\">This tests for correct substitution order and may trap simple regexp based replacement routines if special regexp characters are not escaped.</p>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">BNF Syntax testing rules</li></ol>A -> apple",
        "WWWW -> with",
        "Bgage -> ->.*",
        "B -> bag",
        "->.* -> money",
        "W -> WW",
        "S -> .shop",
        "T -> the",
        "the shop -> my brother",
        "a never used -> .terminating rule",
        "</pre></div>",
        "<p class=\"rosetta__paragraph\">Sample text of:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code>I bought a B of As W my Bgage from T S.</code></span></p>",
        "<p class=\"rosetta__paragraph\">Should generate:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code>I bought a bag of apples with my money from T shop.</code></span></p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Ruleset 4:</dt></dl>",
        "<p class=\"rosetta__paragraph\">This tests for correct order of scanning of rules, and may trap replacement routines that scan in the wrong order.  It implements a general unary multiplication engine.  (Note that the input expression must be placed within underscores in this implementation.)</p>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">## Unary Multiplication Engine, for testing Markov Algorithm implementations</li>",
        "<li class=\"rosetta__list-item--ordered\">## By Donal Fellows.</li>",
        "<li class=\"rosetta__list-item--ordered\">Unary addition engine</li></ol>_+1 -> _1+",
        "1+1 -> 11+",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Pass for converting from the splitting of multiplication into ordinary</li>",
        "<li class=\"rosetta__list-item--ordered\">addition</li></ol>1! -> !1",
        ",! -> !+",
        "_! -> _",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Unary multiplication by duplicating left side, right side times</li></ol>1*1 -> x,@y",
        "1x -> xX",
        "X, -> 1,1",
        "X1 -> 1X",
        "_x -> _X",
        ",x -> ,X",
        "y1 -> 1y",
        "y_ -> _",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Next phase of applying</li></ol>1@1 -> x,@y",
        "1@_ -> @_",
        ",@_ -> !_",
        "++ -> +",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Termination cleanup for addition</li></ol>_1 -> 1",
        "1+_ -> 1",
        "_+_ -> ",
        "</pre></div>",
        "<p class=\"rosetta__paragraph\">Sample text of:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code> _1111*11111_ </code></span></p>",
        "<p class=\"rosetta__paragraph\">should generate the output:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code> 11111111111111111111 </code></span></p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Ruleset 5:</dt></dl>",
        "<p class=\"rosetta__paragraph\">A simple <a class=\"rosetta__link--wiki\" href=\"http://en.wikipedia.org/wiki/Turing_machine\" title=\"link: http://en.wikipedia.org/wiki/Turing_machine\">Turing machine</a>,</p>",
        "<p class=\"rosetta__paragraph\">implementing a three-state <a class=\"rosetta__link--wiki\" href=\"http://en.wikipedia.org/wiki/Busy_beaver\" title=\"link: http://en.wikipedia.org/wiki/Busy_beaver\">busy beaver</a>.</p><br/><p class=\"rosetta__paragraph\">The tape consists of <span class=\"rosetta__text--bold\">0</span>s and <span class=\"rosetta__text--bold\">1</span>s,  the states are <span class=\"rosetta__text--bold\">A</span>, <span class=\"rosetta__text--bold\">B</span>, <span class=\"rosetta__text--bold\">C</span> and <span class=\"rosetta__text--bold\">H</span> (for <span class=\"rosetta__text--bold\">H</span>alt), and the head position is indicated by writing the state letter before the character where the head is.</p>",
        "<p class=\"rosetta__paragraph\">All parts of the initial tape the machine operates on have to be given in the input.</p><br/><p class=\"rosetta__paragraph\">Besides demonstrating that the Markov algorithm is Turing-complete, it also made me catch a bug in the C++ implementation which wasn't caught by the first four rulesets.</p>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Turing machine: three-state busy beaver</li>",
        "<li class=\"rosetta__list-item--ordered\"># state A, symbol 0 => write 1, move right, new state B</li></ol>A0 -> 1B",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">state A, symbol 1 => write 1, move left, new state C</li></ol>0A1 -> C01",
        "1A1 -> C11",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">state B, symbol 0 => write 1, move left, new state A</li></ol>0B0 -> A01",
        "1B0 -> A11",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">state B, symbol 1 => write 1, move right, new state B</li></ol>B1 -> 1B",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">state C, symbol 0 => write 1, move left, new state B</li></ol>0C0 -> B01",
        "1C0 -> B11",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">state C, symbol 1 => write 1, move left, halt</li></ol>0C1 -> H01",
        "1C1 -> H11",
        "</pre></div>",
        "<p class=\"rosetta__paragraph\">This ruleset should turn</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code> 000000A000000 </code></span></p>",
        "<p class=\"rosetta__paragraph\">into</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <code> 00011H1111000 </code></span></p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function markov (rules,test) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function markov(rules,test) {\n    let pattern = new RegExp(\"^([^#]*?)\\\\s+->\\\\s+(\\\\.?)(.*)\");\n    let origTest = test;\n\n    let captures = [];\n    \n    rules.forEach(function(rule){\n\t\tlet m = pattern.exec(rule);\n\t\tfor (let j = 0; j < m.length; j++)\n\t\t    m[j] = m[j + 1];\n\t\tcaptures.push(m);\n    });\n\n    test = origTest;\n    let copy = test;\n    for (let j = 0; j < captures.length; j++) {\n        let c = captures[j];\n        test = test.replace(c[0], c[2]);\n        if (c[1]==\".\")\n            break;\n        if (test!=copy) {\n            j = -1;\n            copy = test;\n        }\n    }\n    return test;\n}\n\n// tail:\nlet rules=[[\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n\t\t\t[\"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n\t\t\t[\"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n\t\t\t[\"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"],\n\t\t\t[\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"]];\nlet tests=[\"I bought a B of As from T S.\",\n\t\t\t\"I bought a B of As from T S.\",\n\t\t\t\"I bought a B of As W my Bgage from T S.\",\n\t\t\t\"_1111*11111_\",\n\t\t\t\"000000A000000\"];\nlet outputs=[\"I bought a bag of apples from my brother.\",\n\t\t\t\"I bought a bag of apples from T shop.\",\n\t\t\t\"I bought a bag of apples with my money from T shop.\",\n\t\t\t\"11111111111111111111\",\n\t\t\t\"00011H1111000\"];"
      ],
      "tests": [
        "assert(typeof markov === 'function', 'message: <code>markov</code> is a function.');",
        "assert.deepEqual(markov(rules[0],tests[0]),outputs[0],'message: <code>markov([\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")</code> should return \"I bought a bag of apples from my brother.\".');",
        "assert.deepEqual(markov(rules[1],tests[1]),outputs[1],'message: <code>markov([\"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")</code> should return \"I bought a bag of apples from T shop.\".');",
        "assert.deepEqual(markov(rules[2],tests[2]),outputs[2],'message: <code>markov([\"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As W my Bgage from T S.\")</code> should return \"I bought a bag of apples with my money from T shop.\".');",
        "assert.deepEqual(markov(rules[3],tests[3]),outputs[3],'message: <code>markov([\"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"],\"_1111*11111_\")</code> should return \"11111111111111111111\".');",
        "assert.deepEqual(markov(rules[4],tests[4]),outputs[4],'message: <code>markov([\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"],\"\")</code> should return \"00011H1111000\".');"
      ],
      "id": "59e09e6d412c5939baa02d16"
    },
    {
      "title": "Extensible prime generator",
      "type": "rosetta-code",
      "categories": [],
      "benchmark": "primeGenerator(10000, false);",
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\"><br/>",
        "<p class=\"rosetta__paragraph\">Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.</p> The generator should be able to : <ul><li>Show the first <b>n</b> prime numbers.</li><li>Show the prime numbers in a range.</li><li>Show the number of primes in a range.</li><li>Show the <b>n<sup>th</sup></b> prime number.</li></ul><p>The function should have two paramters. The first will recieve <b>n</b> or the range as an array. The second will recieve a boolean, that specifies if the function returns the prime numbers as an array or a single number(the number of primes in the range or the <b>n<sup>th</sup></b> prime). According to the parameters the function should return an array.</div>"
      ],
      "challengeSeed": [
        "function primeGenerator (num, showPrimes) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "// noprotect\nfunction primeGenerator(num, showPrimes) {\n  let i,\n    arr = [];\n\n  function isPrime(num) {\n    // try primes <= 16\n    if (num <= 16) { return (\n      num == 2 || num == 3 || num == 5 || num == 7 || num == 11 || num == 13\n    ); }\n    // cull multiples of 2, 3, 5 or 7\n    if (num % 2 == 0 || num % 3 == 0 || num % 5 == 0 || num % 7 == 0)\n      { return false; }\n    // cull square numbers ending in 1, 3, 7 or 9\n    for (let i = 10; i * i <= num; i += 10) {\n      if (num % (i + 1) == 0) return false;\n      if (num % (i + 3) == 0) return false;\n      if (num % (i + 7) == 0) return false;\n      if (num % (i + 9) == 0) return false;\n    }\n    return true;\n  }\n\n  if (typeof num === 'number') {\n    for (i = 0; arr.length < num; i++) if (isPrime(i)) arr.push(i);\n    // first x primes\n    if (showPrimes) return arr;\n    // xth prime\n    return arr.pop();\n  }\n\n  if (Array.isArray(num)) {\n    for (i = num[0]; i <= num[1]; i++) if (isPrime(i)) arr.push(i);\n    // primes between x .. y\n    if (showPrimes) return arr;\n    // number of primes between x .. y\n    return arr.length;\n  }\n}\n"
      ],
      "tests": [
        "assert(typeof primeGenerator === 'function', 'message: <code>primeGenerator</code> is a function.');",
        "assert.deepEqual(primeGenerator(20, true), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71], 'message: <code>primeGenerator</code> is a function.');",
        "assert.deepEqual(primeGenerator([100, 150], true), [101, 103, 107, 109, 113, 127, 131, 137, 139, 149], 'message: <code>primeGenerator</code> is a function.');",
        "assert.equal(primeGenerator([7700, 8000], false), 30, 'message: <code>primeGenerator</code> is a function.');",
        "assert.equal(primeGenerator(10000, false), 104729, 'message: <code>primeGenerator</code> is a function.');"
      ],
      "id": "598ee8b91b410510ae82efef"
    },
    {
      "title": "FASTA format",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">In <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/bioinformatics\" title=\"wp: bioinformatics\">bioinformatics</a>, long character strings are often encoded in a format called <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/FASTA format\" title=\"wp: FASTA format\">FASTA</a>.</p><br/><p class=\"rosetta__paragraph\">A FASTA file can contain several strings, each identified by a name marked by a <big><big><code>&gt;</code></big></big> (greater than) character at the beginning of the line.</p><p class=\"rosetta__paragraph\">Write a function that takes a FASTA file (as a string parameter) such as:</p>",
        "<pre class=\"rosetta__pre\">",
        ">Rosetta_Example_1",
        "THERECANBENOSPACE",
        ">Rosetta_Example_2",
        "THERECANBESEVERAL",
        "LINESBUTTHEYALLMUST",
        "BECONCATENATED",
        "</pre><br/><p>The result for the above input should be : <pre class=\"rosetta__pre\">",
        "Rosetta_Example_1: THERECANBENOSPACE",
        "Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED",
        "</pre><p><b>Note :</b> The input string will contain '|' as line separators. The output should contain '|' as line separators.</b></p>",
        "</div>"
      ],
      "challengeSeed": [
        "function fasta(str) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function fasta(str){\n\tstr=str.split(\"|\");\n\tlet format=\"\";\n\t\n\tstr.forEach(function (a){\n    if(a.startsWith(\">\")){\n      format+=\"|\"+a.substring(1)+\":\";\n    }else{\n      format+=a;\n    }\n\t});\n\t\n\treturn format.substring(1);\n}\n"
      ],
      "tail": [
        "const tests=[",
        "  \">FASTA1|THERECANBENOSPACE|>FASTA2|THERECANBESEVERAL|LINESBUTTHEYALLMUST|BECONCATENATED\",",
        "  \">ANOTHERFASTA|LINEO|LINET|>WOAH|WOAHH|WOAHH\",",
        "  \">HELLO|WORLD|>HELLOAGAIN|WORLD|WORLDMORE|>HELLOYETAGAIN|WORLDAGAIN|WORLDLINE\",",
        "  \">FIVELINES|ONE|TWO|THREE|FOUR|FIVE|>THREELINES|ONE|TWO|THREE\",",
        "  \">LASTEXAMPLE|LAST|EXAMPLE|>LASTEXAMPLELINE|LAST|EXAMPLE|LINE\"];",
        "",
        "const results=[",
        "    \"FASTA1:THERECANBENOSPACE|FASTA2:THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED\",",
        "    \"ANOTHERFASTA:LINEOLINET|WOAH:WOAHHWOAHH\",",
        "    \"HELLO:WORLD|HELLOAGAIN:WORLDWORLDMORE|HELLOYETAGAIN:WORLDAGAINWORLDLINE\",",
        "    \"FIVELINES:ONETWOTHREEFOURFIVE|THREELINES:ONETWOTHREE\",",
        "    \"LASTEXAMPLE:LASTEXAMPLE|LASTEXAMPLELINE:LASTEXAMPLELINE\"",
        "  ];"
      ],
      "tests": [
        "assert(typeof fasta=='function','message:<code>fasta</code> should be a function.')",
        "assert(typeof fasta(tests[0])=='string','message:<code>fasta('+tests[0]+')</code> should return a String.')",
        "assert.equal(fasta(tests[0]),results[0],'message:<code>fasta(\"'+tests[0]+'\")</code> should return <code>\"'+results[0]+'\"</code>')",
        "assert.equal(fasta(tests[1]),results[1],'message:<code>fasta(\"'+tests[1]+'\")</code> should return <code>\"'+results[1]+'\"</code>')",
        "assert.equal(fasta(tests[2]),results[2],'message:<code>fasta(\"'+tests[2]+'\")</code> should return <code>\"'+results[2]+'\"</code>')",
        "assert.equal(fasta(tests[3]),results[3],'message:<code>fasta(\"'+tests[3]+'\")</code> should return <code>\"'+results[3]+'\"</code>')",
        "assert.equal(fasta(tests[4]),results[4],'message:<code>fasta(\"'+tests[4]+'\")</code> should return <code>\"'+results[4]+'\"</code>')"
      ],
      "id": "59c3ecf2fff8b4181fa3719f"
    },
    {
      "title": "Factorial",
      "type": "rosetta-code",
      "categories": [
        "Recursion",
        "Memoization",
        "Classic CS problems and programs",
        "Arithmetic",
        "Simple"
      ],
      "difficulty": "1",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Write a function to return the factorial of a number.</p><br/>",
        "<p>Factorial of a number is given by : </p>",
        "n! = n * (n-1) * (n-2) * ..... * 1",
        "<p>",
        "For example :<br>",
        "3! = 3*2*1 = 6<br>",
        "4! = 4*3*2*1 = 24",
        "</p>",
        "<p>Note : <br>",
        "0! = 1 <br>",
        "</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function factorial (n) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function factorial(n) {\n  let sum = 1;\n  while (n > 1) {\n    sum *= n;\n    n--;\n  }\n  return sum;\n}\n\n"
      ],
      "tail": "const results=[6,120,3628800];",
      "tests": [
        "assert(typeof factorial === 'function', 'message: <code>factorial</code> is a function.');",
        "assert(typeof factorial(2) === 'number', 'message: <code>factorial(2)</code> should return a number.');",
        "assert.equal(factorial(3),results[0],\"message: <code>factorial(3)</code> should return 6.\");",
        "assert.equal(factorial(5),results[1],\"message: <code>factorial(3)</code> should return 120.\");",
        "assert.equal(factorial(10),results[2],\"message: <code>factorial(3)</code> should return 3,628,800.\");"
      ],
      "id": "597b2b2a2702b44414742771"
    },
    {
      "title": "Factors of a Mersenne number",
      "type": "rosetta-code",
      "categories": [
        "Arithmetic",
        "Arithmetic operations"
      ],
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><br/><p class=\"rosetta__paragraph\">A Mersenne number is a number in the form of 2<sup>P</sup>-1.</p><br/><p class=\"rosetta__paragraph\">If P is prime, the Mersenne number may be a Mersenne prime</p>",
        "<p class=\"rosetta__paragraph\">(if P is not prime, the Mersenne number is also not prime).</p><br/><p class=\"rosetta__paragraph\">In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a,  potentially lengthy, <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Lucas-Lehmer test\" title=\"Lucas-Lehmer test\">Lucas-Lehmer test</a>.</p><br/><p class=\"rosetta__paragraph\">There are very efficient algorithms for determining if a number divides 2<sup>P</sup>-1 (or equivalently, if 2<sup>P</sup> mod (the number) = 1).</p>",
        "<p class=\"rosetta__paragraph\">Some languages already have built-in implementations of this exponent-and-mod operation (called <span class=\"rosetta__text--italic\">modPow</span> or similar).</p><br/><p class=\"rosetta__paragraph\">The following is how to implement this <span class=\"rosetta__text--italic\">modPow</span> yourself:</p><br/><p class=\"rosetta__paragraph\">For example, let's compute 2<sup>23</sup> mod 47.</p>",
        "<p class=\"rosetta__paragraph\">Convert the exponent 23 to binary, you get 10111. Starting with <tt>square</tt> = 1, repeatedly square it.</p>",
        "<p class=\"rosetta__paragraph\">Remove the top bit of the exponent, and if it's 1 multiply <tt>square</tt> by the base of the exponentiation (2), then compute <tt>square</tt> modulo 47.</p>",
        "<p class=\"rosetta__paragraph\">Use the result of the modulo from the last step as the initial value of <tt>square</tt> in the next step:</p><br/><p class=\"rosetta__paragraph\">Remove   Optional</p>",
        "<p class=\"rosetta__paragraph\">square        top bit  multiply by 2  mod 47</p>",
        "<p class=\"rosetta__paragraph\">------------  -------  -------------  ------</p>",
        "<p class=\"rosetta__paragraph\">1*1 = 1       1  0111  1*2 = 2           2</p>",
        "<p class=\"rosetta__paragraph\">2*2 = 4       0   111     no             4</p>",
        "<p class=\"rosetta__paragraph\">4*4 = 16      1    11  16*2 = 32        32</p>",
        "<p class=\"rosetta__paragraph\">32*32 = 1024  1     1  1024*2 = 2048    27</p>",
        "<p class=\"rosetta__paragraph\">27*27 = 729   1        729*2 = 1458      1</p><br/><p class=\"rosetta__paragraph\">Since 2<sup>23</sup> mod 47 = 1, 47 is a factor of 2<sup>P</sup>-1.</p>",
        "<p class=\"rosetta__paragraph\">(To see this, subtract 1 from both sides: 2<sup>23</sup>-1 = 0 mod 47.)</p>",
        "<p class=\"rosetta__paragraph\">Since we've shown that 47 is a factor, 2<sup>23</sup>-1 is not prime.</p>",
        "<p class=\"rosetta__paragraph\">Further properties of Mersenne numbers allow us to refine the process even more.</p>",
        "<p class=\"rosetta__paragraph\">Any factor q of 2<sup>P</sup>-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.</p>",
        "<p class=\"rosetta__paragraph\">Finally any potential factor q must be <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Primality by Trial Division\" title=\"Primality by Trial Division\">prime</a>.</p>",
        "<p class=\"rosetta__paragraph\">As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).</p><br/><p class=\"rosetta__paragraph\">These primality tests only work on Mersenne numbers where P is prime. For example, M<sub>4</sub>=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Using the above method find a factor of  2<sup>929</sup>-1 (aka M929)</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Related tasks:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/count in factors\" title=\"count in factors\">count in factors</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/prime decomposition\" title=\"prime decomposition\">prime decomposition</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/factors of an integer\" title=\"factors of an integer\">factors of an integer</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Sieve of Eratosthenes\" title=\"Sieve of Eratosthenes\">Sieve of Eratosthenes</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/primality by trial division\" title=\"primality by trial division\">primality by trial division</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/trial factoring of a Mersenne number\" title=\"trial factoring of a Mersenne number\">trial factoring of a Mersenne number</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/partition an integer X into N primes\" title=\"partition an integer X into N primes\">partition an integer X into N primes</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/sequence of primes by Trial Division\" title=\"sequence of primes by Trial Division\">sequence of primes by Trial Division</a></li>",
        "<li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--wiki\" href=\"https://www.youtube.com/watch?v=SNwvJ7psoow\" title=\"link: https://www.youtube.com/watch?v=SNwvJ7psoow\">Computers in 1948: 2¹²⁷-1</a></li></ul><br><br><br/></div>"
      ],
      "challengeSeed": [
        "function check_mersenne (p) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function check_mersenne(p){  \n\tfunction isPrime(value){\n\t  for (let i=2; i < value; i++){\n\t\tif (value % i == 0){\n\t\t  return false;\n\t\t}\n\t\tif (value % i != 0){\n\t\t  return true;\n\t\t }\n\t  }\n\t}\n\t\n\tfunction trial_factor(base, exp, mod){\n\t  let square, bits;\n\t  square = 1;\n\t  bits = exp.toString(2).split('');\n\t  for (let i=0,ln=bits.length; i<ln; i++){\n\t\tsquare = Math.pow(square, 2) * (bits[i] == 1 ? base : 1) % mod;\n\t  }\n\t  return (square == 1);\n\t}\n\t\n\tfunction mersenne_factor(p){\n\t  let limit, k, q;\n\t  limit = Math.sqrt(Math.pow(2,p) - 1);\n\t  k = 1;\n\t  while ((2*k*p - 1) < limit){\n\t\tq = 2*k*p + 1;\n\t\tif (isPrime(q) && (q % 8 == 1 || q % 8 == 7) && trial_factor(2,p,q)){\n\t\t  return q; // q is a factor of 2**p-1\n\t\t}\n\t\tk++;\n\t  }\n\t  return null;\n\t}\n  let f, result;\n  result=\"M\"+p+\" = 2^\"+p+\"-1 is \";\n  f = mersenne_factor(p);\n  result+=f == null ? \"prime\" : \"composite with factor \"+f;\n  return result;\n}\n\n"
      ],
      "tests": [
        "assert(typeof check_mersenne === 'function', 'message: <code>check_mersenne</code> is a function.');",
        "assert(typeof check_mersenne(3) == 'string', 'message: <code>check_mersenne(3)</code> should return a string.');",
        "assert.equal(check_mersenne(3),\"M3 = 2^3-1 is prime\",'message: <code>check_mersenne(3)</code> should return \"M3 = 2^3-1 is prime\".');",
        "assert.equal(check_mersenne(23),\"M23 = 2^23-1 is composite with factor 47\",'message: <code>check_mersenne(23)</code> should return \"M23 = 2^23-1 is composite with factor 47\".');",
        "assert.equal(check_mersenne(929),\"M929 = 2^929-1 is composite with factor 13007\",'message: <code>check_mersenne(929)</code> should return \"M929 = 2^929-1 is composite with factor 13007');"
      ],
      "id": "598eea87e5cf4b116c3ff81a"
    },
    {
      "title": "Factors of an integer",
      "type": "rosetta-code",
      "categories": [
        "Arithmetic operations",
        "Mathematical_operations"
      ],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Write a function that returns the factors  of a positive integer.</p><p class=\"rosetta__paragraph\">These factors are the positive integers by which the number being factored can be divided to yield a positive integer result.</p>",
        "///</div>"
      ],
      "challengeSeed": [
        "function factors (num) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function factors(num)\n{\n let n_factors = [], i, sqr=Math.floor(Math.sqrt(num));\n\n for (i = 1; i <=sqr ; i += 1)\n  if (num % i === 0)\n  {\n   n_factors.push(i);\n   if (num / i !== i)\n    n_factors.push(num / i);\n  }\n n_factors.sort(function(a, b){return a - b;});\n return n_factors;\n}\n"
      ],
      "tail": "const ans=[[1,3,5,9,15,45],[1,53],[1,2,4,8,16,32,64]];",
      "tests": [
        "assert(typeof factors === 'function', 'message: <code>factors</code> is a function.');",
        "assert.deepEqual(factors(45), ans[0], 'message: <code>factors(45)</code> should return <code>[1,3,5,9,15,45]</code>.');",
        "assert.deepEqual(factors(53), ans[1], 'message: <code>factors(53)</code> should return <code>[1,53]</code>.');",
        "assert.deepEqual(factors(64), ans[2], 'message: <code>factors(64)</code> should return <code>[1,2,4,8,16,32,64]</code>.');"
      ],
      "id": "597f1e7fbc206f0e9ba95dc4"
    },
    {
      "title": "Farey sequence",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "3",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">Write a function that returns the Farey sequence of order n. The function should have one parameter that is n. It should return the sequence as an array. Read the following for more details : </p><p class=\"rosetta__paragraph\">The  <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Farey sequence\" title=\"wp: Farey sequence\">Farey sequence</a>  <span class=\"rosetta__text--bold\"> <span class=\"rosetta__text--italic\">F</span><sub>n</sub></span>  of order  <span class=\"rosetta__text--bold\">n</span>  is the sequence of completely reduced fractions between  <span class=\"rosetta__text--bold\">0</span>  and  <span class=\"rosetta__text--bold\">1</span>  which, when in lowest terms, have denominators less than or equal to  <span class=\"rosetta__text--bold\">n</span>,  arranged in order of increasing size.</p><br/><p class=\"rosetta__paragraph\">The  <span class=\"rosetta__text--italic\">Farey sequence</span>  is sometimes incorrectly called a  <span class=\"rosetta__text--italic\">Farey series</span>.</p>",
        "<br/><p class=\"rosetta__paragraph\">Each Farey sequence:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  starts with the value  <span class=\"rosetta__text--bold\">0</span>,  denoted by the fraction  $ \\frac{0}{1} $</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">::*  ends with the value  <span class=\"rosetta__text--bold\">1</span>,  denoted by the fraction  $ \\frac{1}{1}$.</span></p>",
        "<br/><p class=\"rosetta__paragraph\">The Farey sequences of orders  <span class=\"rosetta__text--bold\">1</span>  to  <span class=\"rosetta__text--bold\">5</span>  are:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">${\\bf\\it{F}}_1 = \\frac{0}{1}, \\frac{1}{1}$</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"><br></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">${\\bf\\it{F}}_2 = \\frac{0}{1}, \\frac{1}{2}, \\frac{1}{1}$</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"><br></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">${\\bf\\it{F}}_3 = \\frac{0}{1}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{1}{1}$</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"><br></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">${\\bf\\it{F}}_4 = \\frac{0}{1}, \\frac{1}{4}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{3}{4}, \\frac{1}{1}$</span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"><br></span></p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">${\\bf\\it{F}}_5 = \\frac{0}{1}, \\frac{1}{5}, \\frac{1}{4}, \\frac{1}{3}, \\frac{2}{5}, \\frac{1}{2}, \\frac{3}{5}, \\frac{2}{3}, \\frac{3}{4}, \\frac{4}{5}, \\frac{1}{1}$</span></p></div>"
      ],
      "challengeSeed": [
        "function farey (n) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function farey(n){\n\tlet farSeq=[];\n\tfor(let den = 1; den <= n; den++){\n\t\tfor(let num = 1; num < den; num++){\n\t\t\tfarSeq.push({\n\t\t\t\tstr:num+\"/\"+den,\n\t\t\t\tval:num/den});\n\t\t}\n\t}\n\tfarSeq.sort(function(a,b){\n\t\treturn a.val-b.val;\n\t});\n\tfarSeq=farSeq.map(function(a){\n\t\treturn a.str;\n\t});\n\treturn farSeq;\n}\n"
      ],
      "tests": [
        "assert(typeof farey === 'function', 'message: <code>farey</code> is a function.');",
        "assert(Array.isArray(farey(3)),'<code>farey(3)</code> should return an array');",
        "assert.deepEqual(farey(3),[\"1/3\",\"1/2\",\"2/3\"],'<code>farey(3)</code> should return <code>[\"1/3\",\"1/2\",\"2/3\"]</code>');",
        "assert.deepEqual(farey(4),[\"1/4\",\"1/3\",\"1/2\",\"2/4\",\"2/3\",\"3/4\"],'<code>farey(4)</code> should return <code>[\"1/4\",\"1/3\",\"1/2\",\"2/4\",\"2/3\",\"3/4\"]</code>');",
        "assert.deepEqual(farey(5),[\"1/5\",\"1/4\",\"1/3\",\"2/5\",\"1/2\",\"2/4\",\"3/5\",\"2/3\",\"3/4\",\"4/5\"],'<code>farey(5)</code> should return <code>[\"1/5\",\"1/4\",\"1/3\",\"2/5\",\"1/2\",\"2/4\",\"3/5\",\"2/3\",\"3/4\",\"4/5\"]</code>');"
      ],
      "id": "59c3ec9f15068017c96eb8a3"
    },
    {
      "title": "Fast Fourier transform",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Write a function to calculate the  FFT  (<u>F</u>ast <u>F</u>ourier <u>T</u>ransform)  of an input array.</p><br/><p class=\"rosetta__paragraph\">The  output should be an array of length same as that of the input array. The elements of the output array sould be objects of the form <code>{\"re\":value,\"im\":value}</code>. It can be seen that the objects represent complex numbers with a real and an imaginary part.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function fourier (amps) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function fourier(amps){\n  function Complex(re, im) \n  {\n    this.re = re;\n    this.im = im || 0.0;\n  }\n  Complex.prototype.add = function(other, dst)\n  {\n    dst.re = this.re + other.re;\n    dst.im = this.im + other.im;\n    return dst;\n  }\n  Complex.prototype.sub = function(other, dst)\n  {\n    dst.re = this.re - other.re;\n    dst.im = this.im - other.im;\n    return dst;\n  }\n  Complex.prototype.mul = function(other, dst)\n  {\n    //cache re in case dst === this\n    var r = this.re * other.re - this.im * other.im;\n    dst.im = this.re * other.im + this.im * other.re;\n    dst.re = r;\n    return dst;\n  }\n  Complex.prototype.cexp = function(dst)\n  {\n    var er = Math.exp(this.re);\n    dst.re = er * Math.cos(this.im);\n    dst.im = er * Math.sin(this.im);\n    return dst;\n  }\n  function cfft(amplitudes)\n  {\n    var N = amplitudes.length;\n    if( N <= 1 )\n      return amplitudes;\n\n    var hN = N / 2;\n    var even = [];\n    var odd = [];\n    even.length = hN;\n    odd.length = hN;\n    for(var i = 0; i < hN; ++i)\n    {\n      even[i] = amplitudes[i*2];\n      odd[i] = amplitudes[i*2+1];\n    }\n    even = cfft(even);\n    odd = cfft(odd);\n\n    var a = -2*Math.PI;\n    for(var k = 0; k < hN; ++k)\n    {\n      if(!(even[k] instanceof Complex))\n        even[k] = new Complex(even[k], 0);\n      if(!(odd[k] instanceof Complex))\n        odd[k] = new Complex(odd[k], 0);\n      var p = k/N;\n      var t = new Complex(0, a * p);\n      t.cexp(t).mul(odd[k], t);\n      amplitudes[k] = even[k].add(t, odd[k]);\n      amplitudes[k + hN] = even[k].sub(t, even[k]);\n    }\n    return amplitudes;\n  }\n  \n  return cfft(amps).map(function(e){\n    return {re:e.re,im:e.im};\n  });\n}\n\n"
      ],
      "tail": [
        "var tests=[[1,1],",
        "           [1,1,0,1],",
        "          [0,1,0,1],",
        "          [1,2,3,0],",
        "          [0,1,2,0]];",
        "",
        "var results=[[{\"re\":2,\"im\":0},{\"re\":0,\"im\":0}],",
        "            [{\"re\":3,\"im\":0},{\"re\":1,\"im\":0},{\"re\":-1,\"im\":0},{\"re\":1,\"im\":0}],",
        "            [{\"re\":2,\"im\":0},{\"re\":0,\"im\":0},{\"re\":-2,\"im\":0},{\"re\":0,\"im\":0}],",
        "            [{\"re\":6,\"im\":0},{\"re\":-1.9999999999999998,\"im\":-2},{\"re\":2,\"im\":0},{\"re\":-2,\"im\":2}],",
        "            [{\"re\":3,\"im\":0},{\"re\":-2,\"im\":-1},{\"re\":1,\"im\":0},{\"re\":-2,\"im\":1}]];"
      ],
      "tests": [
        "assert(typeof fourier === 'function', 'message: <code>fourier</code> should be a function.');",
        "assert(Array.isArray(fourier(tests[0].slice())),'message: <code>fourier([1,1])</code> should return an array.');",
        "assert.deepEqual(fourier(tests[0].slice()),results[0],'message: <code>fourier('+JSON.stringify(tests[0])+')</code> should return <code>'+JSON.stringify(results[0])+'</code>.');",
        "assert.deepEqual(fourier(tests[1].slice()),results[1],'message: <code>fourier('+JSON.stringify(tests[1])+')</code> should return <code>'+JSON.stringify(results[1])+'</code>.');",
        "assert.deepEqual(fourier(tests[2].slice()),results[2],'message: <code>fourier('+JSON.stringify(tests[2])+')</code> should return <code>'+JSON.stringify(results[2])+'</code>.');",
        "assert.deepEqual(fourier(tests[3].slice()),results[3],'message: <code>fourier('+JSON.stringify(tests[3])+')</code> should return <code>'+JSON.stringify(results[3])+'</code>.');",
        "assert.deepEqual(fourier(tests[4].slice()),results[4],'message: <code>fourier('+JSON.stringify(tests[4])+')</code> should return <code>'+JSON.stringify(results[4])+'</code>.');"
      ],
      "id": "5a5dad74b46bac1cee19d44b"
    },
    {
      "title": "Fibonacci n-step number sequences",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "3",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Write a function to generate Fibonacci n-step number sequences and Lucas sequences. The first parameter will be n. The second parameter will be the number of elements to be returned. The third paramter will specify whether to output the Fibonacci sequence or the Lucas sequence. If the parameter is \"f\" then return the Fibonacci sequence and if it is \"l\", then return the Lucas sequence. The sequences must be returned as an array. More details are given below : </p><p class=\"rosetta__paragraph\">These number series are an expansion of the ordinary <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Fibonacci sequence\" title=\"Fibonacci sequence\">Fibonacci sequence</a> where:</p>",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">For $n = 2$ we have the Fibonacci sequence; with initial values $[1, 1]$ and $F_k^2 = F_{k-1}^2 + F_{k-2}^2$</li>",
        "<li class=\"rosetta__list-item--ordered\">For $n = 3$ we have the tribonacci sequence; with initial values $[1, 1, 2]$ and $F_k^3 = F_{k-1}^3 + F_{k-2}^3 + F_{k-3}^3$</li>",
        "<li class=\"rosetta__list-item--ordered\">For $n = 4$ we have the tetranacci sequence; with initial values $[1, 1, 2, 4]$ and $F_k^4 = F_{k-1}^4 + F_{k-2}^4 + F_{k-3}^4 + F_{k-4}^4$<br>...</li>",
        "<li class=\"rosetta__list-item--ordered\">For general $n>2$ we have the Fibonacci $n$-step sequence - $F_k^n$; with initial values of the first $n$ values of the $(n-1)$'th Fibonacci $n$-step sequence $F_k^{n-1}$; and $k$'th value of this $n$'th sequence being $F_k^n = \\sum_{i=1}^{(n)} {F_{k-i}^{(n)}}$</li></ol>",
        "<p class=\"rosetta__paragraph\">For small values of $n$, <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Number prefix#Greek_series\" title=\"wp: Number prefix#Greek_series\">Greek numeric prefixes</a> are sometimes used to individually name each series.</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\">{| style=\"text-align: left;\" border=\"4\" cellpadding=\"2\" cellspacing=\"2\"</span></p>",
        "<p class=\"rosetta__paragraph\">|+ Fibonacci $n$-step sequences</p>",
        "<p class=\"rosetta__paragraph\">|- style=\"background-color: rgb(255, 204, 255);\"</p>",
        "<p class=\"rosetta__paragraph\">! $n$ !! Series name !! Values</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">|  2 ||  fibonacci || 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">|  3 || tribonacci || 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">|  4 || tetranacci || 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">|  5 || pentanacci || 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">|  6 ||  hexanacci || 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">|  7 || heptanacci || 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">|  8 ||  octonacci || 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">|  9 ||  nonanacci || 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...</p>",
        "<p class=\"rosetta__paragraph\">|-</p>",
        "<p class=\"rosetta__paragraph\">| 10 ||  decanacci || 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...</p>",
        "<p class=\"rosetta__paragraph\">|}</p><br/><p class=\"rosetta__paragraph\">Allied sequences can be generated where the initial values are changed:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> <span class=\"rosetta__text--bold\">The <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Lucas number\" title=\"wp: Lucas number\">Lucas series</a></span> sums the two preceding values like the fibonacci series for $n=2$ but uses $[2, 1]$ as its initial values.</span></p><br/><p class=\"rosetta__paragraph\"><!-- Lucas numbers, Lucas number, Lucas series     [added to make searches easier.] --></p><br/><br></div>"
      ],
      "challengeSeed": [
        "function fib_luc (n, len, w) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function fib_luc(n, len, w) {\n\tfunction nacci(a, n, len) {\n\t\twhile (a.length < len) {\n\t\t    let sum = 0;\n\t\t    for (let i = Math.max(0, a.length - n); i < a.length; i++)\n\t\t        sum += a[i];\n\t\t    a.push(sum);\n\t\t}\n\t\treturn a;\n\t}\n\tif(w==\"f\"){\n    \treturn nacci(nacci([1,1], n, n), n, len);\n\t}else{\n    \treturn nacci(nacci([2,1], n, n), n, len);\n\t}\n}\n"
      ],
      "tail": [
        "const ans = [[1,1,2,3,5,8,13,21,34,55],",
        "[1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136],",
        "[1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536],",
        "[ 2, 1, 3, 4, 7, 11, 18, 29, 47, 76],",
        "[ 2, 1, 3, 6, 10, 19, 35, 64, 118, 217, 399, 734, 1350, 2483, 4567 ],",
        "[ 2, 1, 3, 6, 12, 22, 43, 83, 160, 308, 594, 1145, 2207, 4254, 8200 ],",
        "[ 2, 1, 3, 6, 12, 24, 46, 91, 179, 352, 692, 1360, 2674, 5257, 10335 ]];"
      ],
      "tests": [
        "assert(typeof fib_luc === 'function', 'message: <code>fib_luc</code> is a function.');",
        "assert.deepEqual(fib_luc(2,10,\"f\"),ans[0],'message: <code>fib_luc(2,10,\"f\")</code> should return <code>[1,1,2,3,5,8,13,21,34,55]</code>.');",
        "assert.deepEqual(fib_luc(3,15,\"f\"),ans[1],'message: <code>fib_luc(3,15,\"f\")</code> should return <code>[1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136]</code>.');",
        "assert.deepEqual(fib_luc(4,15,\"f\"),ans[2],'message: <code>fib_luc(4,15,\"f\")</code> should return <code>[1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536]</code>.');",
        "assert.deepEqual(fib_luc(2,10,\"l\"),ans[3],'message: <code>fib_luc(2,10,\"l\")</code> should return <code>[ 2, 1, 3, 4, 7, 11, 18, 29, 47, 76]</code>.');",
        "assert.deepEqual(fib_luc(3,15,\"l\"),ans[4],'message: <code>fib_luc(3,15,\"l\")</code> should return <code>[ 2, 1, 3, 6, 10, 19, 35, 64, 118, 217, 399, 734, 1350, 2483, 4567 ]</code>.');",
        "assert.deepEqual(fib_luc(4,15,\"l\"),ans[5],'message: <code>fib_luc(4,15,\"l\")</code> should return <code>[ 2, 1, 3, 6, 12, 22, 43, 83, 160, 308, 594, 1145, 2207, 4254, 8200 ]</code>.');",
        "assert.deepEqual(fib_luc(5,15,\"l\"),ans[6],'message: <code>fib_luc(5,15,\"l\")</code> should return <code>[ 2, 1, 3, 6, 12, 24, 46, 91, 179, 352, 692, 1360, 2674, 5257, 10335 ]</code>.');"
      ],
      "id": "598eef80ba501f1268170e1e"
    },
    {
      "title": "Fibonacci sequence",
      "type": "rosetta-code",
      "categories": [
        "Recursion",
        "Memoization",
        "Classic CS problems and programs"
      ],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p>Write a function to generate the  <big> n<sup>th</sup> </big>  Fibonacci number.</p>",
        "///<p>The <big> n<sup>th</sup> </big>  Fibonacci number is given by :<br>",
        "///<p>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></p>",
        "///<p>The first two terms of the series are 0, 1.</p>",
        "///<p>Hence, the series is : 0, 1, 1, 2, 3, 5, 8, 13...</p>",
        "///</div>"
      ],
      "challengeSeed": [
        "function fibonacci(n) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function fibonacci(n) {\n  let a = 0, b = 1, t;\n  while (--n > 0) {\n    t = a;\n    a = b;\n    b += t;\n  }\n  return a;\n}\n"
      ],
      "tail": [],
      "tests": [
        "assert(typeof fibonacci === 'function', 'message: <code>fibonacci</code> is a function.');",
        "assert(typeof fibonacci(2) == 'number', 'message: <code>fibonacci(2)</code> should return a number.');",
        "assert.equal(fibonacci(3),1,\"message: <code>fibonacci(3)</code> should return 1.\");",
        "assert.equal(fibonacci(5),3,\"message: <code>fibonacci(5)</code> should return 3.\");",
        "assert.equal(fibonacci(10),34,\"message: <code>fibonacci(10)</code> should return 34.\");"
      ],
      "id": "597f24c1dda4e70f53c79c81"
    },
    {
      "title": "Fibonacci word",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "5",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">Write a function to return the Fibonacci Words upto N. N will be provided as a parameter to the function. The function should return an array of objects. The objects should be of the form : { N: 1, Length: 1, Entropy: 0, Word: '1' }. More details are given below : </p><p class=\"rosetta__paragraph\">The  Fibonacci Word  may be created in a manner analogous to the  Fibonacci Sequence   <a class=\"rosetta__link--wiki\" href=\"http://hal.archives-ouvertes.fr/docs/00/36/79/72/PDF/The_Fibonacci_word_fractal.pdf\" title=\"link: http://hal.archives-ouvertes.fr/docs/00/36/79/72/PDF/The_Fibonacci_word_fractal.pdf\">as described here</a>:</p><br/><p class=\"rosetta__paragraph\">Define  F_Word<sub>1</sub>  as  <span class=\"rosetta__text--bold\">1</span></p>",
        "<p class=\"rosetta__paragraph\">Define  F_Word<sub>2</sub>  as  <span class=\"rosetta__text--bold\">0</span></p>",
        "<p class=\"rosetta__paragraph\">Form   F_Word<sub>3</sub>  as  F_Word<sub>2</sub>   concatenated with  F_Word<sub>1</sub>   i.e.:  <span class=\"rosetta__text--bold\">01</span></p>",
        "<p class=\"rosetta__paragraph\">Form   F_Word<sub>n</sub>  as  F_Word<sub>n-1</sub>  concatenated with  F_word<sub>n-2</sub></p>",
        "<br/></div>"
      ],
      "challengeSeed": [
        "function fibWord (n) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function fibWord(n) {\n    function entropy(s) {\n         //create an object containing each individual char\n      //and the amount of iterations per char \n        function prob(s) {\n            var h = Object.create(null);\n            s.split('').forEach(function(c) {\n               h[c] && h[c]++ || (h[c] = 1); \n            });\n            return h;\n        }\n\n        s = s.toString(); //just in case \n        var e = 0, l = s.length, h = prob(s);\n\n        for (var i in h ) {\n            var p = h[i]/l;\n            e -= p * Math.log(p) / Math.log(2);\n        }\n        return e;\n    }\n    var wOne = \"1\", wTwo = \"0\", wNth = [wOne, wTwo], w = \"\", o = [];\n \n    for (var i = 0; i < n; i++) {\n        if (i === 0 || i === 1) {\n            w = wNth[i];\n        } else {\n            w = wNth[i - 1] + wNth[i - 2];\n            wNth.push(w);\n        }\n        var l = w.length;\n        var e = entropy(w);\n \n        if (l <= 21) {\n        \to.push({\n            \tN: i + 1,\n            \tLength: l,\n            \tEntropy: e,\n            \tWord: w\n        \t});\n        } else {\n        \to.push({\n            \tN: i + 1,\n            \tLength: l,\n            \tEntropy: e,\n            \tWord: \"...\"\n        \t});\n        }            \n    }\n  return o;\n}\n"
      ],
      "tail": [
        "let ans=[ { N: 1, Length: 1, Entropy: 0, Word: '1' },",
        "",
        "  { N: 2, Length: 1, Entropy: 0, Word: '0' },",
        "",
        "  { N: 3, Length: 2, Entropy: 1, Word: '01' },",
        "",
        "  { N: 4, Length: 3, Entropy: 0.9182958340544896, Word: '010' },",
        "",
        "  { N: 5, Length: 5, Entropy: 0.9709505944546688, Word: '01001' }];"
      ],
      "tests": [
        "assert(typeof fibWord === 'function', 'message: <code>fibWord</code> is a function.');",
        "assert(Array.isArray(fibWord(5)),'message: <code>fibWord(5)</code> should return an array.');",
        "assert.deepEqual(fibWord(5),ans,'message: <code>fibWord(5)</code> should return <code>'+JSON.stringify(ans)+'</code>.');"
      ],
      "id": "5992e222d397f00d21122931"
    },
    {
      "title": "Filter",
      "type": "rosetta-code",
      "categories": "Iteration",
      "difficulty": "1",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Write a function that takes an array as input. The function should return an array with all the even numbers from the input array, i.e. filter the even numbers from the input array and return the new array.</p>",
        "<br><br><br/></div>"
      ],
      "challengeSeed": [
        "function filter (arr) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function filter(arr){\n\tarr = arr.filter(function(a) {return a % 2 == 0});\n\treturn arr;\n}\n"
      ],
      "tests": [
        "assert(typeof filter === 'function', 'message: <code>filter</code> is a function.');",
        "assert.deepEqual(filter([1,2,3,4,5]),[2,4],'message: <code>filter([1,2,3,4,5])</code> should return <code>[2,4]</code>.');",
        "assert.deepEqual(filter([13,22,113,24,54,21,19]),[22,24,54],'message: <code>filter([13,22,113,24,54,21,19])</code> should return <code>[22,24,54]</code>.');",
        "assert.deepEqual(filter([66,23,31,14,34]),[66,14,34],'message: <code>filter([66,23,31,14,34])</code> should return <code>[66,14,34]</code>.');",
        "assert.deepEqual(filter([10,20,33,40,50]),[10,20,40,50],'message: <code>filter([10,20,33,40,50])</code> should return <code>[10,20,40,50]</code>.');",
        "assert.deepEqual(filter([1999,2014,1985,2000,2017]),[2014,2000],'message: <code>filter([1999,2014,1985,2000,2017])</code> should return <code>[2014,2000]</code>.');"
      ],
      "id": "5a5dafbc992d5b1e20b083c2"
    },
    {
      "title": "Find common directory path",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Create a function that, given a set of strings representing directory paths and a '/' character as directory separator, will return a string representing that part of the directory tree that is common to all the directories.</p><br/>",
        "</div>"
      ],
      "challengeSeed": [
        "function commonDir (paths) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function commonDir(paths){\n\tlet commonpath=\"\",a,b;\n\n\tpaths=paths.map(function(e){\n\t\treturn e.split(\"/\");\n\t});\n\n\tlet first=paths[0];\n\n\tfor(var i=0;i<first.length;i++){\n\t\ta=first[i];\n\n\t\tfor (var j=0;j<paths.length;j++){\n\t\t\tb=paths[j];\n\t\t\tif(a!=b[i]){\n\t\t\t\ta=null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(a!=null){\n\t\t\tcommonpath+=a+\"/\";\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn commonpath;\n}\n"
      ],
      "tail": [
        "let paths=[['/home/user1/tmp/coverage/test' ,'/home/user1/tmp/covert/operator' ,'/home/user1/tmp/coven/members'],",
        "          ['/dir1/dir2/subdir','/dir1/subdir2','/dir1/dir2/dir3','/dir1/dir2/subsurf/dir3'],",
        "          ['/dir/hello_dir','/dir2/subdir1'],",
        "          ['/path/var/tmp/dev','/path/var/spool'],",
        "          ['/bin/include/headers','/bin/include/links','/bin/addons/include/headers','/bin/brick/var/tmp']];",
        "",
        "let outputs=[\"/home/user1/tmp/\",",
        "            \"/dir1/\",",
        "            \"/\",",
        "            \"/path/var/\",",
        "            \"/bin/\"]"
      ],
      "tests": [
        "assert(typeof commonDir=='function','message: <code>commonDir</code> should be a function.');",
        "assert(typeof commonDir(paths[0])=='string','message: <code>commonDir('+JSON.stringify(paths[0])+')</code> should return a string.');",
        "assert.equal(commonDir(paths[0]),outputs[0],'message: <code>commonDir('+JSON.stringify(paths[0])+')</code> should return <code>\"'+outputs[0]+'\"</code>.');",
        "assert.equal(commonDir(paths[1]),outputs[1],'message: <code>commonDir('+JSON.stringify(paths[1])+')</code> should return <code>\"'+outputs[1]+'\"</code>.');",
        "assert.equal(commonDir(paths[2]),outputs[2],'message: <code>commonDir('+JSON.stringify(paths[2])+')</code> should return <code>\"'+outputs[2]+'\"</code>.');",
        "assert.equal(commonDir(paths[3]),outputs[3],'message: <code>commonDir('+JSON.stringify(paths[3])+')</code> should return <code>\"'+outputs[3]+'\"</code>.');",
        "assert.equal(commonDir(paths[4]),outputs[4],'message: <code>commonDir('+JSON.stringify(paths[4])+')</code> should return <code>\"'+outputs[4]+'\"</code>.');"
      ],
      "id": "5a5f60c86c6a5b182fbb2044"
    },
    {
      "title": "Find largest left truncatable prime in a given base",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "4",
      "description": "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">A <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Truncatable primes\" title=\"Truncatable primes\">truncatable prime</a> is one where all non-empty substrings that finish at the end of the number (right-substrings) are also primes <span class=\"rosetta__text--italic\">when understood as numbers in a particular base</span>. The largest such prime in a given (integer) base is therefore computable, provided the base is larger than 2.</p><br/><p class=\"rosetta__paragraph\">Write a function that takes radix/base as parameter and returns the largest left trunctable prime for the given radix/base.</p></div>",
      "challengeSeed": [
        "function getLargestLeftTruncPrime(radix) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "// noprotect\nfunction getLargestLeftTruncPrime(radix)\n{\n  function isPrime(n) {\n      if(n < 2) return false;\n      if(n == 2 || n == 3) return true;\n      if(n%2 == 0 || n%3 == 0) return false;\n      var sqrtN = Math.sqrt(n)+1;\n      for(var i = 6; i <= sqrtN; i += 6) {\n          if(n%(i-1) == 0 || n%(i+1) == 0) return false;\n      }\n      return true;\n  }\n  function getNextLeftTruncatablePrimes(n,radix)\n  {\n    var probablePrimes = [];\n    var baseString = n==0? \"\" : n.toString(radix);\n    for (var i = 1; i < radix; i++)\n    {\n      var p = parseInt(i.toString(radix) + baseString, radix);\n      if (isPrime(p))\n        probablePrimes.push(p);\n    }\n    return probablePrimes;\n  }\n  var lastList = null;\n  var list = getNextLeftTruncatablePrimes(0, radix);\n  while (list.length!=0)\n  {\n    lastList = list;\n    list = [];\n    lastList.forEach(function(n){\n      list.push.apply(list,getNextLeftTruncatablePrimes(n, radix));\n    });\n  }\n  if (lastList == null)\n    return null;\n  lastList.sort();\n  return lastList[lastList.length - 1];\n}\n"
      ],
      "tail": [
        "let tests=[3,4,5,6,8]",
        "let results=[23,4091,7817,4836525320399,14005650767869]"
      ],
      "tests": [
        "assert(typeof getLargestLeftTruncPrime=='function','message: <code>getLargestLeftTruncPrime</code> should be a function.');",
        "assert(typeof getLargestLeftTruncPrime(3)=='number','message: <code>getLargestLeftTruncPrime(3)</code> should return a number.');",
        "assert.equal(getLargestLeftTruncPrime(tests[0]),results[0],'message: <code>getLargestLeftTruncPrime('+tests[0]+')</code> should return <code>'+results[0]+'</code>.');",
        "assert.equal(getLargestLeftTruncPrime(tests[1]),results[1],'message: <code>getLargestLeftTruncPrime('+tests[1]+')</code> should return <code>'+results[1]+'</code>.');",
        "assert.equal(getLargestLeftTruncPrime(tests[2]),results[2],'message: <code>getLargestLeftTruncPrime('+tests[2]+')</code> should return <code>'+results[2]+'</code>.');",
        "assert.equal(getLargestLeftTruncPrime(tests[3]),results[3],'message: <code>getLargestLeftTruncPrime('+tests[3]+')</code> should return <code>'+results[3]+'</code>.');",
        "assert.equal(getLargestLeftTruncPrime(tests[4]),results[4],'message: <code>getLargestLeftTruncPrime('+tests[4]+')</code> should return <code>'+results[4]+'</code>.');"
      ],
      "id": "5a5f6220598ea5191b9925bc"
    },
    {
      "title": "Find palindromic numbers in both binary and ternary bases",
      "type": "rosetta-code",
      "categories": "Palindromes",
      "difficulty": "3",
      "benchmark": "binTernPalin()",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">The task:</dt></dl><br/><p class=\"rosetta__paragraph\">Write a function that returns the first five numbers (non-negative integers) that are <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Palindrome detection\" title=\"Palindrome detection\">palindromes</a> in  <span class=\"rosetta__text--italic\">both</span>  base 2 and base 3.</p><br/><p class=\"rosetta__paragraph\">Use zero (0) as the first number found, even though some other definitions ignore it.</p><br/><p class=\"rosetta__paragraph\">The function should return the decimal form of the numbers as an array.</p></div>792\">Sequence A60792</a>,  numbers that are palindromic in bases 2 and 3 on <span class=\"rosetta__text--italic\">The On-Line Encyclopedia of Integer Sequences</span>.</li></ul><br><br><br/></div>"
      ],
      "challengeSeed": [
        "function binTernPalin () {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function binTernPalin(){\n    // GENERIC FUNCTIONS\n    // range :: Int -> Int -> [Int]\n\n    const range = (m, n) =>\n\n        Array.from({\n\n            length: Math.floor(n - m) + 1\n\n        }, (_, i) => m + i);\n\n\n    // compose :: (b -> c) -> (a -> b) -> (a -> c)\n\n    const compose = (f, g) => x => f(g(x));\n\n    // reverse :: [a] -> [a]\n\n    const reverse = xs =>\n\n        typeof xs === 'string' ? (\n\n            xs.split('')\n\n            .reverse()\n\n            .join('')\n\n        ) : xs.slice(0)\n\n        .reverse();\n\n\n    // take :: Int -> [a] -> [a]\n\n    const take = (n, xs) => xs.slice(0, n);\n\n\n    // drop :: Int -> [a] -> [a]\n\n    const drop = (n, xs) => xs.slice(n);\n\n\n    // quotRem :: Integral a => a -> a -> (a, a)\n\n    const quotRem = (m, n) => [Math.floor(m / n), m % n];\n\n\n    // length :: [a] -> Int\n\n    const length = xs => xs.length;\n\n    // BASES AND PALINDROMES\n\n    // show, showBinary, showTernary :: Int -> String\n\n    const show = n => n.toString(10);\n\n    const showBinary = n => n.toString(2);\n\n    const showTernary = n => n.toString(3);\n\n\n    // readBase3 :: String -> Int\n\n    const readBase3 = s => parseInt(s, 3);\n\n\n    // base3Palindrome :: Int -> String\n\n    const base3Palindrome = n => {\n\n        const s = showTernary(n);\n\n        return s + '1' + reverse(s);\n\n    };\n\n\n    // isBinPal :: Int -> Bool\n\n    const isBinPal = n => {\n\n        const\n\n            s = showBinary(n),\n\n            [q, r] = quotRem(s.length, 2);\n\n        return (r !== 0) && drop(q + 1, s) === reverse(take(q, s));\n\n    };\n\n\n    // solutions :: [Int]\n\n    const solutions = [0, 1].concat(range(1, 50000)\n\n        .map(compose(readBase3, base3Palindrome))\n\n        .filter(isBinPal));\n\n\n    return solutions;\n};\n"
      ],
      "tail": [],
      "tests": [
        "assert(typeof binTernPalin=='function','message: <code>binTernPalin</code> should be a function.');",
        "assert(Array.isArray(binTernPalin()),'message: <code>binTernPalin()</code> should return an Array.');",
        "assert.deepEqual(binTernPalin(),[ 0, 1, 6643, 1422773, 5415589 ],'message: <code>binTernPalin()</code> should return <code>[ 0, 1, 6643, 1422773, 5415589 ]</code>.');"
      ],
      "id": "5a5f63e8b869a71a01cdb41d"
    },
    {
      "title": "Find the last Sunday of given month",
      "type": "rosetta-code",
      "categories": "Date and time",
      "difficulty": "2",
      "description": [
        "<div class='rosetta'>",
        "<p class='rosetta__paragraph'>Write a function that returns the date of the last Sunday of a given month of a given year. The month and year are the parameters of the function. The date should be returned as a string in the format 'yyyy-mm-dd'</p><br/>",
        "</div>"
      ],
      "challengeSeed": [
        "function lastSundayOfMonth (month, year) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function lastSundayOfMonth(month, year) {\n  const lastDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const dates = [];\n\n  if (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) lastDay[1] = 29;\n  const date = new Date(Date.UTC());\n  date.setUTCFullYear(year, month - 1, lastDay[month - 1]);\n  date.setUTCDate(date.getUTCDate() - date.getUTCDay());\n  return date.toISOString().substring(0, 10);\n}\n\n"
      ],
      "tail": [],
      "tests": [
        "assert(typeof lastSundayOfMonth === 'function', 'message: <code>lastSundayOfMonth </code> is a function.');",
        "assert(typeof lastSundayOfMonth(6, 2013) === 'string', 'message: <code>lastSundayOfMonth(6,2013)</code> should return a <code>string</code>.');",
        "assert.equal(lastSundayOfMonth(6, 2013), '2013-06-30', 'message: <code>lastSundayOfMonth(6,2013)</code> should return <code>2013-06-30</code>.');",
        "assert.equal(lastSundayOfMonth(2, 2013), '2013-02-24', 'message: <code>lastSundayOfMonth(2,2013)</code> should return <code>2013-02-24</code>.');",
        "assert.equal(lastSundayOfMonth(9, 1999), '1999-09-26', 'message: <code>lastSundayOfMonth(9,1999)</code> should return <code>1999-09-26</code>.');",
        "assert.equal(lastSundayOfMonth(12, 2010), '2010-12-26', 'message: <code>lastSundayOfMonth(12,2010)</code> should return <code>2010-12-26</code>.');",
        "assert.equal(lastSundayOfMonth(11, 2005), '2005-11-27', 'message: <code>lastSundayOfMonth(11,2005)</code> should return <code>2005-11-27</code>.');"
      ],
      "id": "5a5f66cf09e7bd1b6b4157e1"
    },
    {
      "title": "Find the missing permutation",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\"><p class=\"rosetta__paragraph\">Write a function that takes a string and an array as parameters. The array contains some of the permutation of the string. The function should return the missing permutations.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function permute (str,perms) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function permute(str,perms){\n  var x,v=str;\n    for(var p = -1, j, k, f, r, l = v.length, q = 1, i = l + 1; --i; q *= i);\n    for(x = [new Array(l), new Array(l), new Array(l), new Array(l)], j = q, k = l + 1, i = -1;\n        ++i < l; x[2][i] = i, x[1][i] = x[0][i] = j /= --k);\n    for(r = new Array(q); ++p < q;)\n        for(r[p] = new Array(l), i = -1; ++i < l; !--x[1][i] && (x[1][i] = x[0][i],\n            x[2][i] = (x[2][i] + 1) % l), r[p][i] = 0 ? x[3][i] : v[x[3][i]])\n            for(x[3][i] = x[2][i], f = 0; !f; f = !f)\n                for(j = i; j; x[3][--j] == x[2][i] && (x[3][i] = x[2][i] = (x[2][i] + 1) % l, f = 1));\n\n    var all = r.map(function(elem) {return elem.join('')});\n\n    var missing = all.filter(function(elem) {return perms.indexOf(elem) == -1});\n    return missing;\n};\n"
      ],
      "tail": [
        "const tests=[['AB'],",
        "          ['BA'],",
        "          [ 'BAC', 'CAB', 'CBA' ],",
        "          [ 'ABC', 'BCA' ],",
        "          [ 'ABDC','ADBC','BADC','BACD','ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB']];",
        "",
        "const results=[['BA'],",
        "             ['AB'],",
        "             [ 'ABC', 'ACB', 'BCA' ],",
        "             [ 'ACB', 'BAC', 'CAB', 'CBA' ],",
        "             [ 'BCAD','BDCA','BDAC','CADB','CBAD','CBDA','CDBA','DABC','DBCA','DBAC','DCBA','DCAB' ]];"
      ],
      "tests": [
        "assert(typeof permute==\"function\",\"message: <code>permute</code> should be a function.\");",
        "assert(Array.isArray(permute('AB',tests[0].slice())),\"message: <code>permute('AB',['AB'])</code> return an array.\");",
        "assert.deepEqual(permute('AB',tests[0].slice()),results[0],\"message:<code>permute('AB',\"+JSON.stringify(tests[0])+\")</code> should return <code>\"+JSON.stringify(results[0])+\"</code>\");assert.deepEqual(permute('AB',tests[1].slice()),results[1],\"message:<code>permute('AB',\"+JSON.stringify(tests[1])+\")</code> should return <code>\"+JSON.stringify(results[1])+\"</code>\");",
        "assert.deepEqual(permute('ABC',tests[2].slice()),results[2],\"message:<code>permute('ABC',\"+JSON.stringify(tests[2])+\")</code> should return <code>\"+JSON.stringify(results[2])+\"</code>\");",
        "assert.deepEqual(permute('ABC',tests[3].slice()),results[3],\"message:<code>permute('ABC',\"+JSON.stringify(tests[3])+\")</code> should return <code>\"+JSON.stringify(results[3])+\"</code>\");",
        "assert.deepEqual(permute('ABCD',tests[4].slice()),results[4],\"message:<code>permute('ABCD',\"+JSON.stringify(tests[4])+\")</code> should return <code>\"+JSON.stringify(results[4])+\"</code>\");"
      ],
      "id": "5a6091c34d579c0c906e2037"
    },
    {
      "title": "Five weekends",
      "type": "rosetta-code",
      "categories": "Puzzles",
      "difficulty": "3",
      "description": "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">Write a function that counts the months with five full weekends(five Fridays, Saturdays and Sundays) for a given year range. The year range is passed as parameter to the function.</p></div>",
      "challengeSeed": [
        "function fiveWeekends (startYear,endYear) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function fiveWeekends(startYear,endYear){\n  function startsOnFriday(month, year){\n   return new Date(year, month, 1).getDay() === 5;\n  }\n\n  function has31Days(month, year){\n    return new Date(year, month, 31).getDate() === 31;\n  }\n\n  function checkMonths(year){\n   var month, count = 0;\n   for (month = 0; month < 12; month += 1){\n    if (startsOnFriday(month, year) && has31Days(month, year)){\n     count += 1;\n    }\n   }\n   return count;\n  }\n var year,monthTotal = 0,total = 0;\n\n for (year = startYear; year <= endYear; year += 1){\n  monthTotal = checkMonths(year);\n  total += monthTotal;\n }\n return total;\n}\n"
      ],
      "tail": [],
      "tests": [
        "assert(typeof fiveWeekends=='function','message: <code>fiveWeekends</code> should be a function.');",
        "assert(typeof fiveWeekends(2000,2018)=='number','message: <code>fiveWeekends(2000,2018)</code> should return a number.');",
        "assert.equal(fiveWeekends(2000,2018),17,'message: <code>fiveWeekends(2000,2018)</code should return <code>17</code>.');",
        "assert.equal(fiveWeekends(1900,2100),201,'message: <code>fiveWeekends(1900,2100)</code should return <code>201</code>.');",
        "assert.equal(fiveWeekends(1950,2000),52,'message: <code>fiveWeekends(1950,2000)</code should return <code>52</code>.');",
        "assert.equal(fiveWeekends(2010,2015),6,'message: <code>fiveWeekends(2010,2015)</code should return <code>6</code>.');",
        "assert.equal(fiveWeekends(1500,2000),502,'message: <code>fiveWeekends(1500,2000)</code should return <code>502</code>.');"
      ],
      "id": "5a6093ece13c260dfda0caf0"
    },
    {
      "title": "FizzBuzz",
      "type": "rosetta-code",
      "categories": [
        "Iteration",
        "Recursion",
        "Simple"
      ],
      "difficulty": "1",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">Write a function that takes a number as a parameter and returns a string as follows:</p>",
        "<ul class=\"rosetta__unordered-list\">",
        "\t<li class=\"rosetta__list-item--unordered\"> for multiples of three, print Fizz (instead of the number)</li>",
        "\t<li class=\"rosetta__list-item--unordered\"> for multiples of five, print Buzz (instead of the number)</li>",
        "\t<li class=\"rosetta__list-item--unordered\"> for multiples of both three and five, print FizzBuzz (instead of the number) </li>",
        "\t<li class=\"rosetta__list-item--unordered\"> for all other numbers returns the number itself (as a string) </li>",
        "</ul>",
        "</div>"
      ],
      "challengeSeed": [
        "function fizzBuzz (i) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function fizzBuzz(i) {\n  if(!(i%3) && !(i%5))\n    return 'FizzBuzz'\n\n  if (!(i % 3))\n   return 'Fizz';\n\n  if (!(i % 5))\n    return 'Buzz';\n\n  return i.toString();\n}\n"
      ],
      "tail": [],
      "tests": [
        "assert(typeof fizzBuzz=='function','message: <code>fizzBuzz</code> should be a function.');",
        "assert(typeof fizzBuzz(3)=='string','message: <code>fizzBuzz(3)</code> should return a string.');",
        "assert.equal(fizzBuzz(3),\"Fizz\",'message: <code>fizzBuzz(3)</code> should return <code>\"Fizz\"</code>.');",
        "assert.equal(fizzBuzz(5),\"Buzz\",'message: <code>fizzBuzz(5)</code> should return <code>\"Buzz\"</code>.');",
        "assert.equal(fizzBuzz(10),\"Buzz\",'message: <code>fizzBuzz(10)</code> should return <code>\"Buzz\"</code>.');",
        "assert.equal(fizzBuzz(19),\"19\",'message: <code>fizzBuzz(21)</code> should return <code>\"19\"</code>.');",
        "assert.equal(fizzBuzz(1875),\"FizzBuzz\",'message: <code>fizzBuzz(1875)</code> should return <code>\"FizzBuzz\"</code>.');"
      ],
      "id": "5a6dd7f02bf89b132fcac7bd"
    },
    {
      "title": "Hailstone sequence",
      "type": "rosetta-code",
      "categories": [],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">The Hailstone sequence of numbers can be generated from a starting positive integer,  n  by:</p>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\"> If  n  is   <span class=\"rosetta__text--bold\">1</span>   then the sequence ends.</li>",
        "<li class=\"rosetta__list-item--unordered\"> If  n  is  <span class=\"rosetta__text--bold\">even</span> then the next  n  of the sequence <code> = n/2 </code></li>",
        "<li class=\"rosetta__list-item--unordered\"> If  n  is  <span class=\"rosetta__text--bold\">odd</span>   then the next  n  of the sequence <code> = (3 * n) + 1 </code></li></ul><br/><p class=\"rosetta__paragraph\">The (unproven) <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Collatz conjecture\" title=\"wp: Collatz conjecture\">Collatz conjecture</a> is that the hailstone sequence for any starting number always terminates.</p>",
        "<br/><p class=\"rosetta__paragraph\">The hailstone sequence is also known as <span class=\"rosetta__text--italic\">hailstone numbers</span> (because the values are usually subject to multiple descents and ascents like hailstones in a cloud), or as the <span class=\"rosetta__text--italic\">Collatz sequence</span>.</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Create a routine to generate the hailstone sequence for a number.</li>",
        "<li class=\"rosetta__list-item--ordered\">Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with <code>27, 82, 41, 124</code> and ending with <code>8, 4, 2, 1</code></li>",
        "<li class=\"rosetta__list-item--ordered\">Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length.<br>   (But don't show the actual sequence!)</li></ol><br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">See also:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--wiki\" href=\"http://xkcd.com/710\" title=\"link: http://xkcd.com/710\">xkcd</a> (humourous).</li></ul></div>"
      ],
      "challengeSeed": [
        "// noprotect",
        "function hailstoneSequence () {",
        "  const res = [];",
        "  // Good luck!",
        "",
        "  return res;",
        "}"
      ],
      "solutions": [
        "// noprotect\nfunction hailstoneSequence () {\n  const res = [];\n\n  function hailstone(n) {\n    const seq = [n];\n    while (n > 1) {\n      n = n % 2 ? 3 * n + 1 : n / 2;\n      seq.push(n);\n    }\n    return seq;\n  }\n\n  const h = hailstone(27);\n  const hLen = h.length;\n  res.push([...h.slice(0, 4), ...h.slice(hLen - 4, hLen)]);\n\n  let n = 0;\n  let max = 0;\n  for (let i = 100000; --i;) {\n    const seq = hailstone(i);\n    const sLen = seq.length;\n\n    if (sLen > max) {\n      n = i;\n      max = sLen;\n    }\n  }\n  res.push([max, n]);\n\n  return res;\n}\n"
      ],
      "tail": "const res = [[27, 82, 41, 124, 8, 4, 2, 1], [351, 77031]];",
      "tests": [
        "assert(typeof hailstoneSequence === 'function', 'message: <code>hailstoneSequence</code> is a function.');",
        "assert.deepEqual(hailstoneSequence(), res, 'message: <code>hailstoneSequence()</code> should return <code>[[27,82,41,124,8,4,2,1], [351, 77031]]</code>');"
      ],
      "id": "595608ff8bcd7a50bd490181"
    },
    {
      "title": "Happy numbers",
      "type": "rosetta-code",
      "categories": "?",
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">A happy number is defined by the following process:</p><br/>",
        "<p class=\"rosetta__paragraph\">Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers, while those that do not end in 1 are unhappy numbers.</p><br/>",
        "<p class=\"rosetta__paragraph\">Implement a function that returns true if the number is happy, or false if not.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function happy (number) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function happy (number) {\n  let m;\n  let digit;\n  const cycle = [];\n\n  while (number !== 1 && cycle[number] !== true) {\n    cycle[number] = true;\n    m = 0;\n    while (number > 0) {\n      digit = number % 10;\n      m += Math.pow(digit, 2);\n      number = (number - digit) / 10;\n    }\n    number = m;\n  }\n  return (number === 1);\n}\n"
      ],
      "tests": [
        "assert(typeof happy === 'function', 'message: <code>happy</code> is a function.');",
        "assert(typeof happy(1) === 'boolean', 'message: <code>happy(1)</code> should return a boolean.');",
        "assert(happy(1), 'message: <code>happy(1)</code> should return true.');",
        "assert(!happy(2), 'message: <code>happy(2)</code> should return false.');",
        "assert(happy(7), 'message: <code>happy(7)</code> should return true.');",
        "assert(happy(10), 'message: <code>happy(10)</code> should return true.');",
        "assert(happy(13), 'message: <code>happy(13)</code> should return true.');",
        "assert(happy(19), 'message: <code>happy(19)</code> should return true.');",
        "assert(happy(23), 'message: <code>happy(23)</code> should return true.');",
        "assert(happy(28), 'message: <code>happy(28)</code> should return true.');",
        "assert(happy(31), 'message: <code>happy(31)</code> should return true.');",
        "assert(happy(32), 'message: <code>happy(32)</code> should return true:.');",
        "assert(!happy(33), 'message: <code>happy(33)</code> should return false.');"
      ],
      "id": "594810f028c0303b75339ad1"
    },
    {
      "title": "Harshad or Niven series",
      "type": "rosetta-code",
      "categories": [],
      "difficulty": "2",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">The <a class=\"rosetta__link--wiki\" href=\"http://mathworld.wolfram.com/HarshadNumber.html\" title=\"link: http://mathworld.wolfram.com/HarshadNumber.html\">Harshad</a> or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.</p><br/><p class=\"rosetta__paragraph\">For example,  <span class=\"rosetta__text--bold\">42</span>  is a <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/oeis:A005349\" title=\"oeis:A005349\">Harshad number</a> as  <span class=\"rosetta__text--bold\">42</span>  is divisible by  (<span class=\"rosetta__text--bold\">4</span> + <span class=\"rosetta__text--bold\">2</span>)  without remainder.</p>",
        "<br>Assume that the series is defined as the numbers in increasing order.",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Implement a function to generate successive members of the Harshad sequence.</p><br/><p class=\"rosetta__paragraph\">Use it to list the first twenty members of the sequence and list the first Harshad number greater than 1000.</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function isHarshadOrNiven () {",
        "  const res = {",
        "    firstTwenty: [],",
        "    firstOver1000: undefined",
        "  };",
        "  // Change after this line",
        "",
        "  return res;",
        "}"
      ],
      "solutions": [
        "function isHarshadOrNiven() {\n  const res = {\n    firstTwenty: [],\n    firstOver1000: undefined\n  };\n\n  function isHarshad(n) {\n    let s = 0;\n    const nStr = n.toString();\n    for (let i = 0; i < nStr.length; ++i) {\n      s += parseInt(nStr.charAt(i), 10);\n    }\n    return n % s === 0;\n  }\n\n  let count = 0;\n  const harshads = [];\n\n  for (let n = 1; count < 20; ++n) {\n    if (isHarshad(n)) {\n      count++;\n      harshads.push(n);\n    }\n  }\n\n  res.firstTwenty = harshads;\n\n  let h = 1000;\n  while (!isHarshad(++h));\n  res.firstOver1000 = h;\n\n  return res;\n}\n"
      ],
      "tail": [
        "const res = {",
        "  firstTwenty: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42],",
        "  firstOver1000: 1002",
        "};"
      ],
      "tests": [
        "assert(typeof isHarshadOrNiven === 'function', 'message: <code>isHarshadOrNiven</code> is a function.');",
        "assert.deepEqual(isHarshadOrNiven(), res, 'message: <code>isHarshadOrNiven()</code> should return <code>{\"firstTwenty\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42],\"firstOver1000\": 1002}</code>');"
      ],
      "id": "595668ca4cfe1af2fb9818d4"
    },
    {
      "title": "Hash from two arrays",
      "type": "rosetta-code",
      "categories": "Data Structures",
      "difficulty": "1",
      "benchmark": "arrToObj(Array.apply(null, { length: 10000 }).map(String.call, String), Array.apply(null, { length: 10000 }).map(Number.call, Number));",
      "description": [
        "<div class=\"rosetta\">",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Using two Arrays of equal length, create a Hash object where the elements from one array (the keys) are linked to the elements of the other (the values)</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Related task:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\"> <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Associative arrays/Creation\" title=\"Associative arrays/Creation\">Associative arrays/Creation</a></li></ul>",
        "</div>"
      ],
      "challengeSeed": [
        "function arrToObj (keys, vals) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function arrToObj (keys, vals) {\n  return keys.reduce((map, key, index) => {\n    map[key] = vals[index];\n    return map;\n  }, {});\n}"
      ],
      "tail": [
        "const testCases = [",
        "  [[1, 2, 3, 4, 5], ['a', 'b', 'c', 'd', 'e']],",
        "  [[1, 2, 3, 4, 5], ['a', 'b', 'c', 'd']],",
        "  [[1, 2, 3], ['a', 'b', 'c', 'd', 'e']],",
        "  [['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4, 5]],",
        "  [['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4]],",
        "  [['a', 'b', 'c'], [1, 2, 3, 4, 5]]",
        "];",
        "",
        "const res = [",
        "  { 1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e' },",
        "  { 1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: undefined },",
        "  { 1: 'a', 2: 'b', 3: 'c' },",
        "  { a: 1, b: 2, c: 3, d: 4, e: 5 },",
        "  { a: 1, b: 2, c: 3, d: 4, e: undefined },",
        "  { a: 1, b: 2, c: 3 }",
        "];"
      ],
      "tests": [
        "assert(typeof arrToObj === 'function', 'message: <code>arrToObj</code> is a function.');",
        "assert.deepEqual(arrToObj(...testCases[0]), res[0], 'message: <code>arrToObj([1, 2, 3, 4, 5], [\"a\", \"b\", \"c\", \"d\", \"e\"])</code> should return <code>{ 1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: \"e\" }</code>');",
        "assert.deepEqual(arrToObj(...testCases[1]), res[1], 'message: <code>arrToObj([1, 2, 3, 4, 5], [\"a\", \"b\", \"c\", \"d\"])</code> should return <code>{ 1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: undefined }</code>');",
        "assert.deepEqual(arrToObj(...testCases[2]), res[2], 'message: <code>arrToObj([1, 2, 3], [\"a\", \"b\", \"c\", \"d\", \"e\"])</code> should return <code>{ 1: \"a\", 2: \"b\", 3: \"c\" }</code>');",
        "assert.deepEqual(arrToObj(...testCases[3]), res[3], 'message: <code>arrToObj([\"a\", \"b\", \"c\", \"d\", \"e\"], [1, 2, 3, 4, 5])</code> should return <code>{ \"a\": 1, \"b\": 2, \"c\": 3 , \"d\": 4, \"e\": 5 }</code>');",
        "assert.deepEqual(arrToObj(...testCases[4]), res[4], 'message: <code>arrToObj([\"a\", \"b\", \"c\", \"d\", \"e\"], [1, 2, 3, 4])</code> should return <code>{ \"a\": 1, \"b\": 2, \"c\": 3 , \"d\": 4, \"e\": undefined }</code>');",
        "assert.deepEqual(arrToObj(...testCases[5]), res[5], 'message: <code>arrToObj([\"a\", \"b\", \"c\"], [1, 2, 3, 4, 5])</code> should return <code>{ \"a\": 1, \"b\": 2, \"c\": 3  }</code>');"
      ],
      "id": "595671d4d2cdc305f0d5b36f"
    },
    {
      "title": "Hash join",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "3",
      "benchmark": "hashJoin(bench1, bench2);",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">An <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Join_(SQL)#Inner_join\" title=\"wp: Join_(SQL)#Inner_join\">inner join</a> is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Nested loop join\" title=\"wp: Nested loop join\">nested loop join</a> algorithm, but a more scalable alternative is the <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/hash join\" title=\"wp: hash join\">hash join</a> algorithm.</p>",
        "<br/>",
        "<p class=\"rosetta__paragraph\">Implement the \"hash join\" algorithm, and demonstrate that it passes the test-case listed below.</p><br/><p class=\"rosetta__paragraph\">You should represent the tables as data structures that feel natural in your programming language.</p>",
        "<br/>",
        "<p class=\"rosetta__paragraph\">The \"hash join\" algorithm consists of two steps:</p><br/>",
        "<ol class=\"rosetta__ordered-list\">",
        "<li class=\"rosetta__list-item--ordered\"><span class=\"rosetta__text--bold\">Hash phase:</span> Create a <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Multimap\" title=\"wp: Multimap\">multimap</a> from one of the two tables, mapping from each join column value to all the rows that contain it.<br></li>",
        "<ul class=\"rosetta__unordered-list\">",
        "<li class=\"rosetta__list-item--unordered\"> The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.</li>",
        "<li class=\"rosetta__list-item--unordered\"> Ideally we should create the multimap for the <span class=\"rosetta__text--italic\">smaller</span> table, thus minimizing its creation time and memory size.</li>",
        "</ul>",
        "<li class=\"rosetta__list-item--ordered\"><span class=\"rosetta__text--bold\">Join phase:</span> Scan the other table, and find matching rows by looking in the multimap created before.</li>",
        "</ol><br>",
        "<p class=\"rosetta__paragraph\">In pseudo-code, the algorithm could be expressed as follows:</p><br/>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "<span class=\"rosetta__text--bold\">let</span> <span class=\"rosetta__text--italic\">A</span> = the first input table (or ideally, the larger one)",
        "<span class=\"rosetta__text--bold\">let</span> <span class=\"rosetta__text--italic\">B</span> = the second input table (or ideally, the smaller one)",
        "<span class=\"rosetta__text--bold\">let</span> <span class=\"rosetta__text--italic\">j<sub>A</sub></span> = the join column ID of table <span class=\"rosetta__text--italic\">A</span>",
        "<span class=\"rosetta__text--bold\">let</span> <span class=\"rosetta__text--italic\">j<sub>B</sub></span> = the join column ID of table <span class=\"rosetta__text--italic\">B</span>",
        "<span class=\"rosetta__text--bold\">let</span> <span class=\"rosetta__text--italic\">M<sub>B</sub></span> = a multimap for mapping from single values to multiple rows of table <span class=\"rosetta__text--italic\">B</span> (starts out empty)",
        "<span class=\"rosetta__text--bold\">let</span> <span class=\"rosetta__text--italic\">C</span> = the output table (starts out empty)<br/>",
        "<span class=\"rosetta__text--bold\">for each</span> row <span class=\"rosetta__text--italic\">b</span> <span class=\"rosetta__text--bold\">in</span> table <span class=\"rosetta__text--italic\">B<span class=\"rosetta__text--bold\"></span>:</span>",
        "<span class=\"rosetta__text--bold\">  place</span> <span class=\"rosetta__text--italic\">b</span> <span class=\"rosetta__text--bold\">in</span> multimap <span class=\"rosetta__text--italic\">M<sub>B</sub></span> under key <span class=\"rosetta__text--italic\">b</span>(<span class=\"rosetta__text--italic\">j<sub>B</sub></span>)<br/>",
        "<span class=\"rosetta__text--bold\">for each</span> row <span class=\"rosetta__text--italic\">a</span> <span class=\"rosetta__text--bold\">in</span> table <span class=\"rosetta__text--italic\">A<span class=\"rosetta__text--bold\"></span>:</span>",
        "<span class=\"rosetta__text--bold\">  for each</span> row <span class=\"rosetta__text--italic\">b</span> <span class=\"rosetta__text--bold\">in</span> multimap <span class=\"rosetta__text--italic\">M<sub>B</sub></span> under key <span class=\"rosetta__text--italic\">a</span>(<span class=\"rosetta__text--italic\">j<sub>A</sub></span>)<span class=\"rosetta__text--bold\">:</span>",
        "<span class=\"rosetta__text--bold\">    let</span> <span class=\"rosetta__text--italic\">c</span> = the concatenation of row <span class=\"rosetta__text--italic\">a</span> and row <span class=\"rosetta__text--italic\">b</span>",
        "<span class=\"rosetta__text--bold\">    place</span> row <span class=\"rosetta__text--italic\">c</span> in table <span class=\"rosetta__text--italic\">C</span></p>",
        "</pre></div>",
        "<br/>",
        "<div id=\"Test-case\" style=\"margin:20px 0 10px 0; line-height:1.1; font-size:16.5px; font-weight:bold\">Test-case</div>",
        "<p class=\"rosetta__paragraph rosetta__text--centered rosetta__text--bold\">Input</p>",
        "<table class=\"rosetta__wikitable\">",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\">",
        "<table style=\"border:none; border-collapse:collapse;\">",
        "<tr>",
        "<td style=\"border:none\"> <i>A =</i>",
        "</td>",
        "<td style=\"border:none\">",
        "<table class=\"rosetta__wikitable\">",
        "<tr>",
        "<th style=\"padding: 4px; margin: 5px;\"> Age </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> Name",
        "</th></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 27 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 18 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Glory",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 18 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Popeye",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan",
        "</td></tr></table>",
        "</td>",
        "<td style=\"border:none; padding-left:1.5em;\" rowspan=\"2\">",
        "</td>",
        "<td style=\"border:none\"> <i>B =</i>",
        "</td>",
        "<td style=\"border:none\">",
        "<table class=\"rosetta__wikitable\">",
        "<tr>",
        "<th style=\"padding: 4px; margin: 5px;\"> Character </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> Nemesis",
        "</th></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Whales",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Spiders",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Ghosts",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Zombies",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> Glory </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Buffy",
        "</td></tr></table>",
        "</td></tr>",
        "<tr>",
        "<td style=\"border:none\"> <i>j<sub>A</sub> =</i>",
        "</td>",
        "<td style=\"border:none\"> <i><code>Name</code> (i.e. column 1)</i>",
        "</td>",
        "<td style=\"border:none\"> <i>j<sub>B</sub> =</i>",
        "</td>",
        "<td style=\"border:none\"> <i><code>Character</code> (i.e. column 0)</i>",
        "</td></tr></table>",
        "</td>",
        "<td style=\"padding: 4px; margin: 5px;\">",
        "</td></tr></table>",
        "<br>",
        "<p class=\"rosetta__paragraph rosetta__text--centered rosetta__text--bold\">Output</p>",
        "<table class=\"rosetta__wikitable\">",
        "<tr>",
        "<th style=\"padding: 4px; margin: 5px;\"> A.Age </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> A.Name </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> B.Character </th>",
        "<th style=\"padding: 4px; margin: 5px;\"> B.Nemesis",
        "</th></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 27 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Whales",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 27 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Jonah </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Spiders",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 18 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Ghosts",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 18 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Zombies",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Glory </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Glory </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Buffy",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Ghosts",
        "</td></tr>",
        "<tr>",
        "<td style=\"padding: 4px; margin: 5px;\"> 28 </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Alan </td>",
        "<td style=\"padding: 4px; margin: 5px;\"> Zombies",
        "</td></tr></table>",
        "<br>",
        "<p class=\"rosetta__paragraph\"></p><br/><p class=\"rosetta__paragraph\"></p><br/><p class=\"rosetta__paragraph\">The order of the rows in the output table is not significant.<br></p>",
        "<p class=\"rosetta__paragraph\">If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form <code style=\"white-space:nowrap\">[[27, \"Jonah\"], [\"Jonah\", \"Whales\"]]</code>.</p><br><hr><br/></div>"
      ],
      "challengeSeed": [
        "function hashJoin (hash1, hash2) {",
        "  // Good luck!",
        "  return [];",
        "}"
      ],
      "solutions": [
        "function hashJoin (hash1, hash2) {\n  const hJoin = (tblA, tblB, strJoin) => {\n    const [jA, jB] = strJoin.split('=');\n    const M = tblB.reduce((a, x) => {\n      const id = x[jB];\n      return (\n        a[id] ? a[id].push(x) : (a[id] = [x]),\n        a\n      );\n    }, {});\n\n    return tblA.reduce((a, x) => {\n      const match = M[x[jA]];\n      return match ? (\n                a.concat(match.map(row => dictConcat(x, row)))\n            ) : a;\n    }, []);\n  };\n\n  const dictConcat = (dctA, dctB) => {\n    const ok = Object.keys;\n    return ok(dctB).reduce(\n            (a, k) => (a[`B_${k}`] = dctB[k]) && a,\n            ok(dctA).reduce(\n                (a, k) => (a[`A_${k}`] = dctA[k]) && a, {}\n            )\n        );\n  };\n\n  return hJoin(hash1, hash2, 'name=character');\n}\n\n"
      ],
      "tail": [
        "const hash1 = [",
        "    { age: 27, name: 'Jonah' },",
        "    { age: 18, name: 'Alan' },",
        "    { age: 28, name: 'Glory' },",
        "    { age: 18, name: 'Popeye' },",
        "    { age: 28, name: 'Alan' }",
        "];",
        "",
        "const hash2 = [",
        "    { character: 'Jonah', nemesis: 'Whales' },",
        "    { character: 'Jonah', nemesis: 'Spiders' },",
        "    { character: 'Alan', nemesis: 'Ghosts' },",
        "    { character: 'Alan', nemesis: 'Zombies' },",
        "    { character: 'Glory', nemesis: 'Buffy' },",
        "    { character: 'Bob', nemesis: 'foo' }",
        "];",
        "",
        "const res = [",
        "    { A_age: 27, A_name: 'Jonah', B_character: 'Jonah', B_nemesis: 'Whales' },",
        "    { A_age: 27, A_name: 'Jonah', B_character: 'Jonah', B_nemesis: 'Spiders' },",
        "    { A_age: 18, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Ghosts' },",
        "    { A_age: 18, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Zombies' },",
        "    { A_age: 28, A_name: 'Glory', B_character: 'Glory', B_nemesis: 'Buffy' },",
        "    { A_age: 28, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Ghosts' },",
        "    { A_age: 28, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Zombies' }",
        "];",
        "",
        "const bench1 = [{ name: 'u2v7v', num: 1 }, { name: 'n53c8', num: 10 }, { name: 'oysce', num: 9 }, { name: '0mto2s', num: 1 }, { name: 'vkh5id', num: 4 }, { name: '5od0cf', num: 8 }, { name: 'uuulue', num: 10 }, { name: '3rgsbi', num: 9 }, { name: 'kccv35r', num: 4 }, { name: '80un74', num: 9 }, { name: 'h4pp3', num: 6 }, { name: '51bit', num: 7 }, { name: 'j9ndf', num: 8 }, { name: 'vf3u1', num: 10 }, { name: 'g0bw0om', num: 10 }, { name: 'j031x', num: 7 }, { name: 'ij3asc', num: 9 }, { name: 'byv83y', num: 8 }, { name: 'bjzp4k', num: 4 }, { name: 'f3kbnm', num: 10 }];",
        "const bench2 = [{ friend: 'o8b', num: 8 }, { friend: 'ye', num: 2 }, { friend: '32i', num: 5 }, { friend: 'uz', num: 3 }, { friend: 'a5k', num: 4 }, { friend: 'uad', num: 7 }, { friend: '3w5', num: 10 }, { friend: 'vw', num: 10 }, { friend: 'ah', num: 4 }, { friend: 'qv', num: 7 }, { friend: 'ozv', num: 2 }, { friend: '9ri', num: 10 }, { friend: '7nu', num: 4 }, { friend: 'w3', num: 9 }, { friend: 'tgp', num: 8 }, { friend: 'ibs', num: 1 }, { friend: 'ss7', num: 6 }, { friend: 'g44', num: 9 }, { friend: 'tab', num: 9 }, { friend: 'zem', num: 10 }];"
      ],
      "tests": [
        "assert(typeof hashJoin === 'function', 'message: <code>hashJoin</code> is a function.');",
        "assert.deepEqual(hashJoin(hash1, hash2), res, 'message: <code>hashJoin([{ age: 27, name: \"Jonah\" }, { age: 18, name: \"Alan\" }, { age: 28, name: \"Glory\" }, { age: 18, name: \"Popeye\" }, { age: 28, name: \"Alan\" }], [{ character: \"Jonah\", nemesis: \"Whales\" }, { character: \"Jonah\", nemesis: \"Spiders\" }, { character: \"Alan\", nemesis: \"Ghosts\" }, { character:\"Alan\", nemesis: \"Zombies\" }, { character: \"Glory\", nemesis: \"Buffy\" }, { character: \"Bob\", nemesis: \"foo\" }])</code> should return <code>[{\"A_age\": 27,\"A_name\": \"Jonah\", \"B_character\": \"Jonah\", \"B_nemesis\": \"Whales\"}, {\"A_age\": 27,\"A_name\": \"Jonah\", \"B_character\": \"Jonah\", \"B_nemesis\": \"Spiders\"}, {\"A_age\": 18,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Ghosts\"}, {\"A_age\": 18,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Zombies\"}, {\"A_age\": 28,\"A_name\": \"Glory\", \"B_character\": \"Glory\", \"B_nemesis\": \"Buffy\"}, {\"A_age\": 28,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Ghosts\"}, {\"A_age\": 28,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Zombies\"}]</code>');"
      ],
      "id": "5956795bc9e2c415eb244de1"
    },
    {
      "title": "Heronian triangles",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "4",
      "benchmark": "heronianTriangle(10);",
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\"><a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Heron's formula\" title=\"wp: Heron's formula\">Hero's formula</a> for the area of a triangle given the length of its three sides  <big> <span class=\"rosetta__text--italic\">a</span>,</big>  <big><span class=\"rosetta__text--italic\">b</span>,</big>  and  <big><span class=\"rosetta__text--italic\">c</span></big>  is given by:</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--centered\"><big>$$A = \\sqrt{s(s-a)(s-b)(s-c)},$$</big></span></p><br/><p class=\"rosetta__paragraph\">where  <big><span class=\"rosetta__text--italic\">s</span></big>  is half the perimeter of the triangle; that is,</p><br/><p class=\"rosetta__paragraph\"><span class=\"rosetta__text--centered\"><big>$$s=\\frac{a+b+c}{2}.$$</big></span></p><br/>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--bold\"><a class=\"rosetta__link--wiki\" href=\"http://www.had2know.com/academics/heronian-triangles-generator-calculator.html\" title=\"link: http://www.had2know.com/academics/heronian-triangles-generator-calculator.html\">Heronian triangles</a></span> are triangles whose sides <span class=\"rosetta__text--italic\">and area</span> are all integers.</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"> An example is the triangle with sides  <span class=\"rosetta__text--bold\">3, 4, 5</span>  whose area is  <span class=\"rosetta__text--bold\">6</span>  (and whose perimeter is  <span class=\"rosetta__text--bold\">12</span>). </span></p><br/>",
        "<p class=\"rosetta__paragraph\">Note that any triangle whose sides are all an integer multiple of  <span class=\"rosetta__text--bold\">3, 4, 5</span>;  such as  <span class=\"rosetta__text--bold\">6, 8, 10,</span>  will also be a Heronian triangle.</p><br/><p class=\"rosetta__paragraph\">Define a <span class=\"rosetta__text--bold\">Primitive Heronian triangle</span> as a Heronian triangle where the greatest common divisor</p>",
        "<p class=\"rosetta__paragraph\">of all three sides is  <span class=\"rosetta__text--bold\">1</span>  (unity).</p><br/><p class=\"rosetta__paragraph\">This will exclude, for example, triangle  <span class=\"rosetta__text--bold\">6, 8, 10.</span></p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Implement a function based on Hero's formula that returns the first <code>n<sub>th</sub></code> ordered triangles in an array of arrays.</p>",
        "<br/></div>"
      ],
      "challengeSeed": [
        "// noprotect",
        "function heronianTriangle (n) {",
        "  // Good luck!",
        "",
        "  return [];",
        "}"
      ],
      "solutions": [
        "// noprotect\nfunction heronianTriangle (n) {\n  const list = [];\n  const result = [];\n\n  let j = 0;\n  for (let c = 1; c <= 200; c++) {\n    for (let b = 1; b <= c; b++) {\n      for (let a = 1; a <= b; a++) {\n        if (gcd(gcd(a, b), c) === 1 && isHeron(heronArea(a, b, c))) {\n          list[j++] = new Array(a, b, c, heronArea(a, b, c));\n        }\n      }\n    }\n  }\n\n  sort(list);\n\n  for (let i = 0; i < n; i++) {\n    result[i] = [list[i][0], list[i][1], list[i][2]];\n  }\n\n  return result;\n\n  function heronArea(a, b, c) {\n    const s = (a + b + c) / 2;\n    return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n  }\n\n  function isHeron(h) { return h % 1 === 0 && h > 0; }\n\n  function gcd(a, b) {\n    let leftover = 1;\n    let dividend = a > b ? a : b;\n    let divisor = a > b ? b : a;\n    while (leftover !== 0) {\n      leftover = dividend % divisor;\n      if (leftover > 0) {\n        dividend = divisor;\n        divisor = leftover;\n      }\n    }\n    return divisor;\n  }\n\n  function sort(arg) {\n    let swapped = true;\n    let temp = [];\n    while (swapped) {\n      swapped = false;\n      for (let i = 1; i < arg.length; i++) {\n        if (arg[i][4] < arg[i - 1][4] || arg[i][4] === arg[i - 1][4] && arg[i][3] < arg[i - 1][3]) {\n          temp = arg[i];\n          arg[i] = arg[i - 1];\n          arg[i - 1] = temp;\n          swapped = true;\n        }\n      }\n    }\n  }\n}\n"
      ],
      "tail": [
        "const testCases = [10, 15, 20, 25];",
        "",
        "const res = [",
        "  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17]],",
        "  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15]],",
        "  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53]],",
        "  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53], [19, 20, 37], [16, 17, 17], [17, 17, 30], [16, 25, 39], [13, 20, 21]]",
        "];"
      ],
      "tests": [
        "assert(typeof heronianTriangle === 'function', 'message: <code>heronianTriangle</code> is a function.');",
        "assert.deepEqual(heronianTriangle(testCases[0]), res[0], 'message: <code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17]]</code>');",
        "assert.deepEqual(heronianTriangle(testCases[1]), res[1], 'message: <code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15]],</code>');",
        "assert.deepEqual(heronianTriangle(testCases[2]), res[2], 'message: <code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53]],</code>');",
        "assert.deepEqual(heronianTriangle(testCases[3]), res[3], 'message: <code>heronianTriangle()</code> should return <code>[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53], [19, 20, 37],[16, 17, 17], [17, 17, 30], [16, 25, 39], [13, 20, 21]]</code>');"
      ],
      "id": "595b98f8b5a2245e243aa831"
    },
    {
      "title": "Hofstadter Figure-Figure sequences",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "2",
      "benchmark": [
        "Promise.resolve(() => ffr(100000))",
        "  .then(() => ffs(100000));"
      ],
      "description": [
        "<div class=\"rosetta\"><br/><p class=\"rosetta__paragraph\">These two sequences of positive integers are defined as:</p>",
        "<p class=\"rosetta__paragraph\"><span class=\"rosetta__text--indented\"><big>$$R(1)=1\\ ;\\ S(1)=2 \\\\R(n)=R(n-1)+S(n-1), \\quad n>1.$$</big></span></p><br/>",
        "<p class=\"rosetta__paragraph\">The sequence <big>$S(n)$</big> is further defined as the sequence of positive integers <span class=\"rosetta__text--bold\"><span class=\"rosetta__text--italic\">not</span></span> present in <big>$R(n)$</big>.</p><br/><p class=\"rosetta__paragraph\">Sequence <big>$R$</big> starts:</p>",
        "<p class=\"rosetta__paragraph\">1, 3, 7, 12, 18, ...</p>",
        "<p class=\"rosetta__paragraph\">Sequence <big>$S$</big> starts:</p>",
        "<p class=\"rosetta__paragraph\">2, 4, 5, 6, 8, ...</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<ol class=\"rosetta__ordered-list\"><li class=\"rosetta__list-item--ordered\">Create two functions named <span class=\"rosetta__text--bold\">ffr</span> and <span class=\"rosetta__text--bold\">ffs</span> that when given <span class=\"rosetta__text--bold\">n</span> return <span class=\"rosetta__text--bold\">R(n)</span> or <span class=\"rosetta__text--bold\">S(n)</span> respectively.<br>(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).</li>",
        "<li class=\"rosetta__list-item--ordered\">No maximum value for <span class=\"rosetta__text--bold\">n</span> should be assumed.</li>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">Sloane's <a class=\"rosetta__link--wiki\" href=\"http://oeis.org/A005228\" title=\"link: http://oeis.org/A005228\">A005228</a> and <a class=\"rosetta__link--wiki\" href=\"http://oeis.org/A030124\" title=\"link: http://oeis.org/A030124\">A030124</a>.</li>",
        "<li class=\"rosetta__list-item--unordered\"><a class=\"rosetta__link--wiki\" href=\"http://mathworld.wolfram.com/HofstadterFigure-FigureSequence.html\" title=\"link: http://mathworld.wolfram.com/HofstadterFigure-FigureSequence.html\">Wolfram MathWorld</a></li>",
        "<li class=\"rosetta__list-item--unordered\">Wikipedia: <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Figure-Figure_sequences\" title=\"wp: Hofstadter_sequence#Hofstadter_Figure-Figure_sequences\">Hofstadter Figure-Figure sequences</a>.</li></ul><br/></div>"
      ],
      "challengeSeed": [
        "// noprotect",
        "function ffr(n) {",
        "  return n;",
        "}",
        "",
        "function ffs(n) {",
        "  return n;",
        "}"
      ],
      "solutions": [
        "// noprotect\nconst R = [null, 1];\nconst S = [null, 2];\n\nfunction extendSequences (n) {\n  let current = Math.max(R[R.length - 1], S[S.length - 1]);\n  let i;\n  while (R.length <= n || S.length <= n) {\n    i = Math.min(R.length, S.length) - 1;\n    current += 1;\n    if (current === R[i] + S[i]) {\n      R.push(current);\n    } else {\n      S.push(current);\n    }\n  }\n}\n\nfunction ffr (n) {\n  extendSequences(n);\n  return R[n];\n}\n\nfunction ffs (n) {\n  extendSequences(n);\n  return S[n];\n}\n"
      ],
      "tail": [
        "const ffrParamRes = [[10, 69], [50, 1509], [100, 5764], [1000, 526334]];",
        "const ffsParamRes = [[10, 14], [50, 59], [100, 112], [1000, 1041]];",
        ""
      ],
      "tests": [
        "assert(typeof ffr === 'function', 'message: <code>ffr</code> is a function.');",
        "assert(typeof ffs === 'function', 'message: <code>ffs</code> is a function.');",
        "assert(Number.isInteger(ffr(1)), 'message: <code>ffr</code> should return integer.');",
        "assert(Number.isInteger(ffs(1)), 'message: <code>ffs</code> should return integer.');",
        "assert.equal(ffr(ffrParamRes[0][0]), ffrParamRes[0][1], 'message: <code>ffr()</code> should return <code>69</code>');",
        "assert.equal(ffr(ffrParamRes[1][0]), ffrParamRes[1][1], 'message: <code>ffr()</code> should return <code>1509</code>');",
        "assert.equal(ffr(ffrParamRes[2][0]), ffrParamRes[2][1], 'message: <code>ffr()</code> should return <code>5764</code>');",
        "assert.equal(ffr(ffrParamRes[3][0]), ffrParamRes[3][1], 'message: <code>ffr()</code> should return <code>526334</code>');",
        "assert.equal(ffs(ffsParamRes[0][0]), ffsParamRes[0][1], 'message: <code>ffs()</code> should return <code>14</code>');",
        "assert.equal(ffs(ffsParamRes[1][0]), ffsParamRes[1][1], 'message: <code>ffs()</code> should return <code>59</code>');",
        "assert.equal(ffs(ffsParamRes[2][0]), ffsParamRes[2][1], 'message: <code>ffs()</code> should return <code>112</code>');",
        "assert.equal(ffs(ffsParamRes[3][0]), ffsParamRes[3][1], 'message: <code>ffs()</code> should return <code>1041</code>');"
      ],
      "id": "59622f89e4e137560018a40e"
    },
    {
      "title": "Hofstadter Q sequence",
      "type": "rosetta-code",
      "categories": [
        ""
      ],
      "difficulty": "1",
      "benchmark": "hofstadterQ(10000);",
      "description": [
        "<div class=\"rosetta\"><p class=\"rosetta__paragraph\">The <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Q_sequence\" title=\"wp: Hofstadter_sequence#Hofstadter_Q_sequence\">Hofstadter Q sequence</a> is defined as:</p>",
        "<p class=\"rosetta__text--indented\">$Q(1)=Q(2)=1, \\\\ Q(n)=Q\\big(n-Q(n-1)\\big)+Q\\big(n-Q(n-2)), \\quad n>2.$</p><br/>",
        "<p class=\"rosetta__paragraph\">It is defined like the <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Fibonacci sequence\" title=\"Fibonacci sequence\">Fibonacci sequence</a>, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<li class=\"rosetta__list-item--unordered\">Implement the Hofstadter Q Sequence equation into JavaScript</li></ul><br/></div>"
      ],
      "challengeSeed": [
        "function hofstadterQ (n) {",
        "  // Good luck!",
        "  return n;",
        "}"
      ],
      "solutions": [
        "function hofstadterQ (n) {\n  const memo = [1, 1, 1];\n  const Q = function (i) {\n    let result = memo[i];\n    if (typeof result !== 'number') {\n      result = Q(i - Q(i - 1)) + Q(i - Q(i - 2));\n      memo[i] = result;\n    }\n    return result;\n  };\n  return Q(n);\n}\n"
      ],
      "tail": [
        "const testCase = [1000, 1500, 2000, 2500];",
        "const res = [502, 755, 1005, 1261];"
      ],
      "tests": [
        "assert(typeof hofstadterQ === 'function', 'message: <code>hofstadterQ</code> is a function.');",
        "assert(Number.isInteger(hofstadterQ(1000)), 'message: <code>hofstadterQ()</code> should return <code>integer</code>');",
        "assert.equal(hofstadterQ(testCase[0]), res[0], 'message: <code>hofstadterQ(1000)</code> should return <code>502</code>');",
        "assert.equal(hofstadterQ(testCase[1]), res[1], 'message: <code>hofstadterQ(1500)</code> should return <code>755</code>');",
        "assert.equal(hofstadterQ(testCase[2]), res[2], 'message: <code>hofstadterQ(2000)</code> should return <code>1005</code>');",
        "assert.equal(hofstadterQ(testCase[3]), res[3], 'message: <code>hofstadterQ(2500)</code> should return <code>1261</code>');"
      ],
      "id": "59637c4d89f6786115efd814"
    },
    {
      "title": "S-Expressions",
      "type": "rosetta-code",
      "categories": [
        "parsing",
        "s-expressions"
      ],
      "difficulty": "4",
      "benchmark": "parseSexpr('((data \"quoted data\" 123 4.5) (data (!@# (4.5) \"(more\" \"data)\")))');",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">",
        "<a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/S-Expression\" title=\"wp: S-Expression\">S-Expressions</a> are one convenient way to parse and store data.",
        "</p>",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">",
        "    Write a simple reader/parser for S-Expressions that handles quoted and unquoted strings, integers and floats.",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        "The function should read a single but nested S-Expression from a string and",
        "return it as a (nested) array.",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        "    Newlines and other whitespace may be ignored unless contained within a quoted string.",
        "</p>",
        "<p class=\"rosetta__paragraph\">“<tt>()</tt>”  inside quoted strings are not interpreted, but treated as part of the string.",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        "Handling escaped quotes inside a string is optional;  thus “<tt>(foo\"bar)</tt>” maybe treated as a string “<tt>foo\"bar</tt>”, or as an error.",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        "For this, the reader need not recognize “<tt>\\</tt>” for escaping, but should, in addition, recognize numbers if the language has appropriate datatypes.",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        "Note that with the exception of “<tt>()\"</tt>” (“<tt>\\</tt>” if escaping is supported) and whitespace there are no special characters. Anything else is allowed without quotes.",
        "</p>",
        "<p class=\"rosetta__paragraph\">The reader should be able to read the following input</p>",
        "<p class=\"rosetta__paragraph\">",
        "<pre>",
        "    ((data \"quoted data\" 123 4.5)",
        "    (data (!@# (4.5) \"(more\" \"data)\")))",
        "</pre>",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        "and turn it into a native datastructure. (see the",
        "<a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/#Pike\" title=\"#Pike\">Pike</a>, ",
        "<a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/#Python\" title=\"#Python\">Python</a> and",
        "<a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/#Ruby\" title=\"#Ruby\">Ruby</a> implementations",
        "for examples of native data structures.)",
        "</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function parseSexpr(str) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function parseSexpr(str) {\n  const t = str.match(/\\s*(\"[^\"]*\"|\\(|\\)|\"|[^\\s()\"]+)/g);\n  for (var o, c = 0, i = t.length - 1; i >= 0; i--) {\n    var n,\n      ti = t[i].trim();\n    if (ti == '\"') return;\n    else if (ti == '(') t[i] = '[', c += 1;\n    else if (ti == ')') t[i] = ']', c -= 1;\n    else if ((n = +ti) == ti) t[i] = n;\n    else t[i] = `'${ti.replace('\\'', '\\\\\\'')}'`;\n    if (i > 0 && ti != ']' && t[i - 1].trim() != '(') t.splice(i, 0, ',');\n    if (!c) if (!o) o = true; else return;\n  }\n  return c ? undefined : eval(t.join(''));\n}\n"
      ],
      "tail": [
        "const simpleSExpr = '(data1 data2 data3)';",
        "const simpleSolution = ['data1', 'data2', 'data3'];",
        "",
        "const basicSExpr = '((data \"quoted data\" 123 4.5) (data (!@# (4.5) \"(more\" \"data)\")))';",
        "const basicSolution = [[\"data\",\"\\\"quoted data\\\"\",123,4.5],[\"data\",[\"!@#\",[4.5],\"\\\"(more\\\"\",\"\\\"data)\\\"\"]]];"
      ],
      "tests": [
        "assert(typeof parseSexpr === 'function', 'message: <code>parseSexpr</code> is a function.');",
        "assert.deepEqual(parseSexpr(simpleSExpr), simpleSolution, \"message: <code>parseSexpr('(data1 data2 data3)')</code> should return ['data1', 'data2', 'data3']\");",
        "assert.deepEqual(parseSexpr(basicSExpr), basicSolution, \"message: <code>parseSexpr('(data1 data2 data3)')</code> should return an array with 3 elements\");"
      ],
      "id": "59667989bf71cf555dd5d2ff"
    },
    {
      "title": "SEDOLs",
      "type": "rosetta-code",
      "categories": "checksum",
      "null": [],
      "difficulty": "4",
      "benchmark": [],
      "description": [
        "<div class=\"rosetta\">",
        "  <br/>",
        "",
        "  <dl class=\"rosetta__description-list\">",
        "    <dt class=\"rosetta__description-title\">Task:</dt>",
        "  </dl>",
        "",
        "  <p class=\"rosetta__paragraph\">",
        "    For each number list of <span class=\"rosetta__text--bold\">6</span>-digit ",
        "    <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/SEDOL\" title=\"wp: SEDOL\">SEDOL</a>s,",
        "    calculate and append the checksum digit.",
        "  </p>",
        "  <br/>",
        "  <p class=\"rosetta__paragraph\">",
        "    That is, given the input string on the left, your function should return the",
        "    corresponding string on the right:",
        "  </p>",
        "",
        "  <div class=\"rosetta__pre-wrap\">",
        "    <pre class=\"rosetta__pre\">",
        "     710889 => 7108899",
        "     B0YBKJ => B0YBKJ7",
        "     406566 => 4065663",
        "     B0YBLH => B0YBLH2",
        "     228276 => 2282765",
        "     B0YBKL => B0YBKL9",
        "     557910 => 5579107",
        "     B0YBKR => B0YBKR5",
        "     585284 => 5852842",
        "     B0YBKT => B0YBKT7",
        "     B00030 => B000300",
        "    </pre>",
        "  </div>",
        "",
        "  <p class=\"rosetta__paragraph\">",
        "    Check also that each input is correctly formed, especially",
        "    with respect to valid characters allowed in a SEDOL string. Your function",
        "    should return <code>null</code> on invalid input.",
        "  </p>",
        "",
        "</div>",
        "",
        ""
      ],
      "challengeSeed": [
        "function sedol (input) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function sedol(input) {\n  const checkDigit = sedolCheckDigit(input);\n  if (checkDigit !== null) {\n    return input + checkDigit;\n  }\n  return null;\n}\n\nconst weight = [1, 3, 1, 7, 3, 9, 1];\nfunction sedolCheckDigit(char6) {\n  if (char6.search(/^[0-9BCDFGHJKLMNPQRSTVWXYZ]{6}$/) === -1) {\n    return null;\n  }\n\n  let sum = 0;\n  for (let i = 0; i < char6.length; i++) {\n    sum += weight[i] * parseInt(char6.charAt(i), 36);\n  }\n  const check = (10 - (sum % 10)) % 10;\n  return check.toString();\n}\n"
      ],
      "tail": [
        "const input = [",
        "  '710889', 'B0YBKJ', '406566', 'B0YBLH', '228276',",
        "  'B0YBKL', '557910', 'B0YBKR', '585284', 'B0YBKT',",
        "  'BOATER', '12345', '123456', '1234567', 'ABBAAC',",
        "  '767642', 'B33FAC', 'H3FH3F', 'C0M3D1', 'GOOGL3',",
        "  'APPPL3'",
        "];",
        "",
        "const expected = [",
        "  '7108899', 'B0YBKJ7', '4065663', 'B0YBLH2', '2282765',",
        "  'B0YBKL9', '5579107', 'B0YBKR5', '5852842', 'B0YBKT7',",
        "  null, null, '1234563', null, null, '7676426',",
        "  null, 'H3FH3F6', 'C0M3D17', null, null",
        "];",
        "",
        "const inputLen = input.length;",
        "const randIndex = Math.floor(Math.random(new Date().getTime()) * inputLen);",
        "const inputVal = input[randIndex];",
        "const expVal = expected[randIndex];",
        "const randMsg = `message: <code>sedol('${inputVal}')</code> should return '${expVal}'.`;"
      ],
      "tests": [
        "assert(typeof sedol === 'function', 'message: <code>sedol</code> is a function.');",
        "assert(sedol('a') === null, \"message: <code>sedol('a')</code> should return null.\");",
        "assert(sedol('710889') === '7108899', \"message: <code>sedol('710889')</code> should return '7108899'.\");",
        "assert(sedol('BOATER') === null, \"message: <code>sedol('BOATER')</code> should return null.\");",
        "assert(sedol('228276') === '2282765', \"message: <code>sedol('228276')</code> should return '2282765'.\");",
        "assert(sedol(inputVal) === expVal, randMsg);"
      ],
      "id": "59d9c6bc214c613ba73ff012"
    },
    {
      "title": "Sailors, coconuts and a monkey problem",
      "type": "rosetta-code",
      "categories": "Puzzles",
      "difficulty": "?",
      "benchmark": [],
      "description": [
        "",
        " <div class=\"rosetta\">",
        "",
        " <p class=\"rosetta__paragraph\">",
        "   Five sailors are shipwrecked on an island and",
        "   collect a large pile of coconuts during the day.",
        " </p>",
        "",
        " <p class=\"rosetta__paragraph\">That night the first sailor wakes up and decides",
        "   to take his first share early  so tries to divide the pile of coconuts equally",
        "   into five piles but finds that there is one coconut left over, so he tosses it",
        "   to a monkey and then hides \"his\" one of the five equally sized piles of",
        "   coconuts and pushes the other four piles together to form a single visible pile",
        "   of coconuts again and goes to bed.",
        " </p>",
        "",
        " <p class=\"rosetta__paragraph\">",
        "   To cut a long story short, each of the sailors in",
        "   turn gets up once during the night and performs the same actions of dividing",
        "   the coconut pile into five, finding that one coconut is left over and giving",
        "   that single remainder coconut to the monkey.",
        " </p>",
        "",
        " <p class=\"rosetta__paragraph\">",
        "   In the morning (after the surreptitious and",
        "   separate action of each of the five sailors during the night), the remaining",
        "   coconuts are divided into five equal piles for each of the sailors, whereupon",
        "   it is found that the pile of coconuts divides equally amongst the sailors with",
        "   no remainder. (Nothing for the monkey in the morning.)",
        " </p>",
        "",
        " <br/>",
        "",
        " <dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">The task:</dt></dl>",
        "",
        " <ol class=\"rosetta__ordered-list\">",
        "",
        "   <li class=\"rosetta__list-item--ordered\">",
        "     Create a function that returns the",
        "     the minimum possible size",
        "     of the initial pile of coconuts collected during the day for N",
        "     sailors.",
        "   </li>",
        "",
        " </ol>",
        "",
        " <dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Note:</dt></dl>",
        " <ul class=\"rosetta__unordered-list\">",
        "   <li class=\"rosetta__list-item--unordered\">",
        "     Of course the tale is told in a",
        "     world where the collection of any amount of coconuts in a day and multiple",
        "     divisions of the pile, etc can occur in time fitting the story line, so as",
        "     not to affect the mathematics.",
        "   </li>",
        " </ul>",
        "",
        " <br/>",
        "",
        " <dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">C.f:</dt></dl>",
        "",
        " <ul class=\"rosetta__unordered-list\">",
        "",
        "   <li class=\"rosetta__list-item--unordered\"><a class=\"rosetta__link--wiki\"",
        "       href=\"https://www.youtube.com/watch?v=U9qU20VmvaU\" title=\"link: https://www.youtube.com/watch?v=U9qU20VmvaU\">",
        "       Monkeys and Coconuts - Numberphile</a> (Video) Analytical solution.",
        "   </li>",
        "",
        "   <li class=\"rosetta__list-item--unordered\">",
        "     <a class=\"rosetta__link--wiki\"",
        "       href=\"http://oeis.org/A002021\" title=\"link: http://oeis.org/A002021\">A002021 Pile of coconuts problem</a> The On-Line",
        "     Encyclopedia of Integer Sequences. (Although some of its references may use",
        "     the alternate form of the tale).",
        "   </li>",
        "",
        " </ul>",
        "",
        " </div>",
        "",
        ""
      ],
      "challengeSeed": [
        "// noprotect",
        "function splitCoconuts(intSailors) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "// noprotect\nfunction splitCoconuts(intSailors) {\n  let intNuts = intSailors;\n  let result = splitCoconutsHelper(intNuts, intSailors);\n  while (!result) {\n    intNuts += 1;\n    result = splitCoconutsHelper(intNuts, intSailors);\n  }\n\n  return intNuts;\n}\n\nfunction splitCoconutsHelper(intNuts, intSailors, intDepth) {\n  const nDepth = intDepth !== undefined ? intDepth : intSailors;\n  const portion = Math.floor(intNuts / intSailors);\n  const remain = intNuts % intSailors;\n\n  if (portion <= 0 || remain !== (nDepth ? 1 : 0)) {\n    return null;\n  }\n\n  if (nDepth) {\n    return splitCoconutsHelper(\n      intNuts - portion - remain, intSailors, nDepth - 1\n    );\n  }\n\n  return intNuts;\n}\n"
      ],
      "tail": [],
      "tests": [
        "assert(typeof splitCoconuts === 'function', 'message: <code>splitCoconuts</code> is a function.');",
        "assert(splitCoconuts(5) === 3121, 'message: <code>splitCoconuts(5)</code> should return 3121.');",
        "assert(splitCoconuts(6) === 233275, 'message: <code>splitCoconuts(6)</code> should return 233275.');",
        "assert(splitCoconuts(7) === 823537, 'message: <code>splitCoconuts(7)</code> should return 823537.');"
      ],
      "id": "59da22823d04c95919d46269"
    },
    {
      "title": "Taxicab numbers",
      "type": "rosetta-code",
      "categories": [],
      "difficulty": "5",
      "benchmark": "//replaceWithActualFunctionHere;",
      "description": [
        "<div class=\"rosetta\">",
        "A &nbsp; <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Hardy–Ramanujan number\" title=\"wp: Hardy–Ramanujan number\">taxicab number</a>",
        "&nbsp; (the definition that is being used here) &nbsp; is a positive integer that can be expressed as the sum of two positive cubes in more than one way.",
        "<br>",
        "The first taxicab number is &nbsp; <span class=\"rosetta__text--bold\">1729</span>, &nbsp; which is:",
        "<span class=\"rosetta__text--indented\">1<sup>3</sup> &nbsp; + &nbsp; 12<sup>3</sup> &nbsp; &nbsp; &nbsp; and</span>",
        "<span class=\"rosetta__text--indented\">9<sup>3</sup> &nbsp; + &nbsp; 10<sup>3</sup>.</span>",
        "<br>",
        "Taxicab numbers are also known as:",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li><span class=\"rosetta__text--indented\">* &nbsp; taxi numbers</span></li>",
        "  <li><span class=\"rosetta__text--indented\">* &nbsp; taxi-cab numbers</span></li>",
        "  <li><span class=\"rosetta__text--indented\">* &nbsp; taxi cab numbers</span></li>",
        "  <li><span class=\"rosetta__text--indented\">* &nbsp; Hardy-Ramanujan numbers</span></li>",
        "</ul>",
        "<br>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">Write a function that returns the lowest N taxicab numbers.</li>",
        "<li class=\"rosetta__list-item--unordered\">For each of the taxicab numbers, show the number as well as it's constituent cubes.</li>",
        "</ul>",
        "<br>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">See also:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">[http://oeis.org/A001235 A001235 taxicab numbers] on The On-Line Encyclopedia of Integer Sequences.</li>",
        "  <li class=\"rosetta__list-item--unordered\"><a href=\"http://mathworld.wolfram.com/Hardy-RamanujanNumber.html\">Hardy-Ramanujan Number</a> on MathWorld.</li>",
        "  <li class=\"rosetta__list-item--unordered\"><a href=\"http://mathworld.wolfram.com/TaxicabNumber.html\">taxicab number</a> on MathWorld.</li>",
        "  <li class=\"rosetta__list-item--unordered\"><a href=\"https://en.wikipedia.org/wiki/Taxicab_number\">taxicab number</a> on Wikipedia.</li>",
        "</ul>",
        "</div>"
      ],
      "challengeSeed": [
        "function taxicabNumbers (n) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function taxicabNumbers(nNumbers) {\n  const cubeN = [];\n  const s3s = {};\n\n  const e = 100;\n  for (let n = 1; n < e; n += 1) {\n    cubeN[n] = n * n * n;\n  }\n\n  for (let a = 1; a < e - 1; a += 1) {\n    const a3 = cubeN[a];\n    for (let b = a; b < e; b += 1) {\n      const b3 = cubeN[b];\n      const s3 = a3 + b3;\n\n      let abs = s3s[s3];\n      if (!abs) {\n        s3s[s3] = abs = [];\n      }\n      abs.push([a, b]);\n    }\n  }\n\n  let i = 0;\n  const res = [];\n  Object.keys(s3s).forEach(s3 => {\n    const abs = s3s[s3];\n    if (abs.length >= 2) { // No two cube pairs found\n      i += 1;\n      if (i <= nNumbers) {\n        res.push(s3);\n      }\n    }\n  });\n  return res.map(item => parseInt(item, 10));\n}\n"
      ],
      "tail": [
        "const res4 = [1729, 4104, 13832, 20683];",
        "const res25 = [",
        "  1729, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728, 110656,",
        "  110808, 134379, 149389, 165464, 171288, 195841, 216027, 216125, 262656, 314496, 320264, 327763,",
        "  373464, 402597",
        "];",
        "",
        "const res39From20To29 = [314496, 320264, 327763, 373464, 402597, 439101, 443889, 513000, 513856];"
      ],
      "tests": [
        "assert(typeof taxicabNumbers === 'function', 'message: <code>taxicabNumbers </code> is a function.');",
        "assert(typeof taxicabNumbers(2) === 'object', 'message: <code>taxicabNumbers </code> should return an array.');",
        "assert(typeof taxicabNumbers(100)[0] === 'number', 'message: <code>taxicabNumbers </code> should return an array of numbers.');",
        "assert.deepEqual(taxicabNumbers(4), res4, 'message: <code>taxicabNumbers(4) </code> must return [1729, 4104, 13832, 20683].');",
        "assert.deepEqual(taxicabNumbers(25), res25, 'message: taxicabNumbers(25) should return [1729, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728, 110656, 110808, 134379, 149389, 165464, 171288, 195841, 216027, 216125, 262656, 314496, 320264, 327763, 373464, 402597]');",
        "assert.deepEqual(taxicabNumbers(39).slice(20, 29), res39From20To29, 'message: taxicabNumbers(39) resulting numbers from 20 - 29 should be [314496,320264,327763,373464,402597,439101,443889,513000,513856].');"
      ],
      "id": "594ecc0d9a8cf816e3340187"
    },
    {
      "title": "Tokenize a string with escaping",
      "type": "rosetta-code",
      "categories": [
        "strings",
        "text processing"
      ],
      "difficulty": "4",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">",
        "Write a function or program that can split a string at each non-escaped occurrence of a separator character.",
        "</p>",
        "<br/>",
        "<p class=\"rosetta__paragraph\">",
        "It should accept three input parameters:",
        "</p>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">The <b>string</b></li>",
        "  <li class=\"rosetta__list-item--unordered\">The <b>separator character</b></li>",
        "  <li class=\"rosetta__list-item--unordered\">The <b>escape character</b></li>",
        "</ul>",
        "<br>",
        "<p class=\"rosetta__paragraph\">It should output a list of strings.</p>",
        "<br/>",
        "<p class=\"rosetta__paragraph\">Rules for splitting:</p>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">The fields that were separated by the separators, become the elements of the output list.</li>",
        "  <li class=\"rosetta__list-item--unordered\">Empty fields should be preserved, even at the start and end.</li>",
        "</ul>",
        "<br>",
        "<p class=\"rosetta__paragraph\">Rules for escaping:</p>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">\"Escaped\" means preceded by an occurrence of the escape character that is not already escaped itself.</li>",
        "  <li class=\"rosetta__list-item--unordered\">When the escape character precedes a character that has no special meaning, it still counts as an escape (but does not do anything special).</li>",
        "  <li class=\"rosetta__list-item--unordered\">Each occurrences of the escape character that was used to escape something, should <span class=\"rosetta__text--bold\">not</span> become part of the output.</li>",
        "</ul>",
        "<br/>",
        "<p class=\"rosetta__paragraph\">Demonstrate that your function satisfies the following test-case:",
        "  Given string <pre>one^|uno||three^^^^|four^^^|^cuatro|</pre> and using",
        "  <pre>|</pre> as a separator and <pre>^</pre> as escape character, your",
        "  function should output the following array:",
        "</p>",
        "<br>",
        "<div class=\"rosetta__pre-wrap\">",
        "  <pre class=\"rosetta__pre\">",
        "  ['one|uno', '', 'three^^', 'four^|quatro', '']",
        "  </pre>",
        "</div>",
        "</div>"
      ],
      "challengeSeed": [
        "function tokenize(str, esc, sep) {",
        "  return true;",
        "}"
      ],
      "solutions": [
        "// tokenize :: String -> Character -> Character -> [String]\nfunction tokenize(str, charDelim, charEsc) {\n  const dctParse = str.split('')\n    .reduce((a, x) => {\n      const blnEsc = a.esc;\n      const blnBreak = !blnEsc && x === charDelim;\n      const blnEscChar = !blnEsc && x === charEsc;\n\n      return {\n        esc: blnEscChar,\n        token: blnBreak ? '' : (\n          a.token + (blnEscChar ? '' : x)\n        ),\n        list: a.list.concat(blnBreak ? a.token : [])\n      };\n    }, {\n      esc: false,\n      token: '',\n      list: []\n    });\n\n  return dctParse.list.concat(\n    dctParse.token\n  );\n}\n"
      ],
      "tail": [
        "const testStr1 = 'one^|uno||three^^^^|four^^^|^cuatro|';",
        "const res1 = ['one|uno', '', 'three^^', 'four^|cuatro', ''];",
        "",
        "// TODO add more tests",
        "const testStr2 = 'a@&bcd&ef&&@@hi';",
        "const res2 = ['a&bcd', 'ef', '', '@hi'];"
      ],
      "tests": [
        "assert(typeof tokenize === 'function', 'message: <code>tokenize</code> is a function.');",
        "assert(typeof tokenize('a', 'b', 'c') === 'object', 'message: <code>tokenize</code> should return an array.');",
        "assert.deepEqual(tokenize(testStr1, '|', '^'), res1, \"message: <code>tokenize('one^|uno||three^^^^|four^^^|^cuatro|', '|', '^') </code> should return ['one|uno', '', 'three^^', 'four^|cuatro', '']\");",
        "assert.deepEqual(tokenize(testStr2, '&', '@'), res2, \"message: <code>tokenize('a@&bcd&ef&&@@hi', '&', '@')</code> should return ['a&bcd', 'ef', '', '@hi']\");"
      ],
      "id": "594faaab4e2a8626833e9c3d"
    },
    {
      "title": "Top rank per group",
      "type": "rosetta-code",
      "categories": "ranking",
      "difficulty": "5",
      "description": [
        "<div class=\"rosetta\">",
        "<br/><dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">Find the top <span class=\"rosetta__text--italic\">N</span> ranked data in each group, where <span class=\"rosetta__text--italic\">N</span>  is provided as a parameter. Name of the rank and the group are also provided as parameter.</p><br/>",
        "Given the following data:",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "[",
        "  { name: 'Tyler Bennett', id: 'E10297', salary: 32000, dept: 'D101' },",
        "  { name: 'John Rappl', id: 'E21437', salary: 47000, dept: 'D050' },",
        "  { name: 'George Woltman', id: 'E00127', salary: 53500, dept: 'D101' },",
        "  { name: 'Adam Smith', id: 'E63535', salary: 18000, dept: 'D202' },",
        "  { name: 'Claire Buckman', id: 'E39876', salary: 27800, dept: 'D202' },",
        "  { name: 'David McClellan', id: 'E04242', salary: 41500, dept: 'D101' },",
        "  { name: 'Rich Holcomb', id: 'E01234', salary: 49500, dept: 'D202' },",
        "  { name: 'Nathan Adams', id: 'E41298', salary: 21900, dept: 'D050' },",
        "  { name: 'Richard Potter', id: 'E43128', salary: 15900, dept: 'D101' },",
        "  { name: 'David Motsinger', id: 'E27002', salary: 19250, dept: 'D202' },",
        "  { name: 'Tim Sampair', id: 'E03033', salary: 27000, dept: 'D101' },",
        "  { name: 'Kim Arlich', id: 'E10001', salary: 57000, dept: 'D190' },",
        "  { name: 'Timothy Grove', id: 'E16398', salary: 29900, dept: 'D190' }",
        "];",
        "</pre></div>",
        "one could rank top 10 employees in each department by calling",
        "<code>topRankPerGroup(10, data, 'dept', 'salary')</code>",
        "<br>",
        "Given the following data:",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "[",
        "  { name: 'Friday 13th', genre: 'horror', rating: 9.9 },",
        "  { name: \"Nightmare on Elm's Street\", genre: 'horror', rating: 5.7 },",
        "  { name: 'Titanic', genre: 'drama', rating: 7.3 },",
        "  { name: 'Maze Runner', genre: 'scifi', rating: 7.1 },",
        "  { name: 'Blade runner', genre: 'scifi', rating: 8.9 }",
        "];",
        "</pre></div>",
        "one could rank the top-rated movie in each genre by calling",
        "<code>topRankPerGroup(1, data, 'genre', 'rating')</code>",
        "</div>"
      ],
      "challengeSeed": [
        "function topRankPerGroup(n, data, groupName, rankName) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "\nconst collectDept = function (arrOfObj, groupName) {\n  const collect = arrOfObj.reduce((rtnObj, obj) => {\n    if (rtnObj[obj[groupName]] === undefined) {\n      rtnObj[obj[groupName]] = [];\n    }\n    rtnObj[obj[groupName]].push(obj);\n    return rtnObj;\n  }, {} // initial value to reduce\n  );\n\n  return Object.keys(collect).sort().map(key => collect[key]);\n};\n\nconst sortRank = function (arrOfRankArrs, rankName) {\n  return arrOfRankArrs.map(item => item.sort((a, b) => {\n    if (a[rankName] > b[rankName]) { return -1; }\n    if (a[rankName] < b[rankName]) { return 1; }\n    return 0;\n  }));\n};\n\nfunction topRankPerGroup(n, data, groupName, rankName) {\n  if (n < 0) { return; }\n  return sortRank(collectDept(data, groupName),\n    rankName).map(list => list.slice(0, n));\n}\n"
      ],
      "tail": [
        "const testData1 = [",
        "  { name: 'Tyler Bennett', id: 'E10297', salary: 32000, dept: 'D101' },",
        "  { name: 'John Rappl', id: 'E21437', salary: 47000, dept: 'D050' },",
        "  { name: 'George Woltman', id: 'E00127', salary: 53500, dept: 'D101' },",
        "  { name: 'Adam Smith', id: 'E63535', salary: 18000, dept: 'D202' },",
        "  { name: 'Claire Buckman', id: 'E39876', salary: 27800, dept: 'D202' },",
        "  { name: 'David McClellan', id: 'E04242', salary: 41500, dept: 'D101' },",
        "  { name: 'Rich Holcomb', id: 'E01234', salary: 49500, dept: 'D202' },",
        "  { name: 'Nathan Adams', id: 'E41298', salary: 21900, dept: 'D050' },",
        "  { name: 'Richard Potter', id: 'E43128', salary: 15900, dept: 'D101' },",
        "  { name: 'David Motsinger', id: 'E27002', salary: 19250, dept: 'D202' },",
        "  { name: 'Tim Sampair', id: 'E03033', salary: 27000, dept: 'D101' },",
        "  { name: 'Kim Arlich', id: 'E10001', salary: 57000, dept: 'D190' },",
        "  { name: 'Timothy Grove', id: 'E16398', salary: 29900, dept: 'D190' }",
        "];",
        "",
        "const res1 = topRankPerGroup(10, testData1, 'dept', 'salary');",
        "",
        "const testData2 = [",
        "  { name: 'Friday 13th', genre: 'horror', rating: 9.9 },",
        "  { name: \"Nightmare on Elm's Street\", genre: 'horror', rating: 5.7 },",
        "  { name: 'Titanic', genre: 'drama', rating: 7.3 },",
        "  { name: 'Maze Runner', genre: 'scifi', rating: 7.1 },",
        "  { name: 'Blade runner', genre: 'scifi', rating: 8.9 }",
        "];",
        "",
        "const res2 = topRankPerGroup(1, testData2, 'genre', 'rating');",
        "const res3 = topRankPerGroup(2, testData2, 'genre', 'rating');",
        "",
        "//console.log(JSON.stringify(topRankPerGroup(10, testData1)));"
      ],
      "tests": [
        "assert(typeof topRankPerGroup === 'function', 'message: <code>topRankPerGroup</code> is a function.');",
        "assert(typeof topRankPerGroup(-1, []) === 'undefined', 'message: <code>topRankPerGroup</code> returns undefined on negative n values.');",
        "assert.equal(res1[0][0].dept, 'D050', 'message: First department must be D050');",
        "assert.equal(res1[0][1].salary, 21900, 'message: First department must be D050');",
        "assert.equal(res1[3][3].dept, 'D202', 'message: The last department must be D202');",
        "assert.equal(res2[2].length, 1, 'message: <code>topRankPerGroup(1, ...)</code> must return only top ranking result per group.');",
        "assert.equal(res3[2][1].name, 'Maze Runner', 'message: <code>topRankPerGroup(1, ...)</code> must return only top ranking result per group.');"
      ],
      "id": "595011cba5a81735713873bd"
    },
    {
      "title": "Topological sort",
      "type": "rosetta-code",
      "categories": [
        "sort",
        "dependencies"
      ],
      "difficulty": "7",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">",
        "Given a mapping between items, and items they depend on, a ",
        "<a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Topological sorting\" title=\"wp: Topological sorting\">topological sort</a> orders ",
        "items so that no item precedes an item it depends upon.",
        "</p>",
        "<br/>",
        "<p class=\"rosetta__paragraph\">",
        "The compiling of a library in the ",
        "<a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/VHDL\" title=\"wp: VHDL\">VHDL</a> language",
        "has the constraint that a library must be compiled after any library it depends on.",
        "</p>",
        "<br/>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<p class=\"rosetta__paragraph\">",
        "Write a function that will return a valid compile order of VHDL libraries from their dependencies.",
        "</p>",
        "<br/>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">Assume library names are single words. </li>",
        "  <li class=\"rosetta__list-item--unordered\">Items mentioned as only dependents have no dependents of their own, but their order of compiling must be given.</li>",
        "  <li class=\"rosetta__list-item--unordered\">Any self dependencies should be ignored. </li>",
        "  <li class=\"rosetta__list-item--unordered\">Any un-orderable dependencies should be ignored.</li>",
        "</ul>",
        "<br>",
        "<p class=\"rosetta__paragraph\">Use the following data as an example:</p>",
        "<div class=\"rosetta__pre-wrap\"><pre class=\"rosetta__pre\">",
        "LIBRARY          LIBRARY DEPENDENCIES",
        "=======          ====================",
        "des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee",
        "dw01             ieee dw01 dware gtech",
        "dw02             ieee dw02 dware",
        "dw03             std synopsys dware dw03 dw02 dw01 ieee gtech",
        "dw04             dw04 ieee dw01 dware gtech",
        "dw05             dw05 ieee dware",
        "dw06             dw06 ieee dware",
        "dw07             ieee dware",
        "dware            ieee dware",
        "gtech            ieee gtech",
        "ramlib           std ieee",
        "std_cell_lib     ieee std_cell_lib",
        "synopsys",
        "</pre></div><br/><br>",
        "<p class=\"rosetta__paragraph\">",
        "<small>Note: the above data would be un-orderable if, for example, <code>dw04</code> is added to the list of dependencies of <code>dw01</code>.</small>",
        "</p>",
        "<br/>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">C.f.:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\"> ",
        "    <a class=\"rosetta__link--rosetta\" href=\"http://rosettacode.org/wiki/Topological sort/Extracted top item\" title=\"Topological sort/Extracted top item\">Topological sort/Extracted top item</a>.",
        "  </li>",
        "</ul>",
        "<br>",
        "<p class=\"rosetta__paragraph\">There are two popular algorithms for topological sorting:</p>",
        "<p class=\"rosetta__paragraph\">",
        "  Kahn's 1962 topological sort, and depth-first search:",
        "  <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Topological sorting\" title=\"wp: Topological sorting\">topological sort</a>",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        "  Jason Sachs:",
        "  <a class=\"rosetta__link--wiki\" href=\"http://www.embeddedrelated.com/showarticle/799.php\" title=\"link: http://www.embeddedrelated.com/showarticle/799.php\">",
        "  \"Ten little algorithms, part 4: topological sort\"",
        "  </a>.",
        "</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function topologicalSort(libs) {",
        "  // Good luck!",
        "  return true;",
        "}"
      ],
      "solutions": [
        "function topologicalSort(libs) {\n  // A map of the input data, with the keys as the packages, and the values as\n  // and array of packages on which it depends.\n  const D = libs\n    .split('\\n')\n    .map(e => e.split(' ').filter(ep => ep !== ''))\n    .reduce((p, c) =>\n      p.set(c[0], c.filter((e, i) => (i > 0 && e !== c[0] ? e : null))), new Map());\n  [].concat(...D.values()).forEach(e => {\n    D.set(e, D.get(e) || []);\n  });\n\n  // The above map rotated so that it represents a DAG of the form\n  // Map {\n  //    A => [ A, B, C],\n  //    B => [C],\n  //    C => []\n  // }\n  // where each key represents a node, and the array contains the edges.\n  const G = [...D.keys()].reduce((p, c) =>\n    p.set(\n      c,\n      [...D.keys()].filter(e => D.get(e).includes(c))),\n    new Map()\n  );\n\n  // An array of leaf nodes; nodes with 0 in degrees.\n  const Q = [...D.keys()].filter(e => D.get(e).length === 0);\n\n  // The result array.\n  const S = [];\n  while (Q.length) {\n    const u = Q.pop();\n    S.push(u);\n    G.get(u).forEach(v => {\n      D.set(v, D.get(v).filter(e => e !== u));\n      if (D.get(v).length === 0) {\n        Q.push(v);\n      }\n    });\n  }\n\n  return S;\n}\n"
      ],
      "tail": [
        "const libsSimple =",
        "  `aaa bbb",
        "  bbb`;",
        "",
        "const libsVHDL =",
        "  `des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee",
        "  dw01             ieee dw01 dware gtech",
        "  dw02             ieee dw02 dware",
        "  dw03             std synopsys dware dw03 dw02 dw01 ieee gtech",
        "  dw04             dw04 ieee dw01 dware gtech",
        "  dw05             dw05 ieee dware",
        "  dw06             dw06 ieee dware",
        "  dw07             ieee dware",
        "  dware            ieee dware",
        "  gtech            ieee gtech",
        "  ramlib           std ieee",
        "  std_cell_lib     ieee std_cell_lib",
        "  synopsys`;",
        "",
        "const solutionVHDL = [",
        "  'ieee', 'std_cell_lib', 'gtech', 'dware', 'dw07', 'dw06',",
        "  'dw05', 'dw02', 'dw01', 'dw04', 'std', 'ramlib', 'synopsys',",
        "  'dw03', 'des_system_lib'",
        "];",
        "",
        "const libsCustom =",
        "  `a b c d",
        "  b c d",
        "  d c",
        "  c base",
        "  base`;",
        "const solutionCustom = ['base', 'c', 'd', 'b', 'a'];",
        "",
        "const libsUnorderable =",
        "  `TestLib Base MainLib",
        "  MainLib TestLib",
        "  Base`;",
        "",
        "const solutionUnorderable = ['Base'];"
      ],
      "tests": [
        "assert(typeof topologicalSort === 'function', 'message: <code>topologicalSort</code> is a function.');",
        "assert.deepEqual(topologicalSort(libsSimple), ['bbb', 'aaa'], 'message: <code>topologicalSort</code> must return correct library order..');",
        "assert.deepEqual(topologicalSort(libsVHDL), solutionVHDL, 'message: <code>topologicalSort</code> must return correct library order..');",
        "assert.deepEqual(topologicalSort(libsCustom), solutionCustom, 'message: <code>topologicalSort</code> must return correct library order..');",
        "assert.deepEqual(topologicalSort(libsUnorderable), solutionUnorderable, 'message: <code>topologicalSort</code> must ignore unorderable dependencies..');"
      ],
      "id": "594fa2746886f41f7d8bf225"
    },
    {
      "title": "Towers of Hanoi",
      "type": "rosetta-code",
      "categories": [
        "Recursion",
        "Games"
      ],
      "difficulty": "3",
      "benchmark": "// replaceWithActualFunctionHere;",
      "description": [
        "<div class=\"rosetta\">",
        "<dl class=\"rosetta__description-list\">",
        "    <dt class=\"rosetta__description-title\">Task:</dt>",
        "</dl>",
        "<p class=\"rosetta__paragraph\">Solve the <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Towers_of_Hanoi\" title=\"wp: Towers_of_Hanoi\">Towers of Hanoi</a>  problem.</p>",
        "<p class=\"rosetta__paragraph\">",
        "Your solution should accept the number of discs as the first parameters, and",
        "three string used to identify each of the three stacks of discs, for example",
        "<code>towerOfHanoi(4, 'A', 'B', 'C')</code>. The function should return an",
        "array of arrays containing the list of moves, source -> destination. For",
        "example, the array <code>[['A', 'C'], ['B', 'A']]</code> indicates that the",
        "1st move was to move a disc from stack A to C, and the 2nd move was to move a",
        "disc from stack B to A.",
        "</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function towerOfHanoi (n, a, b, c) {",
        "  // Good luck!",
        "  return [[]];",
        "}"
      ],
      "solutions": [
        "function towerOfHanoi(n, a, b, c) {\n  const res = [];\n  towerOfHanoiHelper(n, a, c, b, res);\n  return res;\n}\n\nfunction towerOfHanoiHelper(n, a, b, c, res) {\n  if (n > 0) {\n    towerOfHanoiHelper(n - 1, a, c, b, res);\n    res.push([a, c]);\n    towerOfHanoiHelper(n - 1, b, a, c, res);\n  }\n}\n"
      ],
      "tail": [
        "const res3 = towerOfHanoi(3, 'A', 'B', 'C');",
        "const res3Moves = [['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B']];",
        "const res5 = towerOfHanoi(5, 'X', 'Y', 'Z');",
        "const res7First10Moves = [['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['B', 'A']];"
      ],
      "tests": [
        "assert(typeof towerOfHanoi === 'function', 'message: <code>towerOfHanoi</code> is a function.');",
        "assert(res3.length === 7, 'message: <code>towerOfHanoi(3, ...)</code> should return 7 moves.');",
        "assert.deepEqual(towerOfHanoi(3, 'A', 'B', 'C'), res3Moves, \"message: <code>towerOfHanoi(3, 'A', 'B', 'C')</code> should return [['A','B'],['A','C'],['B','C'],['A','B'],['C','A'],['C','B'],['A','B']].\");",
        "assert.deepEqual(res5[9], ['Y', 'X'], 'message: <code>towerOfHanoi(5, \"X\", \"Y\", \"Z\")</code> 10th move should be Y -> X.');",
        "assert.deepEqual(towerOfHanoi(7, 'A', 'B', 'C').slice(0, 10), res7First10Moves, \"message: <code>towerOfHanoi(7, 'A', 'B', 'C')</code> first ten moves are [['A','B'],['A','C'],['B','C'],['A','B'],['C','A'],['C','B'],['A','B'],['A','C'],['B','C'],['B','A']].\");"
      ],
      "id": "5951ed8945deab770972ae56"
    },
    {
      "title": "Vector cross product",
      "type": "rosetta-code",
      "difficulty": "2",
      "categories": [
        "vector",
        "math"
      ],
      "description": [
        "<div class=\"rosetta\">",
        "A vector is defined as having three dimensions as being represented by an ordered collection of three numbers: &nbsp; (X, Y, Z).",
        "<br/>",
        "<p class=\"rosetta__paragraph\">",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">",
        "    Write a function that takes two vectors (arrays) as input and computes their cross product.",
        "  </li>",
        "</ul>",
        "<br>",
        "Your function should return <code>null</code> on",
        "invalid inputs (ie vectors of different lengths).",
        "</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function crossProduct() {",
        "    // Good luck!",
        "}"
      ],
      "solutions": [
        "function crossProduct(a, b) {\n  if (!a || !b) {\n    return null;\n  }\n\n  // Check lengths\n  if (a.length !== 3 || b.length !== 3) {\n    return null;\n  }\n\n  return [\n    (a[1] * b[2]) - (a[2] * b[1]),\n    (a[2] * b[0]) - (a[0] * b[2]),\n    (a[0] * b[1]) - (a[1] * b[0])\n  ];\n}\n"
      ],
      "tail": [
        "const tv1 = [1, 2, 3];",
        "const tv2 = [4, 5, 6];",
        "const res12 = crossProduct(tv1, tv2);",
        "const exp12 = [-3, 6, -3];"
      ],
      "tests": [
        "assert.equal(typeof crossProduct, 'function', 'message: dotProduct must be a function');",
        "assert.equal(crossProduct(), null, 'message: dotProduct() must return null');",
        "assert.deepEqual(res12, exp12, 'message: crossProduct([1, 2, 3], [4, 5, 6]) must return [-3, 6, -3].');"
      ],
      "id": "594810f028c0303b75339ad2"
    },
    {
      "title": "Vector dot product",
      "type": "rosetta-code",
      "difficulty": "3",
      "categories": [
        "vector",
        "math"
      ],
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">",
        "A vector is defined as having three dimensions as being represented by an ordered collection of three numbers: &nbsp; (X, Y, Z).",
        "</p>",
        "<br/>",
        "<p class=\"rosetta__paragraph\">",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">",
        "    Write a function that takes any numbers of vectors (arrays) as input and computes their dot product.",
        "  </li>",
        "</ul>",
        "<br>",
        "Your function should return <code>null</code> on",
        "invalid inputs (ie vectors of different lengths).",
        "</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function dotProduct() {",
        "    // Good luck!",
        "}"
      ],
      "solutions": [
        "function dotProduct(...vectors) {\n  if (!vectors || !vectors.length) {\n    return null;\n  }\n  if (!vectors[0] || !vectors[0].length) {\n    return null;\n  }\n  const vectorLen = vectors[0].length;\n  const numVectors = vectors.length;\n\n  // If all vectors not same length, return null\n  for (let i = 0; i < numVectors; i++) {\n    if (vectors[i].length !== vectorLen) {\n      return null;  // return undefined\n    }\n  }\n\n  let prod = 0;\n  let sum = 0;\n  let j = vectorLen;\n  let i = numVectors;\n  // Sum terms\n  while (j--) {\n    i = numVectors;\n    prod = 1;\n\n    while (i--) {\n      prod *= vectors[i][j];\n    }\n    sum += prod;\n  }\n  return sum;\n}\n"
      ],
      "tail": [
        "const vectors5x5 = [];",
        "for (let i = 0; i < 5; i++) {",
        "  vectors5x5[i] = [];",
        "  for (let j = 0; j < 5; j++) {",
        "    vectors5x5[i].push((i + 1) * j);",
        "  }",
        "}",
        "const vectorsWp = [[1, 3, -5], [4, -2, -1]];"
      ],
      "tests": [
        "assert.equal(typeof dotProduct, 'function', 'message: dotProduct must be a function');",
        "assert.equal(dotProduct(), null, 'message: dotProduct() must return null');",
        "assert.equal(dotProduct([1], [1]), 1, 'message: dotProduct([[1], [1]]) must return 1.');",
        "assert.equal(dotProduct([1], [1, 2]), null, 'message: dotProduct([[1], [1, 2]]) must return null.');",
        "assert.equal(dotProduct(...vectorsWp), 3, 'message: dotProduct([[1, 3, -5], [4, -2, -1]]) must return 3.');",
        "assert.equal(dotProduct(...vectors5x5), 156000);"
      ],
      "id": "594810f028c0303b75339ad3"
    },
    {
      "title": "Word wrap",
      "difficulty": "2",
      "type": "rosetta-code",
      "categories": "strings",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">",
        "Even today, with proportional fonts and complex layouts, there are still",
        "cases where you need to wrap text at a specified",
        "column.  The basic task is to wrap a paragraph of text in a simple way.",
        "Example text:",
        "</p>",
        "<pre>",
        "Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.",
        "If your language provides this, you get easy extra credit,",
        "but you ''must reference documentation'' indicating that the algorithm",
        "is something better than a simple minimimum length algorithm.",
        "</pre>",
        "<p class=\"rosetta__paragraph\">",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">",
        "    Write a function that can wrap this text to any number of characters.",
        "  </li>",
        "</ul>",
        "<br>",
        "As an example, the text wrapped to 80 characters should look like the following:",
        "</p>",
        "<pre>",
        "Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX",
        "algorithm. If your language provides this, you get easy extra credit, but you",
        "must reference documentation indicating that the algorithm is something better",
        "than a simple minimimum length algorithm.",
        "</pre>",
        "</div>"
      ],
      "challengeSeed": [
        "function wrap (text, limit) {",
        "  return text;",
        "}"
      ],
      "solutions": [
        "function wrap (text, limit) {\n  const noNewlines = text.replace('\\n', '');\n  if (noNewlines.length > limit) {\n    // find the last space within limit\n    const edge = noNewlines.slice(0, limit).lastIndexOf(' ');\n    if (edge > 0) {\n      const line = noNewlines.slice(0, edge);\n      const remainder = noNewlines.slice(edge + 1);\n      return line + '\\n' + wrap(remainder, limit);\n    }\n  }\n  return text;\n}\n"
      ],
      "tail": [
        "const text =",
        "`Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.",
        "If your language provides this, you get easy extra credit,",
        "but you ''must reference documentation'' indicating that the algorithm",
        "is something better than a simple minimimum length algorithm.`;",
        "",
        "const wrapped80 = wrap(text, 80);",
        "const wrapped42 = wrap(text, 42);",
        "",
        "const firstRow80 =",
        "    'Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX';",
        "",
        "const firstRow42 = 'Wrap text using a more sophisticated';"
      ],
      "tests": [
        "assert.equal(typeof wrap, 'function', 'message: wrap must be a function.');",
        "assert.equal(typeof wrap('abc', 10), 'string', 'message: wrap must return a string.');",
        "assert(wrapped80.split('\\n').length === 4, 'message: wrap(80) must return 4 lines.');",
        "assert.equal(wrapped80.split('\\n')[0], firstRow80);",
        "assert(wrapped42.split('\\n').length === 7, 'message: wrap(42) must return 7 lines.');",
        "assert.equal(wrapped42.split('\\n')[0], firstRow42);"
      ],
      "id": "594810f028c0303b75339ad4"
    },
    {
      "title": "Y combinator",
      "difficulty": "6",
      "type": "rosetta-code",
      "categories": "recursion",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">",
        "In strict ",
        "<a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Functional programming\" title=\"wp: functional programming\">functional programming</a> and",
        "the <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/lambda calculus\" title=\"wp: lambda calculus\">lambda calculus</a>, ",
        "functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions. ",
        "This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.",
        "</p>",
        "<br>",
        "<p class=\"rosetta__paragraph\">",
        "The <a href=\"http://mvanier.livejournal.com/2897.html\">Y combinator</a> is itself a stateless function that,",
        "when applied to another stateless function, returns a recursive version of the function. The Y combinator is",
        "the simplest of the class of such functions, called ",
        "<a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Fixed-point combinator\" title=\"wp: fixed-point combinator\">fixed-point combinators</a>.",
        "</p>",
        "<br>",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">",
        "    Define the stateless Y combinator function and use it to compute",
        "    <a class=\"rosetta__link--wiki\" href=\"https://en.wikipedia.org/wiki/Factorial\" title=\"wp: factorial\">factorial</a>.",
        "  </li>",
        "</ul>",
        "<br>",
        "<code>factorial(N)</code> function is already given to you.",
        "See also <a href=\"http://vimeo.com/45140590\">Jim Weirich: Adventures in Functional Programming</a>.",
        "</div>"
      ],
      "challengeSeed": [
        "function Y(f) {",
        "  return function() {",
        "  // Good luck!",
        "  };",
        "}",
        "",
        "var factorial = Y(function(f) {",
        "  return function (n) {",
        "    return n > 1 ? n * f(n - 1) : 1;",
        "  };",
        "});"
      ],
      "solutions": [
        "var Y = f => (x => x(x))(y => f(x => y(y)(x)));\n"
      ],
      "tail": "var factorial = Y(f => n => (n > 1 ? n * f(n - 1) : 1));",
      "tests": [
        "assert.equal(typeof Y(f => n => n), 'function', 'message: Y must return a function');",
        "assert.equal(factorial(1), 1, 'message: factorial(1) must return 1.');",
        "assert.equal(factorial(2), 2, 'message: factorial(2) must return 2.');",
        "assert.equal(factorial(3), 6, 'message: factorial(3) must return 6.');",
        "assert.equal(factorial(4), 24, 'message: factorial(4) must return 24.');",
        "assert.equal(factorial(10), 3628800, 'message: factorial(10) must return 3628800.');"
      ],
      "id": "594810f028c0303b75339ad5"
    },
    {
      "title": "Zeckendorf number representation",
      "type": "rosetta-code",
      "difficulty": "3",
      "description": [
        "<div class=\"rosetta\">",
        "<p class=\"rosetta__paragraph\">",
        "Just as numbers can be represented in a",
        "positional notation as sums of multiples of the powers of ten (decimal)",
        "or two (binary); all the positive integers can be represented as the sum",
        "of one or zero times the distinct members of the Fibonacci series.",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        "Recall that the first six distinct Fibonacci",
        "numbers are:  <code>1, 2, 3, 5, 8, 13</code>. The decimal number eleven can",
        "be written as <code>0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1</code> or",
        "<code>010100</code> in positional notation where the columns represent",
        "multiplication by a particular member of the sequence. Leading zeroes are",
        "dropped so that 11 decimal becomes <code>10100</code>.",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        "10100 is not the only way to make 11 from the Fibonacci numbers however",
        "<code>0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 1*1</code> or 010011 would also",
        "represent decimal 11. For a true Zeckendorf number there is the added",
        "restriction that ''no two consecutive Fibonacci numbers can be used''",
        "which leads to the former unique solution.",
        "</p>",
        "<p class=\"rosetta__paragraph\">",
        " <dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        " <ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">Write a function that generates and returns an array of first N Zeckendorf numbers in order.</li></ul>",
        "</p>",
        "</div>"
      ],
      "challengeSeed": [
        "function zeckendorf(n) {",
        "  // good luck!",
        "}"
      ],
      "solutions": [
        "// zeckendorf :: Int -> String\nfunction zeckendorf(n) {\n  const f = (m, x) => (m < x ? [m, 0] : [m - x, 1]);\n  return (n === 0 ? ([0]) :\n    mapAccumL(f, n, reverse(\n      tail(fibUntil(n))\n    ))[1]).join('');\n}\n\n// fibUntil :: Int -> [Int]\nlet fibUntil = n => {\n  const xs = [];\n  until(\n      ([a]) => a > n,\n      ([a, b]) => (xs.push(a), [b, a + b]), [1, 1]\n  );\n  return xs;\n};\n\nlet mapAccumL = (f, acc, xs) => (\n  xs.reduce((a, x) => {\n    const pair = f(a[0], x);\n\n    return [pair[0], a[1].concat(pair[1])];\n  }, [acc, []])\n);\n\nlet until = (p, f, x) => {\n  let v = x;\n  while (!p(v)) v = f(v);\n  return v;\n};\n\nconst tail = xs => (\n   xs.length ? xs.slice(1) : undefined\n);\n\nconst reverse = xs => xs.slice(0).reverse();\n"
      ],
      "tail": [
        "const range = (m, n) => (",
        "  Array.from({",
        "    length: Math.floor(n - m) + 1",
        "  }, (_, i) => m + i)",
        ");",
        "",
        "const solution20 = [",
        "  '1', '10', '100', '101', '1000', '1001', '1010', '10000', '10001',",
        "  '10010', '10100', '10101', '100000', '100001', '100010', '100100', '100101',",
        "  '101000', '101001', '101010'",
        "];",
        "",
        "const answer = range(1, 20).map(zeckendorf);"
      ],
      "tests": [
        "assert.equal(typeof zeckendorf, 'function', 'message: zeckendorf must be function');",
        "assert.deepEqual(answer, solution20);"
      ],
      "id": "594810f028c0303b75339ad6"
    },
    {
      "title": "Zhang-Suen thinning algorithm",
      "type": "rosetta-code",
      "difficulty": "7",
      "description": [
        "<div class=\"rosetta\">",
        "This is an algorithm used to thin a black and white i.e. one bit per pixel images.",
        "<br/>",
        "For example, with an input image of:",
        "<pre>",
        " #################                   #############",
        " ##################               ################",
        " ###################            ##################",
        " ########     #######          ###################",
        "   ######     #######         #######       ######",
        "   ######     #######        #######",
        "   #################         #######",
        "   ################          #######",
        "   #################         #######",
        "   ######     #######        #######",
        "   ######     #######        #######",
        "   ######     #######         #######       ######",
        " ########     #######          ###################",
        " ########     ####### ######    ################## ######",
        " ########     ####### ######      ################ ######",
        " ########     ####### ######         ############# ######",
        "                                                           </pre>",
        "It produces the thinned output:",
        "<pre>",
        "                                                           ",
        "    # ##########                       #######",
        "     ##        #                   ####       #",
        "     #          #                 ##",
        "     #          #                #",
        "     #          #                #",
        "     #          #                #",
        "     ############               #",
        "     #          #               #",
        "     #          #                #",
        "     #          #                #",
        "     #          #                #",
        "     #                            ##",
        "     #                             ############",
        "                       ###                          ###",
        "                                                           ",
        "                                                           </pre>",
        "<br/>",
        "<h2>Algorithm</h2>",
        "Assume black pixels are one and white pixels zero, and that the input image is a rectangular N by M array of ones and zeroes.",
        "<br/>",
        "The algorithm operates on all black pixels P1 that can have eight neighbours. The neighbours are, in order, arranged as:",
        "<table class=\"table\" border=\"1\">",
        "  <tr><td>P9</td><td>P2</td><td>P3</td></tr>",
        "  <tr><td>P8</td><td><b>P1</b></td><td>P4</td></tr>",
        "  <tr><td>P7</td><td>P6</td><td>P5</td></tr>",
        "</table>",
        "<br/>",
        "Obviously the boundary pixels of the image cannot have the full eight neighbours.",
        "<br/>",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">",
        "    Define $A(P1)$ = the number of transitions from white to black, (0 -> 1) in the sequence P2,P3,P4,P5,P6,P7,P8,P9,P2. (Note the extra P2 at the end - it is circular).",
        "  </li>",
        "  <li class=\"rosetta__list-item--unordered\">",
        "    Define $B(P1)$ = the number of black pixel neighbours of P1. ( = sum(P2 .. P9) )",
        "  </li>",
        "</ul>",
        "<br/>",
        "<h3>Step 1:</h3>",
        "All pixels are tested and pixels satisfying all the following conditions (simultaneously) are just noted at this stage.",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">(0) The pixel is black and has eight neighbours</li>",
        "  <li class=\"rosetta__list-item--unordered\">(1) $2 <= B(P1) <= 6$</li>",
        "  <li class=\"rosetta__list-item--unordered\">(2) $A(P1) = 1$</li>",
        "  <li class=\"rosetta__list-item--unordered\">(3) At least one of P2 and P4 and P6 is white</li>",
        "  <li class=\"rosetta__list-item--unordered\">(4) At least one of P4 and P6 and P8 is white</li>",
        "</ul>",
        "After iterating over the image and collecting all the pixels satisfying all step 1 conditions, all these condition satisfying pixels are set to white.",
        "<br/>",
        "<h3>Step 2:</h3>",
        "All pixels are again tested and pixels satisfying all the following conditions are just noted at this stage.",
        "<ul class=\"rosetta__unordered-list\">",
        "  <li class=\"rosetta__list-item--unordered\">(0) The pixel is black and has eight neighbours</li>",
        "  <li class=\"rosetta__list-item--unordered\">(1) $2 <= B(P1) <= 6$</li>",
        "  <li class=\"rosetta__list-item--unordered\">(2) $A(P1) = 1$</li>",
        "  <li class=\"rosetta__list-item--unordered\">(3) At least one of P2 and P4 and '''P8''' is white</li>",
        "  <li class=\"rosetta__list-item--unordered\">(4) At least one of '''P2''' and P6 and P8 is white</li>",
        "</ul>",
        "After iterating over the image and collecting all the pixels satisfying all step 2 conditions, all these condition satisfying pixels are again set to white.",
        "<br/>",
        "Iteration:",
        "If any pixels were set in this round of either step 1 or step 2 then all steps are repeated until no image pixels are so changed.",
        "<br/>",
        "<p class=\"rosetta__paragraph\">",
        "<dl class=\"rosetta__description-list\"><dt class=\"rosetta__description-title\">Task:</dt></dl>",
        "<ul class=\"rosetta__unordered-list\"><li class=\"rosetta__list-item--unordered\">Write a routine to perform Zhang-Suen thinning on an image matrix of ones and zeroes.</li></ul>",
        "</p>",
        "</div>"
      ],
      "challengeSeed": [
        "const testImage = [",
        "  '                                                          ',",
        "  ' #################                   #############        ',",
        "  ' ##################               ################        ',",
        "  ' ###################            ##################        ',",
        "  ' ########     #######          ###################        ',",
        "  '   ######     #######         #######       ######        ',",
        "  '   ######     #######        #######                      ',",
        "  '   #################         #######                      ',",
        "  '   ################          #######                      ',",
        "  '   #################         #######                      ',",
        "  '   ######     #######        #######                      ',",
        "  '   ######     #######        #######                      ',",
        "  '   ######     #######         #######       ######        ',",
        "  ' ########     #######          ###################        ',",
        "  ' ########     ####### ######    ################## ###### ',",
        "  ' ########     ####### ######      ################ ###### ',",
        "  ' ########     ####### ######         ############# ###### ',",
        "  '                                                          '];",
        "",
        "function thinImage(image) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nconst ZhangSuen = (function () {\n  function ZhangSuen() {\n  }\n\n  ZhangSuen.nbrs = [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1]];\n\n  ZhangSuen.nbrGroups = [[[0, 2, 4], [2, 4, 6]], [[0, 2, 6], [0, 4, 6]]];\n\n  ZhangSuen.toWhite = [];\n\n  ZhangSuen.main = function (image) {\n    ZhangSuen.grid = new Array(image);\n    for (let r = 0; r < image.length; r++) {\n      ZhangSuen.grid[r] = image[r].split('');\n    }\n    ZhangSuen.thinImage();\n    return ZhangSuen.getResult();\n  };\n\n  ZhangSuen.thinImage = function () {\n    let firstStep = false;\n    let hasChanged;\n    do {\n      hasChanged = false;\n      firstStep = !firstStep;\n      for (let r = 1; r < ZhangSuen.grid.length - 1; r++) {\n        for (let c = 1; c < ZhangSuen.grid[0].length - 1; c++) {\n          if (ZhangSuen.grid[r][c] !== '#') {\n            continue;\n          }\n          const nn = ZhangSuen.numNeighbors(r, c);\n          if (nn < 2 || nn > 6) {\n            continue;\n          }\n          if (ZhangSuen.numTransitions(r, c) !== 1) {\n            continue;\n          }\n          if (!ZhangSuen.atLeastOneIsWhite(r, c, firstStep ? 0 : 1)) {\n            continue;\n          }\n          ZhangSuen.toWhite.push(new Point(c, r));\n          hasChanged = true;\n        }\n      }\n      for (let i = 0; i < ZhangSuen.toWhite.length; i++) {\n        const p = ZhangSuen.toWhite[i];\n        ZhangSuen.grid[p.y][p.x] = ' ';\n      }\n      ZhangSuen.toWhite = [];\n    } while ((firstStep || hasChanged));\n  };\n\n  ZhangSuen.numNeighbors = function (r, c) {\n    let count = 0;\n    for (let i = 0; i < ZhangSuen.nbrs.length - 1; i++) {\n      if (ZhangSuen.grid[r + ZhangSuen.nbrs[i][1]][c + ZhangSuen.nbrs[i][0]] === '#') {\n        count++;\n      }\n    }\n    return count;\n  };\n\n  ZhangSuen.numTransitions = function (r, c) {\n    let count = 0;\n    for (let i = 0; i < ZhangSuen.nbrs.length - 1; i++) {\n      if (ZhangSuen.grid[r + ZhangSuen.nbrs[i][1]][c + ZhangSuen.nbrs[i][0]] === ' ') {\n        if (ZhangSuen.grid[r + ZhangSuen.nbrs[i + 1][1]][c + ZhangSuen.nbrs[i + 1][0]] === '#') {\n          count++;\n        }\n      }\n    }\n    return count;\n  };\n\n  ZhangSuen.atLeastOneIsWhite = function (r, c, step) {\n    let count = 0;\n    const group = ZhangSuen.nbrGroups[step];\n    for (let i = 0; i < 2; i++) {\n      for (let j = 0; j < group[i].length; j++) {\n        const nbr = ZhangSuen.nbrs[group[i][j]];\n        if (ZhangSuen.grid[r + nbr[1]][c + nbr[0]] === ' ') {\n          count++;\n          break;\n        }\n      }\n    }\n    return count > 1;\n  };\n\n  ZhangSuen.getResult = function () {\n    const result = [];\n    for (let i = 0; i < ZhangSuen.grid.length; i++) {\n      const row = ZhangSuen.grid[i].join('');\n      result.push(row);\n    }\n    return result;\n  };\n  return ZhangSuen;\n}());\n\nfunction thinImage(image) {\n  return ZhangSuen.main(image);\n}\n"
      ],
      "tail": [
        "",
        "const imageForTests = [",
        "  '                                                          ',",
        "  ' #################                   #############        ',",
        "  ' ##################               ################        ',",
        "  ' ###################            ##################        ',",
        "  ' ########     #######          ###################        ',",
        "  '   ######     #######         #######       ######        ',",
        "  '   ######     #######        #######                      ',",
        "  '   #################         #######                      ',",
        "  '   ################          #######                      ',",
        "  '   #################         #######                      ',",
        "  '   ######     #######        #######                      ',",
        "  '   ######     #######        #######                      ',",
        "  '   ######     #######         #######       ######        ',",
        "  ' ########     #######          ###################        ',",
        "  ' ########     ####### ######    ################## ###### ',",
        "  ' ########     ####### ######      ################ ###### ',",
        "  ' ########     ####### ######         ############# ###### ',",
        "  '                                                          '];",
        "const expected = [",
        "  '                                                          ',",
        "  '                                                          ',",
        "  '    # ##########                       #######            ',",
        "  '     ##        #                   ####       #           ',",
        "  '     #          #                 ##                      ',",
        "  '     #          #                #                        ',",
        "  '     #          #                #                        ',",
        "  '     #          #                #                        ',",
        "  '     ############               #                         ',",
        "  '     #          #               #                         ',",
        "  '     #          #                #                        ',",
        "  '     #          #                #                        ',",
        "  '     #          #                #                        ',",
        "  '     #                            ##                      ',",
        "  '     #                             ############           ',",
        "  '                       ###                          ###   ',",
        "  '                                                          ',",
        "  '                                                          '",
        "];",
        "const result = thinImage(imageForTests);"
      ],
      "tests": [
        "assert.equal(typeof thinImage, 'function', 'thinImage must be a function');",
        "assert.equal(typeof result, 'object', 'thinImage must return an array of strings');",
        "assert.equal(typeof result[0], 'string', 'thinImage must return an array of strings');",
        "assert.deepEqual(result, expected, 'thinImage must return an array of strings');"
      ],
      "id": "594810f028c0303b75339ad7"
    },
    {
      "title": "Zig-zag matrix",
      "type": "rosetta-code",
      "difficulty": "3",
      "categories": "matrix",
      "description": [
        "<div class=\"rosetta\">",
        "A &nbsp; ''zig-zag'' &nbsp; array is a square arrangement of the first &nbsp;",
        "$N^2$ &nbsp; integers, &nbsp; where the",
        "numbers increase sequentially as you zig-zag along the array's &nbsp;",
        "<a href=\"https://en.wiktionary.org/wiki/antidiagonal\">anti-diagonals</a>.",
        "<br/>",
        "For example, given &nbsp; '''5''', &nbsp; produce this array:",
        "<pre>",
        " 0  1  5  6 14",
        " 2  4  7 13 15",
        " 3  8 12 16 21",
        " 9 11 17 20 22",
        "10 18 19 23 24",
        "</pre>",
        "Write a function that takes the size of the zig-zag matrix, and returns the",
        "corresponding matrix as two-dimensional array.",
        "</div>"
      ],
      "challengeSeed": [
        "function ZigZagMatrix(n) {",
        "  // Good luck!",
        "  return [[], []];",
        "}"
      ],
      "solutions": [
        "function ZigZagMatrix(n) {\n  const mtx = [];\n  for (let i = 0; i < n; i++) {\n    mtx[i] = [];\n  }\n\n  let i = 1;\n  let j = 1;\n  for (let e = 0; e < n * n; e++) {\n    mtx[i - 1][j - 1] = e;\n    if ((i + j) % 2 === 0) {\n      // Even stripes\n      if (j < n) j++;\n      else i += 2;\n      if (i > 1) i--;\n    } else {\n      // Odd stripes\n      if (i < n) i++;\n      else j += 2;\n      if (j > 1) j--;\n    }\n  }\n  return mtx;\n}\n"
      ],
      "tail": [
        "const zm1 = [[0]];",
        "const zm2 = [[0, 1], [2, 3]];",
        "const zm5 = [",
        "  [0, 1, 5, 6, 14],",
        "  [2, 4, 7, 13, 15],",
        "  [3, 8, 12, 16, 21],",
        "  [9, 11, 17, 20, 22],",
        "  [10, 18, 19, 23, 24]",
        "];"
      ],
      "tests": [
        "assert.equal(typeof ZigZagMatrix, 'function', 'message: ZigZagMatrix must be a function');",
        "assert.equal(typeof ZigZagMatrix(1), 'object', 'message: ZigZagMatrix should return array');",
        "assert.equal(typeof ZigZagMatrix(1)[0], 'object', 'message: ZigZagMatrix should return an array of nestes arrays');",
        "assert.deepEqual(ZigZagMatrix(1), zm1, 'message: ZigZagMatrix(1) should return [[0]]');",
        "assert.deepEqual(ZigZagMatrix(2), zm2, 'message: ZigZagMatrix(2) should return [[0, 1], [2, 3]]');",
        "assert.deepEqual(ZigZagMatrix(5), zm5, 'message: ZigZagMatrix(5) must return specified matrix');"
      ],
      "id": "594810f028c0303b75339ad8"
    }
  ]
}