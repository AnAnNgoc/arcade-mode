{
  "name": "ArcadeMode Interview Questions",
  "order": "",
  "time": "",
  "helpRoom": "",
  "challenges": [
    {
      "title": "100 doors",
      "type": "rosetta-code",
      "categories": "?",
      "difficulty": "2",
      "benchmark": "getFinalOpenedDoors(10000);",
      "description": [
        "There are 100 doors in a row that are all initially closed. You make 100 passes by the doors. The first time through, visit every door and 'toggle' the door (if the door is closed, open it; if it is open, close it). The second time, only visit every 2nd door (i.e., door #2, #4, #6, ...) and toggle it. The third time, visit every 3rd door (i.e., door #3, #6, #9, ...), etc., until you only visit the 100th door.",
        "Implement an algorithm to determine the state of the doors after the last pass. Return the final result in an array, with only the door number included in the array if it is open."
      ],
      "challengeSeed": [
        "function getFinalOpenedDoors (numDoors) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function getFinalOpenedDoors (numDoors) {\n  // this is the final pattern (always squares).\n  // thus, the most efficient solution simply returns an array of squares up to numDoors).\n  const finalState = [];\n  let i = 1;\n  while (i ** 2 <= numDoors) {\n    finalState.push(i ** 2);\n    i++;\n  }\n /*\n  Array.apply(null, { length: numDoors })\n    .map((v, i) => i + 1)\n    .forEach(door => {\n      const sqrt = Math.sqrt(door);\n      if (sqrt === Math.floor(sqrt)) { // check if equal to floored value\n        finalState.push(door);\n      }\n    });\n   */\n  return finalState;\n}\n"
      ],
      "naive": "function getFinalOpenedDoors (numDoors) {\n  const doors = [];\n  const openedDoors = [];\n  for (let i = 0; i < numDoors; i++) {\n    doors[i] = false; // create doors\n  }\n  for (let i = 1; i <= numDoors; i++) {\n    for (let i2 = i - 1; i2 < numDoors; i2+=i) {\n      doors[i2] = !doors[i2]; // toggle doors\n    }\n  }\n  for (let i = 0; i < numDoors; i++) {\n    if (doors[i]) {\n      openedDoors.push(i + 1);\n    }\n  }\n\n  return openedDoors;\n}\n",
      "tail": "const solution = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100];",
      "tests": [
        "assert(typeof getFinalOpenedDoors === 'function', 'message: <code>getFinalOpenedDoors</code> is a function.');",
        "assert(Array.isArray(getFinalOpenedDoors(100)), 'message: <code>getFinalOpenedDoors</code> should return an array.');",
        "assert.deepEqual(getFinalOpenedDoors(100), solution, 'message: <code>getFinalOpenedDoors</code> did not produce the correct results.');"
      ],
      "id": 0
    },
    {
      "title": "ABC Problem",
      "type": "rosetta-code",
      "categories": "?",
      "difficulty": "3",
      "description": [
        "You are given a collection of ABC blocks (e.g., childhood alphabet blocks). There are 20 blocks with two letters on each block. A complete alphabet is guaranteed amongst all sides of the blocks. The sample collection of blocks,",
        "(B O)",
        "(X K)",
        "(D Q)",
        "(C P)",
        "(N A)",
        "(G T)",
        "(R E)",
        "(T G)",
        "(Q D)",
        "(F S)",
        "(J W)",
        "(H U)",
        "(V I)",
        "(A N)",
        "(O B)",
        "(E R)",
        "(F S)",
        "(L Y)",
        "(P C)",
        "(Z M)",
        "Some rules to keep in mind,",
        "1. Once a letter on a block is used, that block cannot be used again",
        "2. the function should be case-insensitive",
        "Implement a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks."
      ],
      "challengeSeed": [
        "function canMakeWord (word) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function canMakeWord (word) {\n  const characters = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM';\n  const blocks = characters.split(' ').map(pair => pair.split(''));\n\n  const letters = [...word.toUpperCase()];\n  let length = letters.length;\n  const copy = new Set(blocks);\n\n  letters.forEach(letter => {\n    for (let block of copy) {\n      const index = block.indexOf(letter);\n\n      if (index !== -1) {\n        length--;\n        copy.delete(block);\n        break;\n      }\n    }\n  });\n  return !length;\n}\n"
      ],
      "tail": "const words = ['bark', 'BooK', 'TReAT', 'COMMON', 'squAD', 'conFUSE'];",
      "tests": [
        "assert(typeof canMakeWord === 'function', 'message: <code>canMakeWord</code> is a function.');",
        "assert(typeof canMakeWord('hi') === 'boolean', 'message: <code>canMakeWord</code> should return a boolean.');",
        "assert.isTrue(canMakeWord(words[0]), 'message: <code>canMakeWord(\"bark\")</code> should return true.');",
        "assert.isFalse(canMakeWord(words[1]), 'message: <code>canMakeWord(\"BooK\")</code> should return false.');",
        "assert.isTrue(canMakeWord(words[2]), 'message: <code>canMakeWord(\"TReAT\")</code> should return true.');",
        "assert.isFalse(canMakeWord(words[3]), 'message: <code>canMakeWord(\"COMMON\")</code> should return false.');",
        "assert.isTrue(canMakeWord(words[4]), 'message: <code>canMakeWord(\"squAD\")</code> should return true.');",
        "assert.isTrue(canMakeWord(words[5]), 'message: <code>canMakeWord(\"conFUSE\")</code> should return true.');"
      ],
      "id": 0
    },
    {
      "title": "Abundant, deficient and perfect number classifications",
      "type": "rosetta-code",
      "categories": "?",
      "difficulty": "4",
      "benchmark": "getDPA(20000);",
      "description": [
        "These define three classifications of positive integers based on their Proper Divisors.",
        "Let P(n) be the sum of the proper divisors of n where proper divisors are all positive integers n other than n itself.",
        "if <code>P(n) < n</code> then n is classed as \"deficient\"",
        "if <code>P(n) === n</code> then n is classed as \"perfect\"",
        "if <code>P(n) > n</code> then n is classed as \"abundant\"",
        "Example",
        "6 has proper divisors of 1, 2, and 3.",
        "1 + 2 + 3 = 6, so 6 is classed as a perfect number.",
        "Implement an function that calculates how many of hte integers from 1 to 20,000 (inclusive) are in each of the three classes. Output the result as an array in the following format [deficient, perfect, abundant]."
      ],
      "challengeSeed": [
        "function getDPA (num) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function getDPA (num) {\n  const dpa = [1, 0, 0];\n  for (let n = 2; n <= num; n += 1) {\n    let ds = 1;\n    const e = Math.sqrt(n);\n    for (let d = 2; d < e; d += 1) {\n      if (n % d === 0) {\n        ds += d + (n / d);\n      }\n    }\n    if (n % e === 0) {\n      ds += e;\n    }\n    dpa[ds < n ? 0 : ds === n ? 1 : 2] += 1;\n  }\n  return dpa;\n}\n"
      ],
      "tail": "const solution = [15043, 4, 4953];",
      "tests": [
        "assert(typeof getDPA === 'function', 'message: <code>getDPA</code> is a function.');",
        "assert(Array.isArray(getDPA(100)), 'message: <code>getDPA</code> should return an array.');",
        "assert(getDPA(100).length === 3, 'message: <code>getDPA</code> return value should have a length of 3.');",
        "assert.deepEqual(getDPA(20000), solution, 'message: <code>getDPA(20000)</code> should equal [15043, 4, 4953]');"
      ],
      "id": 0
    },
    {
      "title": "Accumulator factory",
      "type": "rosetta-code",
      "categories": "closures",
      "difficulty": "1",
      "description": [
        "Create a function that takes a single (numeric) argument and returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).",
        "Rules",
        "Do not use global variables.",
        "Hint",
        "Closures save outer state."
      ],
      "challengeSeed": [
        "function accumulator (sum) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function accumulator (sum) {\n  return function (n) {\n    return sum += n;\n  };\n}\n"
      ],
      "tail": [
        "const testFn = typeof accumulator(3) === 'function' && accumulator(3);",
        "if (testFn) {",
        "  testFn(-4);",
        "  testFn(1.5);",
        "}"
      ],
      "tests": [
        "assert(typeof accumulator === 'function', 'message: <code>accumulator</code> is a function.');",
        "assert(typeof accumulator(0) === 'function', 'message: <code>accumulator(0)</code> should return a function.');",
        "assert(typeof accumulator(0)(2) === 'number', 'message: <code>accumulator(0)(2)</code> should return a number.');",
        "assert(testFn(5) === 5.5, 'message: Passing in the values 3, -4, 1.5, and 5 should return 5.5.');"
      ],
      "id": 0
    },
    {
      "title": "Ackermann function",
      "type": "rosetta-code",
      "categories": "recursion",
      "difficulty": "2",
      "description": [
        "The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.",
        "The Ackermann function is usually defined as follows",
        "$$A(m, n) =",
        " \\begin{cases}",
        " n+1 & \\mbox{if } m = 0 \\\\",
        " A(m-1, 1) & \\mbox{if } m > 0 \\mbox{ and } n = 0 \\\\",
        " A(m-1, A(m, n-1)) & \\mbox{if } m > 0 \\mbox{ and } n > 0.",
        " \\end{cases}$$",
        "Its arguments are never negative and it always terminates. Write a function which returns the value of A(m, n). Arbitrary precision is preferred (since the function grows so quickly), but not required."
      ],
      "challengeSeed": [
        "function ack (m, n) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function ack (m, n) {\n  return m === 0 ? n + 1 : ack(m - 1, n === 0 ? 1 : ack(m, n - 1));\n}\n"
      ],
      "tests": [
        "assert(typeof ack === 'function', 'message: <code>ack</code> is a function.');",
        "assert(ack(0, 0) === 1, 'message: <code>ack(0, 0)</code> should return 1.');",
        "assert(ack(1, 1) === 3, 'message: <code>ack(1, 1)</code> should return 3.');",
        "assert(ack(2, 5) === 13, 'message: <code>ack(2, 5)</code> should return 13.');",
        "assert(ack(3, 3) === 61, 'message: <code>ack(3, 3)</code> should return 61.');"
      ],
      "id": 0
    },
    {
      "title": "Align columns",
      "type": "rosetta-code",
      "categories": "closures",
      "difficulty": "3",
      "description": [
        "Given a text file of many lines, where fields within a line are delineated by a single $ character, write a program that aligns each column of fields by ensuring that words in each column are separated by at least one space. Further, allow for each word in a column to be either left justified, right justified, or center justified within its column.",
        "<br clear=all>Use the following text to test your programs,",
        "<pre>Given$a$text$file$of$many$lines,$where$fields$within$a$line$",
        "are$delineated$by$a$single$'dollar'$character,$write$a$program",
        "that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$",
        "column$are$separated$by$at$least$one$space.",
        "Further,$allow$for$each$word$in$a$column$to$be$either$left$",
        "justified,$right$justified,$or$center$justified$within$its$column.</pre>",
        "Note that,",
        "1. The example input texts lines may, or may not, have trailing dollar characters.",
        "2. All columns should share the same alignment.",
        "3. Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.",
        "4. Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal.",
        "5. The minimum space between columns should be computed from the text and not hard-coded.",
        "6. It is not a requirement to add separating characters between or around columns."
      ],
      "challengeSeed": [
        "const testArr = [",
        "  'Given$a$text$file$of$many$lines',",
        "  'where$fields$within$a$line$',",
        "  'are$delineated$by$a$single$\"dollar\"$character',",
        "  'write$a$program',",
        "  'that$aligns$each$column$of$fields$',",
        "  'by$ensuring$that$words$in$each$',",
        "  'column$are$separated$by$at$least$one$space.',",
        "  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',",
        "  'justified,$right$justified',",
        "  'or$center$justified$within$its$column.'",
        "];",
        "",
        "function formatText (input, justification) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "const testArr = [\n  'Given$a$text$file$of$many$lines',\n  'where$fields$within$a$line$',\n  'are$delineated$by$a$single$\"dollar\"$character',\n  'write$a$program',\n  'that$aligns$each$column$of$fields$',\n  'by$ensuring$that$words$in$each$',\n  'column$are$separated$by$at$least$one$space.',\n  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',\n  'justified,$right$justified',\n  'or$center$justified$within$its$column.'\n];\n\nString.prototype.repeat = function (n) { return new Array(1 + parseInt(n)).join(this); };\n\nfunction formatText (input, justification) {\n  let x, y, max, cols = 0, diff, left, right;\n  for (x = 0; x < input.length; x++) {\n    input[x] = input[x].split('$');\n    if (input[x].length > cols) {\n      cols = input[x].length;\n    }\n  }\n  for (x = 0; x < cols; x++) {\n    max = 0;\n    for (y = 0; y < input.length; y++) {\n      if (input[y][x] && max < input[y][x].length) {\n        max = input[y][x].length;\n      }\n    }\n    for (y = 0; y < input.length; y++) {\n      if (input[y][x]) {\n        diff = (max - input[y][x].length) / 2;\n        left = ' '.repeat(Math.floor(diff));\n        right = ' '.repeat(Math.ceil(diff));\n        if (justification === 'left') {\n          right += left; left = '';\n        }\n        if (justification === 'right') {\n          left += right; right = '';\n        }\n        input[y][x] = left + input[y][x] + right;\n      }\n    }\n  }\n  for (x = 0; x < input.length; x++) {\n    input[x] = input[x].join(' ');\n  }\n  input = input.join('\\n');\n  return input;\n}\n"
      ],
      "tail": [
        "const testInput = [",
        "  'Given$a$text$file$of$many$lines',",
        "  'where$fields$within$a$line$',",
        "  'are$delineated$by$a$single$\"dollar\"$character',",
        "  'write$a$program',",
        "  'that$aligns$each$column$of$fields$',",
        "  'by$ensuring$that$words$in$each$',",
        "  'column$are$separated$by$at$least$one$space.',",
        "  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',",
        "  'justified,$right$justified',",
        "  'or$center$justified$within$its$column.'",
        "];",
        "",
        "const rightAligned = `     Given          a      text   file     of     many     lines",
        "     where     fields    within      a   line ",
        "       are delineated        by      a single \"dollar\" character",
        "     write          a   program",
        "      that     aligns      each column     of   fields ",
        "        by   ensuring      that  words     in     each ",
        "    column        are separated     by     at    least       one space.",
        "  Further,      allow       for   each   word       in         a column to be either left ",
        "justified,      right justified",
        "        or     center justified within    its  column.`;",
        "",
        "const leftAligned = `Given      a          text      file   of     many     lines    ",
        "where      fields     within    a      line   ",
        "are        delineated by        a      single \"dollar\" character",
        "write      a          program  ",
        "that       aligns     each      column of     fields   ",
        "by         ensuring   that      words  in     each     ",
        "column     are        separated by     at     least    one       space.",
        "Further,   allow      for       each   word   in       a         column to be either left ",
        "justified, right      justified",
        "or         center     justified within its    column. `;",
        "",
        "const centerAligned = `  Given        a        text     file    of     many     lines  ",
        "  where      fields    within     a     line  ",
        "   are     delineated    by       a    single \"dollar\" character",
        "  write        a       program ",
        "   that      aligns     each    column   of    fields  ",
        "    by      ensuring    that    words    in     each   ",
        "  column      are     separated   by     at    least      one    space.",
        " Further,    allow       for     each   word     in        a     column to be either left ",
        "justified,   right    justified",
        "    or       center   justified within  its   column. `;"
      ],
      "tests": [
        "assert(typeof formatText === 'function', 'message: <code>formatText</code> is a function.');",
        "assert.strictEqual(formatText(testInput, 'right'), rightAligned, 'message: <code>formatText</code> with the above input and \"right\" justification should produce the following: ');",
        "assert.strictEqual(formatText(testInput, 'left'), leftAligned, 'message: <code>formatText</code> with the above input and \"left\" justification should produce the following: ');",
        "assert.strictEqual(formatText(testInput, 'center'), centerAligned, 'message: <code>formatText</code> with the above input and \"center\" justification should produce the following: ');"
      ],
      "id": 0
    },
    {
      "title": "Happy numbers",
      "type": "rosetta-code",
      "categories": "?",
      "difficulty": "2",
      "description": [
        ";A happy number is defined by the following process:",
        "Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers, while those that do not end in 1 are unhappy numbers.",
        "Implement a function that returns true if the number is happy, or false if not."
      ],
      "challengeSeed": [
        "function happy (number) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function happy (number) {\n  let m;\n  let digit;\n  const cycle = [];\n\n  while (number !== 1 && cycle[number] !== true) {\n    cycle[number] = true;\n    m = 0;\n    while (number > 0) {\n      digit = number % 10;\n      m += digit ** 2;\n      number = (number - digit) / 10;\n    }\n    number = m;\n  }\n  return (number === 1);\n}\n"
      ],
      "tests": [
        "assert(typeof happy === 'function', 'message: <code>happy</code> is a function.');",
        "assert(typeof happy(1) === 'boolean', 'message: <code>happy(1)</code> should return a boolean.');",
        "assert.isTrue(happy(1), 'message: <code>happy(1)</code> should return true.');",
        "assert.isFalse(happy(2), 'message: <code>happy(2)</code> should return false.');",
        "assert.isTrue(happy(7), 'message: <code>happy(7)</code> should return true.');",
        "assert.isTrue(happy(10), 'message: <code>happy(10)</code> should return true.');",
        "assert.isTrue(happy(13), 'message: <code>happy(13)</code> should return true.');",
        "assert.isTrue(happy(19), 'message: <code>happy(19)</code> should return true.');",
        "assert.isTrue(happy(23), 'message: <code>happy(23)</code> should return true.');",
        "assert.isTrue(happy(28), 'message: <code>happy(28)</code> should return true.');",
        "assert.isTrue(happy(31), 'message: <code>happy(31)</code> should return true.');",
        "assert.isTrue(happy(32), 'message: <code>happy(32)</code> should return true:.');",
        "assert.isFalse(happy(33), 'message: <code>happy(33)</code> should return false.');"
      ],
      "id": 0
    },
    {
      "title": "Vector dot product",
      "type": "rosetta-code",
      "difficulty": "2",
      "categories": [
        "vector",
        "math"
      ],
      "description": "A vector is defined as having three dimensions as being represented by an ordered collection of three numbers: &nbsp; (X, Y, Z).",
      "Instructions": [
        "Write a function that takes any numbers of vectors (arrays) as",
        "input and computes their dot product. Your function should return <code>null</code> on",
        "invalid inputs (ie vectors of different lenghts)."
      ],
      "challengeSeed": [
        "function dotProduct() {",
        "    // Good luck!",
        "}"
      ],
      "solutions": [
        "function dotProduct(...vectors) {\n  if (!vectors || !vectors.length) {\n    return null;\n  }\n  if (!vectors[0] || !vectors[0].length) {\n    return null;\n  }\n  const vectorLen = vectors[0].length;\n  const numVectors = vectors.length;\n\n  // If all vectors not same length, return null\n  for (let i = 0; i < numVectors; i++) {\n    if (vectors[i].length !== vectorLen) {\n      return null;  // return undefined\n    }\n  }\n\n  let prod = 0;\n  let sum = 0;\n  let j = vectorLen;\n  let i = numVectors;\n  // Sum terms\n  while (j--) {\n    i = numVectors;\n    prod = 1;\n\n    while (i--) {\n      prod *= vectors[i][j];\n    }\n    sum += prod;\n  }\n  return sum;\n}\n"
      ],
      "tail": [
        "const vectors5x5 = [];",
        "for (let i = 0; i < 5; i++) {",
        "  vectors5x5[i] = [];",
        "  for (let j = 0; j < 5; j++) {",
        "    vectors5x5[i].push((i + 1) * j);",
        "  }",
        "}",
        "const vectorsWp = [[1, 3, -5], [4, -2, -1]];"
      ],
      "tests": [
        "assert.equal(typeof dotProduct, 'function', 'message: dotProduct must be a function');",
        "assert.equal(dotProduct(), null, 'message: dotProduct() must return null');",
        "assert.equal(dotProduct([1], [1]), 1, 'message: dotProduct([[1], [1]]) must return 1.');",
        "assert.equal(dotProduct([1], [1, 2]), null, 'message: dotProduct([[1], [1, 2]]) must return null.');",
        "assert.equal(dotProduct(...vectorsWp), 3, 'message: dotProduct([[1, 3, -5], [4, -2, -1]]) must return 3.');",
        "assert.equal(dotProduct(...vectors5x5), 156000);"
      ],
      "id": 0
    },
    {
      "title": "Word wrap",
      "difficulty": "2",
      "type": "rosetta-code",
      "categories": "strings",
      "description": [
        "Even today, with proportional fonts and complex layouts, there are still",
        "[[Template:Lines_too_long|cases]] where you need to wrap text at a specified",
        "column.  The basic task is to wrap a paragraph of text in a simple way.",
        "Example text:",
        "<pre>",
        "Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.",
        "If your language provides this, you get easy extra credit,",
        "but you ''must reference documentation'' indicating that the algorithm",
        "is something better than a simple minimimum length algorithm.",
        "</pre>",
        "can be wrapped to 80 characters as such:",
        "<pre>",
        "Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX",
        "algorithm. If your language provides this, you get easy extra credit, but you",
        "must reference documentation indicating that the algorithm is something better",
        "than a simple minimimum length algorithm.",
        "</pre>"
      ],
      "challengeSeed": [
        "function wrap (text, limit) {",
        "  return text;",
        "}"
      ],
      "solutions": [
        "function wrap (text, limit) {\n  const noNewlines = text.replace('\\n', '');\n  if (noNewlines.length > limit) {\n    // find the last space within limit\n    const edge = noNewlines.slice(0, limit).lastIndexOf(' ');\n    if (edge > 0) {\n      const line = noNewlines.slice(0, edge);\n      const remainder = noNewlines.slice(edge + 1);\n      return line + '\\n' + wrap(remainder, limit);\n    }\n  }\n  return text;\n}\n"
      ],
      "tail": [
        "const text =",
        "`Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.",
        "If your language provides this, you get easy extra credit,",
        "but you ''must reference documentation'' indicating that the algorithm",
        "is something better than a simple minimimum length algorithm.`;",
        "",
        "const wrapped80 = wrap(text, 80);",
        "const wrapped42 = wrap(text, 42);",
        "",
        "const firstRow80 =",
        "    'Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX';",
        "",
        "const firstRow42 = 'Wrap text using a more sophisticated';"
      ],
      "tests": [
        "assert.equal(typeof wrap, 'function', 'message: wrap must be a function.');",
        "assert.equal(typeof wrap('abc', 10), 'string', 'message: wrap must return a string.');",
        "assert(wrapped80.split('\\n').length === 4, 'message: wrap(80) must return 4 lines.');",
        "assert.equal(wrapped80.split('\\n')[0], firstRow80);",
        "assert(wrapped42.split('\\n').length === 7, 'message: wrap(42) must return 7 lines.');",
        "assert.equal(wrapped42.split('\\n')[0], firstRow42);"
      ],
      "id": 0
    },
    {
      "title": "Y combinator",
      "difficulty": "6",
      "type": "rosetta-code",
      "categories": "recursion",
      "description": [
        "In strict [[wp:Functional programming|functional programming]] and the",
        "[[wp:lambda calculus|lambda calculus]], functions (lambda expressions) don't",
        "have state and are only allowed to refer to arguments of enclosing functions.",
        "This rules out the usual definition of a recursive function wherein a function",
        "is associated with the state of a variable and this variable's state is used in",
        "the body of the function.",
        "///<br/>",
        "The <a href=\"http://mvanier.livejournal.com/2897.html\">Y combinator</a> is itself a",
        "stateless function that, when applied to another stateless function, returns a",
        "recursive version of the function. The Y combinator is the simplest of the",
        "class of such functions, called [[wp:Fixed-point combinator|fixed-point combinators]]."
      ],
      "Instructions": [
        "Define the stateless Y combinator function and use it to compute",
        "[[wp:Factorial|factorials]]. factorial(N) function is already given to you.",
        "See also <a href=\"http://vimeo.com/45140590\">Jim Weirich: Adventures in Functional Programming</a>."
      ],
      "challengeSeed": [
        "function Y(f) {",
        "  return function() {",
        "  // Good luck!",
        "  };",
        "}",
        "",
        "var factorial = Y(function(f) {",
        "  return function (n) {",
        "    return n > 1 ? n * f(n - 1) : 1;",
        "  };",
        "});"
      ],
      "solutions": [
        "var Y = f => (x => x(x))(y => f(x => y(y)(x)));\n"
      ],
      "tail": "var factorial = Y(f => n => (n > 1 ? n * f(n - 1) : 1));",
      "tests": [
        "assert.equal(typeof Y(f => n => n), 'function', 'message: Y must return a function');",
        "assert.equal(factorial(1), 1, 'message: factorial(1) must return 1.');",
        "assert.equal(factorial(2), 2, 'message: factorial(2) must return 2.');",
        "assert.equal(factorial(3), 6, 'message: factorial(3) must return 6.');",
        "assert.equal(factorial(4), 24, 'message: factorial(4) must return 24.');",
        "assert.equal(factorial(10), 3628800, 'message: factorial(10) must return 3628800.');"
      ],
      "id": 0
    },
    {
      "title": "Zeckendorf number representation",
      "type": "rosetta-code",
      "difficulty": "3",
      "description": [
        "Just as numbers can be represented in a positional notation as sums of multiples",
        "of the powers of ten (decimal) or two (binary); all the positive integers can be",
        "represented as the sum of one or zero times the distinct members of the",
        "Fibonacci series.<br/>",
        "Recall that the first six distinct Fibonacci numbers are:  1, 2, 3, 5, 8, 13.",
        "The decimal number eleven can be written as 0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1",
        "or 010100 in positional notation where the columns represent multiplication by a",
        " particular member of the sequence. Leading zeroes are dropped so that 11 decimal",
        "becomes 10100. <br/>",
        "10100 is not the only way to make 11 from the Fibonacci numbers however;  0*13 +",
        "<code>1*8 + 0*5 + 0*3 + 1*2 + 1*1</code> or 010011 would also represent decimal 11. For a",
        "true Zeckendorf number there is the added restriction that ''no two consecutive",
        "Fibonacci numbers can be used'' which leads to the former unique solution."
      ],
      "Instructions": [
        "Generate and show here a table of the Zeckendorf number representations of",
        "the decimal numbers zero to twenty, in order.",
        "The intention in this task to find the Zeckendorf form of an arbitrary integer.",
        "The Zeckendorf form can be iterated by some bit twiddling rather than",
        "calculating each value separately but leave that to another separate task."
      ],
      "challengeSeed": [
        "function zeckendorf(n) {",
        "  // good luck!",
        "}"
      ],
      "solutions": [
        "// zeckendorf :: Int -> String\nfunction zeckendorf(n) {\n  const f = (m, x) => (m < x ? [m, 0] : [m - x, 1]);\n  return (n === 0 ? ([0]) :\n    mapAccumL(f, n, reverse(\n      tail(fibUntil(n))\n    ))[1]).join('');\n}\n\n// fibUntil :: Int -> [Int]\nlet fibUntil = n => {\n  const xs = [];\n  until(\n      ([a]) => a > n,\n      ([a, b]) => (xs.push(a), [b, a + b]), [1, 1]\n  );\n  return xs;\n};\n\nlet mapAccumL = (f, acc, xs) => (\n  xs.reduce((a, x) => {\n    const pair = f(a[0], x);\n\n    return [pair[0], a[1].concat(pair[1])];\n  }, [acc, []])\n);\n\nlet until = (p, f, x) => {\n  let v = x;\n  while (!p(v)) v = f(v);\n  return v;\n};\n\nconst tail = xs => (\n   xs.length ? xs.slice(1) : undefined\n);\n\nconst reverse = xs => xs.slice(0).reverse();\n"
      ],
      "tail": [
        "const range = (m, n) => (",
        "  Array.from({",
        "    length: Math.floor(n - m) + 1",
        "  }, (_, i) => m + i)",
        ");",
        "",
        "const solution20 = [",
        "  '1', '10', '100', '101', '1000', '1001', '1010', '10000', '10001',",
        "  '10010', '10100', '10101', '100000', '100001', '100010', '100100', '100101',",
        "  '101000', '101001', '101010'",
        "];",
        "",
        "const answer = range(1, 20).map(zeckendorf);"
      ],
      "tests": [
        "assert.equal(typeof zeckendorf, 'function', 'message: zeckendorf must be function');",
        "assert.deepEqual(answer, solution20);"
      ],
      "id": 0
    },
    {
      "title": "Zhang-Suen thinning algorithm",
      "type": "rosetta-code",
      "difficulty": "7",
      "description": [
        "This is an algorithm used to thin a black and white i.e. one bit per pixel images.",
        "///<br/>",
        "For example, with an input image of:",
        "<pre>",
        " #################                   #############",
        " ##################               ################",
        " ###################            ##################",
        " ########     #######          ###################",
        "   ######     #######         #######       ######",
        "   ######     #######        #######",
        "   #################         #######",
        "   ################          #######",
        "   #################         #######",
        "   ######     #######        #######",
        "   ######     #######        #######",
        "   ######     #######         #######       ######",
        " ########     #######          ###################",
        " ########     ####### ######    ################## ######",
        " ########     ####### ######      ################ ######",
        " ########     ####### ######         ############# ######",
        "                                                           </pre>",
        "It produces the thinned output:",
        "<pre>",
        "///",
        "    # ##########                       #######",
        "     ##        #                   ####       #",
        "     #          #                 ##",
        "     #          #                #",
        "     #          #                #",
        "     #          #                #",
        "     ############               #",
        "     #          #               #",
        "     #          #                #",
        "     #          #                #",
        "     #          #                #",
        "     #                            ##",
        "     #                             ############",
        "                       ###                          ###",
        "///",
        "                                                           </pre>",
        "///<br/>",
        "<h2>Algorithm</h2>",
        "Assume black pixels are one and white pixels zero, and that the input image is a rectangular N by M array of ones and zeroes.",
        "///<br/>",
        "The algorithm operates on all black pixels P1 that can have eight neighbours. The neighbours are, in order, arranged as:",
        "<table border=\"1\">",
        "  <tr><td>P9</td><td>P2</td><td>P3</td></tr>",
        "  <tr><td>P8</td><td><b>P1</b></td><td>P4</td></tr>",
        "  <tr><td>P7</td><td>P6</td><td>P5</td></tr>",
        "</table>",
        "///<br/>",
        "Obviously the boundary pixels of the image cannot have the full eight neighbours.",
        "///<br/>",
        "* Define <math>A(P1)</math> = the number of transitions from white to black, (0 -> 1) in the sequence P2,P3,P4,P5,P6,P7,P8,P9,P2. (Note the extra P2 at the end - it is circular).",
        "* Define <math>B(P1)</math> = The number of black pixel neighbours of P1. ( = sum(P2 .. P9) )",
        "///<br/>",
        ";Step 1:",
        "All pixels are tested and pixels satisfying all the following conditions (simultaneously) are just noted at this stage.",
        "* (0) The pixel is black and has eight neighbours",
        "* (1) <math>2 <= B(P1) <= 6</math>",
        "* (2) A(P1) = 1",
        "* (3) At least one of P2 and P4 and P6 is white",
        "* (4) At least one of P4 and P6 and P8 is white",
        "After iterating over the image and collecting all the pixels satisfying all step 1 conditions, all these condition satisfying pixels are set to white.",
        "///<br/>",
        ";Step 2:",
        "All pixels are again tested and pixels satisfying all the following conditions are just noted at this stage.",
        "* (0) The pixel is black and has eight neighbours",
        "* (1) <math>2 <= B(P1) <= 6</math>",
        "* (2) A(P1) = 1",
        "* (3) At least one of P2 and P4 and '''P8''' is white",
        "* (4) At least one of '''P2''' and P6 and P8 is white",
        "After iterating over the image and collecting all the pixels satisfying all step 2 conditions, all these condition satisfying pixels are again set to white.",
        "///<br/>",
        ";Iteration:",
        "If any pixels were set in this round of either step 1 or step 2 then all steps are repeated until no image pixels are so changed.",
        "///<br/>",
        ";Task:",
        "# Write a routine to perform Zhang-Suen thinning on an image matrix of ones and zeroes."
      ],
      "challengeSeed": [
        "const testImage = [",
        "  '                                                          ',",
        "  ' #################                   #############        ',",
        "  ' ##################               ################        ',",
        "  ' ###################            ##################        ',",
        "  ' ########     #######          ###################        ',",
        "  '   ######     #######         #######       ######        ',",
        "  '   ######     #######        #######                      ',",
        "  '   #################         #######                      ',",
        "  '   ################          #######                      ',",
        "  '   #################         #######                      ',",
        "  '   ######     #######        #######                      ',",
        "  '   ######     #######        #######                      ',",
        "  '   ######     #######         #######       ######        ',",
        "  ' ########     #######          ###################        ',",
        "  ' ########     ####### ######    ################## ###### ',",
        "  ' ########     ####### ######      ################ ###### ',",
        "  ' ########     ####### ######         ############# ###### ',",
        "  '                                                          '];",
        "",
        "function thinImage(image) {",
        "  // Good luck!",
        "}"
      ],
      "solutions": [
        "function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nconst ZhangSuen = (function () {\n  function ZhangSuen() {\n  }\n\n  ZhangSuen.nbrs = [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1]];\n\n  ZhangSuen.nbrGroups = [[[0, 2, 4], [2, 4, 6]], [[0, 2, 6], [0, 4, 6]]];\n\n  ZhangSuen.toWhite = [];\n\n  ZhangSuen.main = function (image) {\n    ZhangSuen.grid = new Array(image);\n    for (let r = 0; r < image.length; r++) {\n      ZhangSuen.grid[r] = image[r].split('');\n    }\n    ZhangSuen.thinImage();\n    return ZhangSuen.getResult();\n  };\n\n  ZhangSuen.thinImage = function () {\n    let firstStep = false;\n    let hasChanged;\n    do {\n      hasChanged = false;\n      firstStep = !firstStep;\n      for (let r = 1; r < ZhangSuen.grid.length - 1; r++) {\n        for (let c = 1; c < ZhangSuen.grid[0].length - 1; c++) {\n          if (ZhangSuen.grid[r][c] !== '#') {\n            continue;\n          }\n          const nn = ZhangSuen.numNeighbors(r, c);\n          if (nn < 2 || nn > 6) {\n            continue;\n          }\n          if (ZhangSuen.numTransitions(r, c) !== 1) {\n            continue;\n          }\n          if (!ZhangSuen.atLeastOneIsWhite(r, c, firstStep ? 0 : 1)) {\n            continue;\n          }\n          ZhangSuen.toWhite.push(new Point(c, r));\n          hasChanged = true;\n        }\n      }\n      for (let i = 0; i < ZhangSuen.toWhite.length; i++) {\n        const p = ZhangSuen.toWhite[i];\n        ZhangSuen.grid[p.y][p.x] = ' ';\n      }\n      ZhangSuen.toWhite = [];\n    } while ((firstStep || hasChanged));\n  };\n\n  ZhangSuen.numNeighbors = function (r, c) {\n    let count = 0;\n    for (let i = 0; i < ZhangSuen.nbrs.length - 1; i++) {\n      if (ZhangSuen.grid[r + ZhangSuen.nbrs[i][1]][c + ZhangSuen.nbrs[i][0]] === '#') {\n        count++;\n      }\n    }\n    return count;\n  };\n\n  ZhangSuen.numTransitions = function (r, c) {\n    let count = 0;\n    for (let i = 0; i < ZhangSuen.nbrs.length - 1; i++) {\n      if (ZhangSuen.grid[r + ZhangSuen.nbrs[i][1]][c + ZhangSuen.nbrs[i][0]] === ' ') {\n        if (ZhangSuen.grid[r + ZhangSuen.nbrs[i + 1][1]][c + ZhangSuen.nbrs[i + 1][0]] === '#') {\n          count++;\n        }\n      }\n    }\n    return count;\n  };\n\n  ZhangSuen.atLeastOneIsWhite = function (r, c, step) {\n    let count = 0;\n    const group = ZhangSuen.nbrGroups[step];\n    for (let i = 0; i < 2; i++) {\n      for (let j = 0; j < group[i].length; j++) {\n        const nbr = ZhangSuen.nbrs[group[i][j]];\n        if (ZhangSuen.grid[r + nbr[1]][c + nbr[0]] === ' ') {\n          count++;\n          break;\n        }\n      }\n    }\n    return count > 1;\n  };\n\n  ZhangSuen.getResult = function () {\n    const result = [];\n    for (let i = 0; i < ZhangSuen.grid.length; i++) {\n      const row = ZhangSuen.grid[i].join('');\n      result.push(row);\n    }\n    return result;\n  };\n  return ZhangSuen;\n}());\n\nfunction thinImage(image) {\n  return ZhangSuen.main(image);\n}\n"
      ],
      "tail": [
        "",
        "const imageForTests = [",
        "  '                                                          ',",
        "  ' #################                   #############        ',",
        "  ' ##################               ################        ',",
        "  ' ###################            ##################        ',",
        "  ' ########     #######          ###################        ',",
        "  '   ######     #######         #######       ######        ',",
        "  '   ######     #######        #######                      ',",
        "  '   #################         #######                      ',",
        "  '   ################          #######                      ',",
        "  '   #################         #######                      ',",
        "  '   ######     #######        #######                      ',",
        "  '   ######     #######        #######                      ',",
        "  '   ######     #######         #######       ######        ',",
        "  ' ########     #######          ###################        ',",
        "  ' ########     ####### ######    ################## ###### ',",
        "  ' ########     ####### ######      ################ ###### ',",
        "  ' ########     ####### ######         ############# ###### ',",
        "  '                                                          '];",
        "const expected = [",
        "  '                                                          ',",
        "  '                                                          ',",
        "  '    # ##########                       #######            ',",
        "  '     ##        #                   ####       #           ',",
        "  '     #          #                 ##                      ',",
        "  '     #          #                #                        ',",
        "  '     #          #                #                        ',",
        "  '     #          #                #                        ',",
        "  '     ############               #                         ',",
        "  '     #          #               #                         ',",
        "  '     #          #                #                        ',",
        "  '     #          #                #                        ',",
        "  '     #          #                #                        ',",
        "  '     #                            ##                      ',",
        "  '     #                             ############           ',",
        "  '                       ###                          ###   ',",
        "  '                                                          ',",
        "  '                                                          '",
        "];",
        "const result = thinImage(imageForTests);"
      ],
      "tests": [
        "assert.equal(typeof thinImage, 'function', 'thinImage must be a function');",
        "assert.equal(typeof result, 'object', 'thinImage must return an array of strings');",
        "assert.equal(typeof result[0], 'string', 'thinImage must return an array of strings');",
        "assert.deepEqual(result, expected, 'thinImage must return an array of strings');"
      ],
      "id": 0
    },
    {
      "title": "Zig-zag matrix",
      "type": "rosetta-code",
      "difficulty": "3",
      "categories": "matrix",
      "description": [
        "A &nbsp; ''zig-zag'' &nbsp; array is a square arrangement of the first &nbsp;",
        "<big>N<sup>2</sup></big> &nbsp; integers, &nbsp; where the",
        "<br>numbers increase sequentially as you zig-zag along the array's &nbsp;",
        "<a href=\"https://en.wiktionary.org/wiki/antidiagonal\">anti-diagonals</a>.",
        "///<br/>",
        "For example, given &nbsp; '''5''', &nbsp; produce this array:",
        "<pre>",
        " 0  1  5  6 14",
        " 2  4  7 13 15",
        " 3  8 12 16 21",
        " 9 11 17 20 22",
        "10 18 19 23 24",
        "</pre>"
      ],
      "Instructions": [
        "Write a function that takes the size of the zig-zag matrix, and returns the",
        "corresponding matrix as two-dimensional array."
      ],
      "challengeSeed": [
        "function ZigZagMatrix(n) {",
        "  // Good luck!",
        "  return [[], []];",
        "}"
      ],
      "solutions": [
        "function ZigZagMatrix(n) {\n  const mtx = [];\n  for (let i = 0; i < n; i++) {\n    mtx[i] = [];\n  }\n\n  let i = 1;\n  let j = 1;\n  for (let e = 0; e < n * n; e++) {\n    mtx[i - 1][j - 1] = e;\n    if ((i + j) % 2 === 0) {\n      // Even stripes\n      if (j < n) j++;\n      else i += 2;\n      if (i > 1) i--;\n    } else {\n      // Odd stripes\n      if (i < n) i++;\n      else j += 2;\n      if (j > 1) j--;\n    }\n  }\n  return mtx;\n}\n"
      ],
      "tail": [
        "const zm1 = [[0]];",
        "const zm2 = [[0, 1], [2, 3]];",
        "const zm5 = [",
        "  [0, 1, 5, 6, 14],",
        "  [2, 4, 7, 13, 15],",
        "  [3, 8, 12, 16, 21],",
        "  [9, 11, 17, 20, 22],",
        "  [10, 18, 19, 23, 24]",
        "];"
      ],
      "tests": [
        "assert.equal(typeof ZigZagMatrix, 'function', 'message: ZigZagMatrix must be a function');",
        "assert.equal(typeof ZigZagMatrix(1), 'object', 'message: ZigZagMatrix should return array');",
        "assert.equal(typeof ZigZagMatrix(1)[0], 'object', 'message: ZigZagMatrix should return an array of nestes arrays');",
        "assert.deepEqual(ZigZagMatrix(1), zm1, 'message: ZigZagMatrix(1) should return [[0]]');",
        "assert.deepEqual(ZigZagMatrix(2), zm2, 'message: ZigZagMatrix(2) should return [[0, 1], [2, 3]]');",
        "assert.deepEqual(ZigZagMatrix(5), zm5, 'message: ZigZagMatrix(5) must return specified matrix');"
      ],
      "id": 0
    }
  ]
}