
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Execute a Markov algorithm
/// type: rosetta-code

/// categories:
/// ?

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// <br>
/// <br>
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Task:</dt></dl>
/// Create an interpreter for a <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Markov algorithm" title="wp: Markov algorithm">Markov Algorithm</a>. 
/// <br>
/// Rules have the syntax:
///  <ruleset> ::= ((<comment> | <rule>) <newline>+)*
///  <comment> ::= # {<any character>}
///  <rule> ::= <pattern> <whitespace> -> <whitespace> [.] <replacement>
///  <whitespace> ::= (<tab> | <space>) [<whitespace>]
/// There is one rule per line. 
/// <br>
/// If there is a &nbsp; <b>.</b> &nbsp; (period) &nbsp; present before the &nbsp; <span class="rosetta__text--bold"><replacement></span>, &nbsp; then this is a terminating rule in which case the interpreter must halt execution. 
/// <br>
/// A ruleset consists of a sequence of rules, with optional comments.
/// <br>
/// <br>
/// <big><big> Rulesets </big></big>
/// <br>
/// Use the following tests on entries:
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Ruleset 1:</dt></dl>
/// <pre>
/// # This rules file is extracted from Wikipedia:
/// # http://en.wikipedia.org/wiki/Markov_Algorithm
/// A -> apple
/// B -> bag
/// S -> shop
/// T -> the
/// the shop -> my brother
/// a never used -> .terminating rule
/// </pre>
/// Sample text of:
/// <span class="rosetta__text--indented"> <code> I bought a B of As from T S. </code></span>
/// Should generate the output:
/// <span class="rosetta__text--indented"> <code> I bought a bag of apples from my brother. </code></span>
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Ruleset 2:</dt></dl>
/// A test of the terminating rule
/// <pre>
/// # Slightly modified from the rules on Wikipedia
/// A -> apple
/// B -> bag
/// S -> .shop
/// T -> the
/// the shop -> my brother
/// a never used -> .terminating rule</pre>
/// Sample text of:
/// <span class="rosetta__text--indented"> <code>I bought a B of As from T S.</code></span>
/// Should generate:
/// <span class="rosetta__text--indented"> <code>I bought a bag of apples from T shop.</code></span>
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Ruleset 3:</dt></dl>
/// This tests for correct substitution order and may trap simple regexp based replacement routines if special regexp characters are not escaped.
/// <pre>
/// # BNF Syntax testing rules
/// A -> apple
/// WWWW -> with
/// Bgage -> ->.*
/// B -> bag
/// ->.* -> money
/// W -> WW
/// S -> .shop
/// T -> the
/// the shop -> my brother
/// a never used -> .terminating rule
/// </pre>
/// Sample text of:
/// <span class="rosetta__text--indented"> <code>I bought a B of As W my Bgage from T S.</code></span>
/// Should generate:
/// <span class="rosetta__text--indented"> <code>I bought a bag of apples with my money from T shop.</code></span>
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Ruleset 4:</dt></dl>
/// This tests for correct order of scanning of rules, and may trap replacement routines that scan in the wrong order. &nbsp; It implements a general unary multiplication engine. &nbsp; (Note that the input expression must be placed within underscores in this implementation.)
/// <pre>
/// ### Unary Multiplication Engine, for testing Markov Algorithm implementations
/// ### By Donal Fellows.
/// # Unary addition engine
/// _+1 -> _1+
/// 1+1 -> 11+
/// # Pass for converting from the splitting of multiplication into ordinary
/// # addition
/// 1! -> !1
/// ,! -> !+
/// _! -> _
/// # Unary multiplication by duplicating left side, right side times
/// 1*1 -> x,@y
/// 1x -> xX
/// X, -> 1,1
/// X1 -> 1X
/// _x -> _X
/// ,x -> ,X
/// y1 -> 1y
/// y_ -> _
/// # Next phase of applying
/// 1@1 -> x,@y
/// 1@_ -> @_
/// ,@_ -> !_
/// ++ -> +
/// # Termination cleanup for addition
/// _1 -> 1
/// 1+_ -> 1
/// _+_ -> 
/// </pre>
/// Sample text of:
/// <span class="rosetta__text--indented"> <code> _1111*11111_ </code></span>
/// should generate the output:
/// <span class="rosetta__text--indented"> <code> 11111111111111111111 </code></span>
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Ruleset 5:</dt></dl>
/// A simple [http://en.wikipedia.org/wiki/Turing_machine Turing machine], 
/// implementing a three-state [http://en.wikipedia.org/wiki/Busy_beaver busy beaver]. 
/// <br>
/// The tape consists of <span class="rosetta__text--bold">0</span>s and <span class="rosetta__text--bold">1</span>s, &nbsp; the states are <span class="rosetta__text--bold">A</span>, <span class="rosetta__text--bold">B</span>, <span class="rosetta__text--bold">C</span> and <span class="rosetta__text--bold">H</span> (for <span class="rosetta__text--bold">H</span>alt), and the head position is indicated by writing the state letter before the character where the head is. 
/// All parts of the initial tape the machine operates on have to be given in the input.
/// <br>
/// Besides demonstrating that the Markov algorithm is Turing-complete, it also made me catch a bug in the C++ implementation which wasn't caught by the first four rulesets.
/// <pre>
/// # Turing machine: three-state busy beaver
/// #
/// # state A, symbol 0 => write 1, move right, new state B
/// A0 -> 1B
/// # state A, symbol 1 => write 1, move left, new state C
/// 0A1 -> C01
/// 1A1 -> C11
/// # state B, symbol 0 => write 1, move left, new state A
/// 0B0 -> A01
/// 1B0 -> A11
/// # state B, symbol 1 => write 1, move right, new state B
/// B1 -> 1B
/// # state C, symbol 0 => write 1, move left, new state B
/// 0C0 -> B01
/// 1C0 -> B11
/// # state C, symbol 1 => write 1, move left, halt
/// 0C1 -> H01
/// 1C1 -> H11
/// </pre>
/// This ruleset should turn
/// <span class="rosetta__text--indented"> <code> 000000A000000 </code></span>
/// into
/// <span class="rosetta__text--indented"> <code> 00011H1111000 </code></span>
/// <br><br>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:


/// rawSolutions:
null

/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
