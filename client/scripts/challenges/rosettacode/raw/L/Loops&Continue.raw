
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Loops/Continue
/// type: rosetta-code

/// categories:
/// ?

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// [[Category:Loop modifiers]]
/// <br>
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Task:</dt></dl>
/// Show the following output using one loop. 
///  1, 2, 3, 4, 5
///  6, 7, 8, 9, 10
/// <br>
/// <br>
/// Try to achieve the result by forcing the next iteration within the loop 
/// upon a specific condition, if your language allows it.
/// <br><br>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:
var output = "";
for (var i = 1; i <= 10; i++) {
  output += i; 
  if (i % 5 == 0) {
    print(output);
    output = "";
    continue;
  } 
  output += ", ";
}

/// rawSolutions:
=={{header|JavaScript}}==
Using the <code>print()</code> function from [[Rhino]] or [[SpiderMonkey]].
<lang javascript>var output = "";
for (var i = 1; i <= 10; i++) {
  output += i; 
  if (i % 5 == 0) {
    print(output);
    output = "";
    continue;
  } 
  output += ", ";
}</lang>


Stepping back from any assumption that repetitive patterns of computation necessarily entail 'loops', and using a functional idiom of JavaScript, we can make the value of one or more subexpressions in a ''reduce()'' fold conditional on any special cases that we define.

For example:

<lang JavaScript>function rng(n) {
  return n ? rng(n - 1).concat(n) : [];
}

console.log(
  rng(10).reduce(
    function (a, x) {
      return a + x.toString() + (x % 5 ? ', ' : '\n');
    }, ''
  )
);</lang>

Output:
<lang JavaScript>1, 2, 3, 4, 5
6, 7, 8, 9, 10
</lang>



/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
