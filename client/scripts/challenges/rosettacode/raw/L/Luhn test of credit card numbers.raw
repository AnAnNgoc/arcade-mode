Luhn test of credit card numbers

{{task|Checksums}}
{{omit from|GUISS}}

The <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Luhn algorithm" title="wp: Luhn algorithm">Luhn test</a> is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.

Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:
#  Reverse the order of the digits in the number.
#  Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1
#  Taking the second, fourth ... and every other even digit in the reversed digits:
:#  Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits
:#  Sum the partial sums of the even digits to form s2
# If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.

<br>
For example, if the trial number is 49927398716:
<pre>Reverse the digits:
  61789372994
Sum the odd digits:
  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
The even digits:
    1,  8,  3,  2,  9
  Two times each even digit:
    2, 16,  6,  4, 18
  Sum the digits of each multiplication:
    2,  7,  6,  4,  9
  Sum the last:
    2 + 7 + 6 + 4 + 9 = 28 = s2

s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test</pre>


;Task:
Write a function/method/procedure/subroutine that will validate a number with the Luhn test, and 
<br>use it to validate the following numbers:
    49927398716
    49927398717
    1234567812345678
    1234567812345670

<br>
;Related tasks:
* &nbsp; <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/SEDOLs" title="SEDOLs">SEDOL</a>
* &nbsp; <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Calculate International Securities Identification Number" title="Calculate International Securities Identification Number">ISIN</a>
<br><br>


=={{header|JavaScript}}==
Using prototype.
<lang javascript>mod10check = function(cc) {
  return $A(cc).reverse().map(Number).inject(0, function(s, d, i) {
    return s + (i % 2 == 1 ? (d == 9 ? 9 : (d * 2) % 9) : d);
  }) % 10 == 0;
};
['49927398716','49927398717','1234567812345678','1234567812345670'].each(function(i){alert(mod10check(i))});</lang>

Without any library.
<lang javascript>var LuhnCheck = (function()
{
	var luhnArr = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];
	return function(str)
	{
		var counter = 0;
		var incNum;
		var odd = false;
		var temp = String(str).replace(/[^\d]/g, "");
		if ( temp.length == 0)
			return false;
		for (var i = temp.length-1; i >= 0; --i)
		{
			incNum = parseInt(temp.charAt(i), 10);
			counter += (odd = !odd)? incNum : luhnArr[incNum];
		}
		return (counter%10 == 0);
	}
})();</lang>
ES5.1 version (uses 'reduce' and 'reduceRight' Array methods).
<lang javascript>function luhn(str){
	return str.split('').reduceRight(function(prev, curr, idx){
		prev = parseInt(prev, 10);
		if ((idx + 1) % 2 !== 0) {
			curr = (curr * 2).toString().split('').reduce(function(p, c){ return parseInt(p, 10) + parseInt(c, 10)});
		}
		return prev + parseInt(curr, 10);
	}) % 10 === 0;
}</lang>

Highly compressed version.
<lang javascript>var luhn10 = function(a,b,c,d,e) {
  for(d = +a[b = a.length-1], e=0; b--;)
    c = +a[b], d += ++e % 2 ? 2 * c % 10 + (c > 4) : c;
  return !(d%10)
};

// returns true
luhn10('4111111111111111') 

// returns false
luhn10('4111111111111112') 
</lang>

