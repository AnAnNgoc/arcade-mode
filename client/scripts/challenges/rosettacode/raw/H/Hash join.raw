
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Hash join
/// type: rosetta-code

/// categories:
/// ?

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// <br>
/// An <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Join_(SQL)#Inner_join" title="wp: Join_(SQL)#Inner_join">inner join]] is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the [[wp:Nested loop join|nested loop join]] algorithm, but a more scalable alternative is the [[wp:hash join|hash join</a> algorithm.
/// <br>
/// <br>
/// <br>
/// Implement the "hash join" algorithm, and demonstrate that it passes the test-case listed below.
/// <br>
/// You should represent the tables as data structures that feel natural in your programming language.
/// <br>
/// <br>
/// <br>
/// The "hash join" algorithm consists of two steps:
/// <br>
/// # <span class="rosetta__text--bold">Hash phase:</span> Create a <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Multimap" title="wp: Multimap">multimap</a> from one of the two tables, mapping from each join column value to all the rows that contain it.<br>
/// #* The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.
/// #* Ideally we should create the multimap for the <span class="rosetta__text--italic">smaller</span> table, thus minimizing its creation time and memory size.
/// # <span class="rosetta__text--bold">Join phase:</span> Scan the other table, and find matching rows by looking in the multimap created before.
/// <br>
/// <br>
/// In pseudo-code, the algorithm could be expressed as follows:
/// <br>
///  <span class="rosetta__text--bold">let</span> <span class="rosetta__text--italic">A</span> = the first input table (or ideally, the larger one)
///  <span class="rosetta__text--bold">let</span> <span class="rosetta__text--italic">B</span> = the second input table (or ideally, the smaller one)
///  <span class="rosetta__text--bold">let</span> <span class="rosetta__text--italic">j<sub>A</sub></span> = the join column ID of table <span class="rosetta__text--italic">A</span>
///  <span class="rosetta__text--bold">let</span> <span class="rosetta__text--italic">j<sub>B</sub></span> = the join column ID of table <span class="rosetta__text--italic">B</span>
///  <span class="rosetta__text--bold">let</span> <span class="rosetta__text--italic">M<sub>B</sub></span> = a multimap for mapping from single values to multiple rows of table <span class="rosetta__text--italic">B</span> (starts out empty)
///  <span class="rosetta__text--bold">let</span> <span class="rosetta__text--italic">C</span> = the output table (starts out empty)
///  
///  <span class="rosetta__text--bold">for each</span> row <span class="rosetta__text--italic">b</span> <span class="rosetta__text--bold">in</span> table <span class="rosetta__text--italic">B<span class="rosetta__text--bold"></span>:</span>
///     <span class="rosetta__text--bold">place</span> <span class="rosetta__text--italic">b</span> <span class="rosetta__text--bold">in</span> multimap <span class="rosetta__text--italic">M<sub>B</sub></span> under key <span class="rosetta__text--italic">b</span>(<span class="rosetta__text--italic">j<sub>B</sub></span>)
///  
///  <span class="rosetta__text--bold">for each</span> row <span class="rosetta__text--italic">a</span> <span class="rosetta__text--bold">in</span> table <span class="rosetta__text--italic">A<span class="rosetta__text--bold"></span>:</span>
///     <span class="rosetta__text--bold">for each</span> row <span class="rosetta__text--italic">b</span> <span class="rosetta__text--bold">in</span> multimap <span class="rosetta__text--italic">M<sub>B</sub></span> under key <span class="rosetta__text--italic">a</span>(<span class="rosetta__text--italic">j<sub>A</sub></span>)<span class="rosetta__text--bold">:</span>
///        <span class="rosetta__text--bold">let</span> <span class="rosetta__text--italic">c</span> = the concatenation of row <span class="rosetta__text--italic">a</span> and row <span class="rosetta__text--italic">b</span>
///        <span class="rosetta__text--bold">place</span> row <span class="rosetta__text--italic">c</span> in table <span class="rosetta__text--italic">C</span>
/// <br>
/// <br>
/// <br>
/// {| class="wikitable"
/// |-
/// ! Input
/// ! Output
/// |-
/// |
/// <br>
/// {| style="border:none; border-collapse:collapse;"
/// |-
/// | style="border:none" | <span class="rosetta__text--italic">A</span> = 
/// | style="border:none" |
/// <br>
/// {| class="wikitable"
/// |-
/// ! Age !! Name
/// |-
/// | 27 || Jonah
/// |-
/// | 18 || Alan
/// |-
/// | 28 || Glory
/// |-
/// | 18 || Popeye
/// |-
/// | 28 || Alan
/// |}
/// <br>
/// | style="border:none; padding-left:1.5em;" rowspan="2" |
/// | style="border:none" | <span class="rosetta__text--italic">B</span> = 
/// | style="border:none" |
/// <br>
/// {| class="wikitable"
/// |-
/// ! Character !! Nemesis
/// |-
/// | Jonah || Whales
/// |-
/// | Jonah || Spiders
/// |-
/// | Alan || Ghosts
/// |-
/// | Alan || Zombies
/// |-
/// | Glory || Buffy
/// |}
/// <br>
/// |-
/// | style="border:none" | <span class="rosetta__text--italic">j<sub>A</sub></span> =
/// | style="border:none" | <code>Name</code> (i.e. column 1)
/// <br>
/// | style="border:none" | <span class="rosetta__text--italic">j<sub>B</sub></span> =
/// | style="border:none" | <code>Character</code> (i.e. column 0)
/// |}
/// <br>
/// |
/// <br>
/// {| class="wikitable" style="margin-left:1em"
/// |-
/// ! A.Age !! A.Name !! B.Character !! B.Nemesis
/// |-
/// | 27 || Jonah || Jonah || Whales
/// |-
/// | 27 || Jonah || Jonah || Spiders
/// |-
/// | 18 || Alan || Alan || Ghosts
/// |-
/// | 18 || Alan || Alan || Zombies
/// |-
/// | 28 || Glory || Glory || Buffy
/// |-
/// | 28 || Alan || Alan || Ghosts
/// |-
/// | 28 || Alan || Alan || Zombies
/// |}
/// <br>
/// |}
/// <br>
/// The order of the rows in the output table is not significant.<br>
/// If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form <code style="white-space:nowrap">[[27, "Jonah"], ["Jonah", "Whales"]]</code>.
/// <br>
/// <br><hr>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:
(() => {
    'use strict';

    // hashJoin :: [Dict] -> [Dict] -> String -> [Dict]
    let hashJoin = (tblA, tblB, strJoin) => {

        let [jA, jB] = strJoin.split('='),
            M = tblB.reduce((a, x) => {
                let id = x[jB];
                return (
                    a[id] ? a[id].push(x) : a[id] = [x],
                    a
                );
            }, {});

        return tblA.reduce((a, x) => {
            let match = M[x[jA]];
            return match ? (
                a.concat(match.map(row => dictConcat(x, row)))
            ) : a;
        }, []);
    },

    // dictConcat :: Dict -> Dict -> Dict
    dictConcat = (dctA, dctB) => {
        let ok = Object.keys;
        return ok(dctB).reduce(
            (a, k) => (a['B_' + k] = dctB[k]) && a,
            ok(dctA).reduce(
                (a, k) => (a['A_' + k] = dctA[k]) && a, {}
            )
        );
    };


    // TEST
    let lstA = [
        { age: 27, name: 'Jonah' },
        { age: 18, name: 'Alan' },
        { age: 28, name: 'Glory' },
        { age: 18, name: 'Popeye' },
        { age: 28, name: 'Alan' }
    ],
    lstB = [
        { character: 'Jonah', nemesis: 'Whales' },
        { character: 'Jonah', nemesis: 'Spiders' },
        { character: 'Alan', nemesis: 'Ghosts' },
        { character:'Alan', nemesis: 'Zombies' },
        { character: 'Glory', nemesis: 'Buffy' },
        { character: 'Bob', nemesis: 'foo' }
    ];

    return hashJoin(lstA, lstB, 'name=character');
    
})();


/// rawSolutions:
=={{header|JavaScript}}==
===ES6===

<lang JavaScript>(() => {
    'use strict';

    // hashJoin :: [Dict] -> [Dict] -> String -> [Dict]
    let hashJoin = (tblA, tblB, strJoin) => {

        let [jA, jB] = strJoin.split('='),
            M = tblB.reduce((a, x) => {
                let id = x[jB];
                return (
                    a[id] ? a[id].push(x) : a[id] = [x],
                    a
                );
            }, {});

        return tblA.reduce((a, x) => {
            let match = M[x[jA]];
            return match ? (
                a.concat(match.map(row => dictConcat(x, row)))
            ) : a;
        }, []);
    },

    // dictConcat :: Dict -> Dict -> Dict
    dictConcat = (dctA, dctB) => {
        let ok = Object.keys;
        return ok(dctB).reduce(
            (a, k) => (a['B_' + k] = dctB[k]) && a,
            ok(dctA).reduce(
                (a, k) => (a['A_' + k] = dctA[k]) && a, {}
            )
        );
    };


    // TEST
    let lstA = [
        { age: 27, name: 'Jonah' },
        { age: 18, name: 'Alan' },
        { age: 28, name: 'Glory' },
        { age: 18, name: 'Popeye' },
        { age: 28, name: 'Alan' }
    ],
    lstB = [
        { character: 'Jonah', nemesis: 'Whales' },
        { character: 'Jonah', nemesis: 'Spiders' },
        { character: 'Alan', nemesis: 'Ghosts' },
        { character:'Alan', nemesis: 'Zombies' },
        { character: 'Glory', nemesis: 'Buffy' },
        { character: 'Bob', nemesis: 'foo' }
    ];

    return hashJoin(lstA, lstB, 'name=character');
    
})();
</lang>

{{Out}}
<pre>[{"A_age":27,"A_name":"Jonah","B_character":"Jonah","B_nemesis":"Whales"},
{"A_age":27,"A_name":"Jonah","B_character":"Jonah","B_nemesis":"Spiders"},
{"A_age":18,"A_name":"Alan","B_character":"Alan","B_nemesis":"Ghosts"},
{"A_age":18,"A_name":"Alan","B_character":"Alan","B_nemesis":"Zombies"},
{"A_age":28,"A_name":"Glory","B_character":"Glory","B_nemesis":"Buffy"},
{"A_age":28,"A_name":"Alan","B_character":"Alan","B_nemesis":"Ghosts"},
{"A_age":28,"A_name":"Alan","B_character":"Alan","B_nemesis":"Zombies"}]</pre>



/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
