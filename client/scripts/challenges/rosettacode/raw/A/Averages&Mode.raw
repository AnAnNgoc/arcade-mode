Averages/Mode

{{task|Probability and statistics}}

{{task heading}}

Write a program to find the <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Mode (statistics)" title="wp: Mode (statistics)">mode</a> value of a collection. 

The case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.

If it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.

{{task heading|See also}}

{{Related tasks/Statistical measures}}

<hr>

=={{Header|ActionScript}}==
This implementation does not work with arbitrary collections. However, it works with arrays containing mixed data, including strings and other arrays.
<lang ActionScript>function Mode(arr:Array):Array {
	//Create an associative array to count how many times each element occurs,
	//an array to contain the modes, and a variable to store how many times each mode appears.
	var count:Array = new Array();
	var modeList:Array;
	var maxCount:uint=0;
	for (var i:String in arr) {
		//Record how many times an element has occurred. Note that each element in the cuont array
		//has to be initialized explicitly, since it is an associative array.
		if (count[arr[i]]==undefined) {
			count[arr[i]]=1;
		} else {
			count[arr[i]]++;
		}
		//If this is now the most common element, clear the list of modes, and add this element.
		if(count[arr[i]] > maxCount)
		{
			maxCount=count[arr[i]];
			modeList = new Array();
			modeList.push(arr[i]);
		}
		//If this is a mode, add it to the list.
		else if(count[arr[i]] == maxCount){
			modeList.push(arr[i]);
		}
	}
	return modeList;
}</lang>

=={{Header|Ada}}==
{{works with|Ada 2005}}
mode.ads:
<lang Ada>generic
   type Element_Type is private;
   type Element_Array is array (Positive range <>) of Element_Type;
package Mode is

   function Get_Mode (Set : Element_Array) return Element_Array;

end Mode;</lang>
mode.adb:
<lang Ada>with Ada.Containers.Indefinite_Vectors;

package body Mode is

   -- map Count to Elements
   package Count_Vectors is new Ada.Containers.Indefinite_Vectors
     (Element_Type => Element_Array,
      Index_Type => Positive);

   procedure Add (To : in out Count_Vectors.Vector; Item : Element_Type) is
      use type Count_Vectors.Cursor;
      Position : Count_Vectors.Cursor := To.First;
      Found    : Boolean              := False;
   begin
      while not Found and then Position /= Count_Vectors.No_Element loop
         declare
            Elements : Element_Array := Count_Vectors.Element (Position);
         begin
            for I in Elements'Range loop
               if Elements (I) = Item then
                  Found := True;
               end if;
            end loop;
         end;
         if not Found then
            Position := Count_Vectors.Next (Position);
         end if;
      end loop;
      if Position /= Count_Vectors.No_Element then
         -- element found, remove it and insert to next count
         declare
            New_Position : Count_Vectors.Cursor :=
               Count_Vectors.Next (Position);
         begin
            -- remove from old position
            declare
               Old_Elements : Element_Array :=
                  Count_Vectors.Element (Position);
               New_Elements : Element_Array (1 .. Old_Elements'Length - 1);
               New_Index    : Positive      := New_Elements'First;
            begin
               for I in Old_Elements'Range loop
                  if Old_Elements (I) /= Item then
                     New_Elements (New_Index) := Old_Elements (I);
                     New_Index                := New_Index + 1;
                  end if;
               end loop;
               To.Replace_Element (Position, New_Elements);
            end;
            -- new position not already there?
            if New_Position = Count_Vectors.No_Element then
               declare
                  New_Array : Element_Array (1 .. 1) := (1 => Item);
               begin
                  To.Append (New_Array);
               end;
            else
               -- add to new position
               declare
                  Old_Elements : Element_Array :=
                     Count_Vectors.Element (New_Position);
                  New_Elements : Element_Array (1 .. Old_Elements'Length + 1);
               begin
                  New_Elements (1 .. Old_Elements'Length) := Old_Elements;
                  New_Elements (New_Elements'Last)        := Item;
                  To.Replace_Element (New_Position, New_Elements);
               end;
            end if;
         end;
      else
         -- element not found, add to count 1
         Position := To.First;
         if Position = Count_Vectors.No_Element then
            declare
               New_Array : Element_Array (1 .. 1) := (1 => Item);
            begin
               To.Append (New_Array);
            end;
         else
            declare
               Old_Elements : Element_Array :=
                  Count_Vectors.Element (Position);
               New_Elements : Element_Array (1 .. Old_Elements'Length + 1);
            begin
               New_Elements (1 .. Old_Elements'Length) := Old_Elements;
               New_Elements (New_Elements'Last)        := Item;
               To.Replace_Element (Position, New_Elements);
            end;
         end if;
      end if;
   end Add;

   function Get_Mode (Set : Element_Array) return Element_Array is
      Counts : Count_Vectors.Vector;
   begin
      for I in Set'Range loop
         Add (Counts, Set (I));
      end loop;
      return Counts.Last_Element;
   end Get_Mode;

end Mode;</lang>
example use:
<lang Ada>with Ada.Text_IO;
with Mode;
procedure Main is
   type Int_Array is array (Positive range <>) of Integer;
   package Int_Mode is new Mode (Integer, Int_Array);

   Test_1 : Int_Array := (1, 2, 3, 1, 2, 4, 2, 5, 2, 3, 3, 1, 3, 6);
   Result : Int_Array := Int_Mode.Get_Mode (Test_1);
begin
   Ada.Text_IO.Put ("Input: ");
   for I in Test_1'Range loop
      Ada.Text_IO.Put (Integer'Image (Test_1 (I)));
      if I /= Test_1'Last then
         Ada.Text_IO.Put (",");
      end if;
   end loop;
   Ada.Text_IO.New_Line;
   Ada.Text_IO.Put ("Result:");
   for I in Result'Range loop
      Ada.Text_IO.Put (Integer'Image (Result (I)));
      if I /= Result'Last then
         Ada.Text_IO.Put (",");
      end if;
   end loop;
   Ada.Text_IO.New_Line;
end Main;</lang>
{{out}}
<pre>Input:  1, 2, 3, 1, 2, 4, 2, 5, 2, 3, 3, 1, 3, 6
Result: 2, 3</pre>

=={{Header|APL}}==
<lang APL>mode←{{s←⌈/⍵[;2]⋄⊃¨(↓⍵)∩{⍵,s}¨⍵[;1]}{⍺,≢⍵}⌸⍵}</lang>

=={{Header|AutoHotkey}}==
{{AutoHotkey case}}
Source: [http://www.autohotkey.com/forum/post-276175.html#276175 AutoHotkey forum] by Laszlo
<lang autohotkey>MsgBox % Mode("1 2 3") 
MsgBox % Mode("1 2 0 3 0.0") 
MsgBox % Mode("0.1 2.2 -0.1 0.22e1 2.20 0.1") 

Mode(a, d=" ") { ; the number that occurs most frequently in a list delimited by d (space) 
   Sort a, ND%d% 
   Loop Parse, a, %d% 
      If (V != A_LoopField) { 
         If (Ct > MxCt) 
            MxV := V, MxCt := Ct 
         V := A_LoopField, Ct := 1 
      } 
      Else Ct++ 
   Return Ct>MxCt ? V : MxV 
}</lang>


=={{header|JavaScript}}==
<lang javascript>function mode(ary) {
    var counter = {};
    var mode = [];
    var max = 0;
    for (var i in ary) {
        if (!(ary[i] in counter))
            counter[ary[i]] = 0;
        counter[ary[i]]++;

        if (counter[ary[i]] == max) 
            mode.push(ary[i]);
        else if (counter[ary[i]] > max) {
            max = counter[ary[i]];
            mode = [ary[i]];
        }
    }
    return mode; 
}

mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]);  // [6]
mode([1, 2, 4, 4, 1]);  // [1,4]</lang>

