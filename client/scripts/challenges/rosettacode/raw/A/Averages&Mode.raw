
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Averages/Mode
/// type: rosetta-code

/// categories:


/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// <br>
/// <br>
/// <br>
/// Write a program to find the <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Mode (statistics)" title="wp: Mode (statistics)">mode</a> value of a collection. 
/// <br>
/// The case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.
/// <br>
/// If it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.
/// <br>
/// <br>
/// <br>
/// <br>
/// <br>
/// <hr>
/// <br>
/// ====
/// This implementation does not work with arbitrary collections. However, it works with arrays containing mixed data, including strings and other arrays.
/// <lang ActionScript>function Mode(arr:Array):Array {
/// 	//Create an associative array to count how many times each element occurs,
/// 	//an array to contain the modes, and a variable to store how many times each mode appears.
/// 	var count:Array = new Array();
/// 	var modeList:Array;
/// 	var maxCount:uint=0;
/// 	for (var i:String in arr) {
/// 		//Record how many times an element has occurred. Note that each element in the cuont array
/// 		//has to be initialized explicitly, since it is an associative array.
/// 		if (count[arr[i]]==undefined) {
/// 			count[arr[i]]=1;
/// 		} else {
/// 			count[arr[i]]++;
/// 		}
/// 		//If this is now the most common element, clear the list of modes, and add this element.
/// 		if(count[arr[i]] > maxCount)
/// 		{
/// 			maxCount=count[arr[i]];
/// 			modeList = new Array();
/// 			modeList.push(arr[i]);
/// 		}
/// 		//If this is a mode, add it to the list.
/// 		else if(count[arr[i]] == maxCount){
/// 			modeList.push(arr[i]);
/// 		}
/// 	}
/// 	return modeList;
/// }</lang>
/// <br>
/// ====
/// <br>
/// mode.ads:
/// <lang Ada>generic
///    type Element_Type is private;
///    type Element_Array is array (Positive range <>) of Element_Type;
/// package Mode is
/// <br>
///    function Get_Mode (Set : Element_Array) return Element_Array;
/// <br>
/// end Mode;</lang>
/// mode.adb:
/// <lang Ada>with Ada.Containers.Indefinite_Vectors;
/// <br>
/// package body Mode is
/// <br>
///    -- map Count to Elements
///    package Count_Vectors is new Ada.Containers.Indefinite_Vectors
///      (Element_Type => Element_Array,
///       Index_Type => Positive);
/// <br>
///    procedure Add (To : in out Count_Vectors.Vector; Item : Element_Type) is
///       use type Count_Vectors.Cursor;
///       Position : Count_Vectors.Cursor := To.First;
///       Found    : Boolean              := False;
///    begin
///       while not Found and then Position /= Count_Vectors.No_Element loop
///          declare
///             Elements : Element_Array := Count_Vectors.Element (Position);
///          begin
///             for I in Elements'Range loop
///                if Elements (I) = Item then
///                   Found := True;
///                end if;
///             end loop;
///          end;
///          if not Found then
///             Position := Count_Vectors.Next (Position);
///          end if;
///       end loop;
///       if Position /= Count_Vectors.No_Element then
///          -- element found, remove it and insert to next count
///          declare
///             New_Position : Count_Vectors.Cursor :=
///                Count_Vectors.Next (Position);
///          begin
///             -- remove from old position
///             declare
///                Old_Elements : Element_Array :=
///                   Count_Vectors.Element (Position);
///                New_Elements : Element_Array (1 .. Old_Elements'Length - 1);
///                New_Index    : Positive      := New_Elements'First;
///             begin
///                for I in Old_Elements'Range loop
///                   if Old_Elements (I) /= Item then
///                      New_Elements (New_Index) := Old_Elements (I);
///                      New_Index                := New_Index + 1;
///                   end if;
///                end loop;
///                To.Replace_Element (Position, New_Elements);
///             end;
///             -- new position not already there?
///             if New_Position = Count_Vectors.No_Element then
///                declare
///                   New_Array : Element_Array (1 .. 1) := (1 => Item);
///                begin
///                   To.Append (New_Array);
///                end;
///             else
///                -- add to new position
///                declare
///                   Old_Elements : Element_Array :=
///                      Count_Vectors.Element (New_Position);
///                   New_Elements : Element_Array (1 .. Old_Elements'Length + 1);
///                begin
///                   New_Elements (1 .. Old_Elements'Length) := Old_Elements;
///                   New_Elements (New_Elements'Last)        := Item;
///                   To.Replace_Element (New_Position, New_Elements);
///                end;
///             end if;
///          end;
///       else
///          -- element not found, add to count 1
///          Position := To.First;
///          if Position = Count_Vectors.No_Element then
///             declare
///                New_Array : Element_Array (1 .. 1) := (1 => Item);
///             begin
///                To.Append (New_Array);
///             end;
///          else
///             declare
///                Old_Elements : Element_Array :=
///                   Count_Vectors.Element (Position);
///                New_Elements : Element_Array (1 .. Old_Elements'Length + 1);
///             begin
///                New_Elements (1 .. Old_Elements'Length) := Old_Elements;
///                New_Elements (New_Elements'Last)        := Item;
///                To.Replace_Element (Position, New_Elements);
///             end;
///          end if;
///       end if;
///    end Add;
/// <br>
///    function Get_Mode (Set : Element_Array) return Element_Array is
///       Counts : Count_Vectors.Vector;
///    begin
///       for I in Set'Range loop
///          Add (Counts, Set (I));
///       end loop;
///       return Counts.Last_Element;
///    end Get_Mode;
/// <br>
/// end Mode;</lang>
/// example use:
/// <lang Ada>with Ada.Text_IO;
/// with Mode;
/// procedure Main is
///    type Int_Array is array (Positive range <>) of Integer;
///    package Int_Mode is new Mode (Integer, Int_Array);
/// <br>
///    Test_1 : Int_Array := (1, 2, 3, 1, 2, 4, 2, 5, 2, 3, 3, 1, 3, 6);
///    Result : Int_Array := Int_Mode.Get_Mode (Test_1);
/// begin
///    Ada.Text_IO.Put ("Input: ");
///    for I in Test_1'Range loop
///       Ada.Text_IO.Put (Integer'Image (Test_1 (I)));
///       if I /= Test_1'Last then
///          Ada.Text_IO.Put (",");
///       end if;
///    end loop;
///    Ada.Text_IO.New_Line;
///    Ada.Text_IO.Put ("Result:");
///    for I in Result'Range loop
///       Ada.Text_IO.Put (Integer'Image (Result (I)));
///       if I /= Result'Last then
///          Ada.Text_IO.Put (",");
///       end if;
///    end loop;
///    Ada.Text_IO.New_Line;
/// end Main;</lang>
/// <br>
/// <pre>Input:  1, 2, 3, 1, 2, 4, 2, 5, 2, 3, 3, 1, 3, 6
/// Result: 2, 3</pre>
/// <br>
/// ====
/// <lang APL>mode←{{s←⌈/⍵[;2]⋄⊃¨(↓⍵)∩{⍵,s}¨⍵[;1]}{⍺,≢⍵}⌸⍵}</lang>
/// <br>
/// ====
/// <br>
/// Source: [http://www.autohotkey.com/forum/post-276175.html#276175 AutoHotkey forum] by Laszlo
/// <lang autohotkey>MsgBox % Mode("1 2 3") 
/// MsgBox % Mode("1 2 0 3 0.0") 
/// MsgBox % Mode("0.1 2.2 -0.1 0.22e1 2.20 0.1") 
/// <br>
/// Mode(a, d=" ") { ; the number that occurs most frequently in a list delimited by d (space) 
///    Sort a, ND%d% 
///    Loop Parse, a, %d% 
///       If (V != A_LoopField) { 
///          If (Ct > MxCt) 
///             MxV := V, MxCt := Ct 
///          V := A_LoopField, Ct := 1 
///       } 
///       Else Ct++ 
///    Return Ct>MxCt ? V : MxV 
/// }</lang>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:
function mode(ary) {
    var counter = {};
    var mode = [];
    var max = 0;
    for (var i in ary) {
        if (!(ary[i] in counter))
            counter[ary[i]] = 0;
        counter[ary[i]]++;

        if (counter[ary[i]] == max) 
            mode.push(ary[i]);
        else if (counter[ary[i]] > max) {
            max = counter[ary[i]];
            mode = [ary[i]];
        }
    }
    return mode; 
}

mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]);  // [6]
mode([1, 2, 4, 4, 1]);  // [1,4]

/// rawSolutions:
=={{header|JavaScript}}==
<lang javascript>function mode(ary) {
    var counter = {};
    var mode = [];
    var max = 0;
    for (var i in ary) {
        if (!(ary[i] in counter))
            counter[ary[i]] = 0;
        counter[ary[i]]++;

        if (counter[ary[i]] == max) 
            mode.push(ary[i]);
        else if (counter[ary[i]] > max) {
            max = counter[ary[i]];
            mode = [ary[i]];
        }
    }
    return mode; 
}

mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]);  // [6]
mode([1, 2, 4, 4, 1]);  // [1,4]</lang>



/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
