
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Test integerness
/// type: rosetta-code

/// categories:


/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// <br>
/// Mathematically,
/// <ul class="rosetta__unordered-list">
/// <li class="rosetta__list-item--unordered">the <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Integer" title="wp: Integer">integers]] <span class="rosetta__text--bold">Z</span> are included in the [[wp:Rational number|rational numbers</a> <span class="rosetta__text--bold">Q</span>,</li>
/// <li class="rosetta__list-item--unordered">which are included in the <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Real number" title="wp: Real number">real numbers</a> <span class="rosetta__text--bold">R</span>,</li>
/// <li class="rosetta__list-item--unordered">which can be generalized to the <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Complex number" title="wp: Complex number">complex numbers</a> <span class="rosetta__text--bold">C</span>.</li>
/// <br>
/// </ul>
/// <br>
/// This means that each of those larger sets, and the data types used to represent them, include some integers.
/// <br>
/// <br>
/// <br>
/// Given a rational, real, or complex number of any type, test whether it is mathematically an integer.
/// <br>
/// Your code should handle all numeric data types commonly used in your programming language.
/// <br>
/// Discuss any limitations of your code.
/// <br>
/// <br>
/// <br>
/// For the purposes of this task, integerness means that a number could theoretically be represented as an integer at no loss of precision <span class="rosetta__text--italic"><small>(given an infinitely wide integer type)</small></span>.<br>
/// In other words:
/// <br>
/// {| class="wikitable"
/// |-
/// ! Set
/// ! Common representation
/// ! C++ type
/// ! Considered an integer...
/// |-
/// | rational numbers <span class="rosetta__text--bold">Q</span>
/// | <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Rational data type" title="wp: Rational data type">fraction</a>
/// | <code>std::ratio</code>
/// | ...if its denominator is 1 (in reduced form)
/// |-
/// | rowspan=2 | real numbers <span class="rosetta__text--bold">Z</span><br><small><span class="rosetta__text--italic">(approximated)</span></small>
/// | <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Fixed-point arithmetic" title="wp: Fixed-point arithmetic">fixed-point</a>
/// | 
/// | ...if it has no non-zero digits after the decimal point
/// |-
/// | <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Floating point" title="wp: Floating point">floating-point</a>
/// | <code>float</code>, <code>double</code>
/// | ...if the number of significant decimal places of its mantissa isn't greater than its exponent
/// |-
/// | complex numbers <span class="rosetta__text--bold">C</span>
/// | <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Complex data type" title="wp: Complex data type">pair of real numbers</a>
/// | <code>std::complex</code>
/// | ...if its real part is considered an integer and its imaginary part is zero
/// |}
/// <br>
/// <br>
/// <br>
/// Optionally, make your code accept a <code>tolerance</code> parameter for fuzzy testing. The tolerance is the maximum amount by which the number may differ from the nearest integer, to still be considered an integer.
/// <br>
/// This is useful in practice, because when dealing with approximate numeric types (such as floating point), there may already be <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Round-off error" title="wp: Round-off error">round-off errors</a> from previous calculations. For example, a float value of <code>0.9999999998</code> might actually be intended to represent the integer <code>1</code>.
/// <br>
/// <br>
/// <br>
/// {| class="wikitable"
/// |-
/// ! colspan=2 | Input
/// ! colspan=2 | Output
/// ! rowspan=2 | Comment
/// |-
/// ! <small>Type</small>
/// ! <small>Value</small>
/// ! <small><tt>exact</tt></small>
/// ! <small><tt>tolerance = 0.00001</tt></small>
/// |-
/// | rowspan=3 | decimal
/// | <code>25.000000</code>
/// | colspan=2 | true
/// | 
/// |-
/// | <code>24.999999</code>
/// | false
/// | true
/// | 
/// |-
/// | <code>25.000100</code>
/// | colspan=2 | false
/// | 
/// |-
/// | rowspan=4 | floating-point
/// | <code>-2.1e120</code>
/// | colspan=2 | true
/// | This one is tricky, because in most languages it is too large to fit into a native integer type.<br>It is, nonetheless, mathematically an integer, and your code should identify it as such.
/// |-
/// | <code>-5e-2</code>
/// | colspan=2 | false
/// | 
/// |-
/// | <code>NaN</code>
/// | colspan=2 | false
/// | 
/// |-
/// | <code>Inf</code>
/// | colspan=2 | false
/// | This one is debatable. If your code considers it an integer, that's okay too.
/// |-
/// | rowspan=2 | complex
/// | <code>5.0+0.0i</code>
/// | colspan=2 | true
/// | 
/// |-
/// | <code>5-5i</code>
/// | colspan=2 | false
/// | 
/// |}
/// <br>
/// (The types and notations shown in these tables are merely examples &ndash; you should use the native data types and number literals of your programming language and standard library. Use a different set of test-cases, if this one doesn't demonstrate all relevant behavior.)
/// <br>
/// <hr>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:


/// rawSolutions:
null

/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
