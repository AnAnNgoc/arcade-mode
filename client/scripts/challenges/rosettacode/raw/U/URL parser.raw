URL parser

{{task}}
[[Category:String manipulation]]
[[Category:Parser]]

URLs are strings with a simple syntax:
   scheme://[username:password@]domain[:port]/path?query_string#fragment_id


;Task:
Parse a well-formed URL to retrieve the relevant information: &nbsp; <span class="rosetta__text--bold">scheme</span>, <span class="rosetta__text--bold">domain</span>, <span class="rosetta__text--bold">path</span>, ...


Note: &nbsp; this task has nothing to do with [[URL encoding]] or [[URL decoding]].


According to the standards, the characters:
:::: &nbsp; <big><big>    ! * ' ( ) ; : @ & = + $ , / ? % # [ ]    </big></big>
only need to be percent-encoded &nbsp; (<span class="rosetta__text--bold">%</span>) &nbsp; in case of possible confusion. 

Also note that the <span class="rosetta__text--bold">path</span>, <span class="rosetta__text--bold">query</span> and <span class="rosetta__text--bold">fragment</span> are case sensitive, even if the <span class="rosetta__text--bold">scheme</span> and <span class="rosetta__text--bold">domain</span> are not.

The way the returned information is provided (set of variables, array, structured, record, object,...) 
is language-dependent and left to the programmer, but the code should be clear enough to reuse.

Extra credit is given for clear error diagnostics.

* &nbsp; Here is the official standard: &nbsp; &nbsp; https://tools.ietf.org/html/rfc3986, 
* &nbsp; and here is a simpler &nbsp; BNF: &nbsp; &nbsp; http://www.w3.org/Addressing/URL/5_URI_BNF.html.


;Test cases:
According to T. Berners-Lee
 
<span class="rosetta__text--bold"><nowiki>foo://example.com:8042/over/there?name=ferret#nose</nowiki></span> &nbsp; &nbsp; should parse into:
::* &nbsp; scheme = foo
::* &nbsp; domain = example.com
::* &nbsp; port = :8042
::* &nbsp; path = over/there
::* &nbsp; query = name=ferret
::* &nbsp; fragment = nose


<span class="rosetta__text--bold"><nowiki>urn:example:animal:ferret:nose</nowiki></span> &nbsp; &nbsp; should parse into:
::* &nbsp; scheme = urn
::* &nbsp; path = example:animal:ferret:nose


<span class="rosetta__text--bold">other URLs that must be parsed include:</span>
:* &nbsp; <nowiki> jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true </nowiki> 
:* &nbsp; <nowiki> ftp://ftp.is.co.za/rfc/rfc1808.txt                                      </nowiki>
:* &nbsp; <nowiki> http://www.ietf.org/rfc/rfc2396.txt#header1                             </nowiki>
:* &nbsp; <nowiki> ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two               </nowiki>
:* &nbsp; <nowiki> mailto:John.Doe@example.com                                             </nowiki>
:* &nbsp; <nowiki> news:comp.infosystems.www.servers.unix                                  </nowiki>
:* &nbsp; <nowiki> tel:+1-816-555-1212                                                     </nowiki>
:* &nbsp; <nowiki> telnet://192.0.2.16:80/                                                 </nowiki>
:* &nbsp; <nowiki> urn:oasis:names:specification:docbook:dtd:xml:4.1.2                     </nowiki>
<br><br>


=={{header|JavaScript}}==

As JavaScript is (at the time of writing) still the native language of the DOM, the simplest first-pass approach will be to set the ''href'' property of  a DOM element, and read off the various components of the DOM parse from that element. 

Here is an example, tested against the JavaScript engines of current versions of Chrome and Safari, of taking this 'Gordian knot' approach to the task:

<lang JavaScript>(function (lstURL) {

    var e = document.createElement('a'),
        lstKeys = [
            'hash',
            'host',
            'hostname',
            'origin',
            'pathname',
            'port',
            'protocol',
            'search'
        ],

        fnURLParse = function (strURL) {
            e.href = strURL;

            return lstKeys.reduce(
                function (dct, k) {
                    dct[k] = e[k];
                    return dct;
                }, {}
            );
        };

    return JSON.stringify(
        lstURL.map(fnURLParse),
        null, 2
    );

})([
  "foo://example.com:8042/over/there?name=ferret#nose",
  "urn:example:animal:ferret:nose",
  "jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true",
  "ftp://ftp.is.co.za/rfc/rfc1808.txt",
  "http://www.ietf.org/rfc/rfc2396.txt#header1",
  "ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two",
  "mailto:John.Doe@example.com",
  "news:comp.infosystems.www.servers.unix",
  "tel:+1-816-555-1212",
  "telnet://192.0.2.16:80/",
  "urn:oasis:names:specification:docbook:dtd:xml:4.1.2",
  "ssh://alice@example.com",
  "https://bob:pass@example.com/place",
  "http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64"
]);</lang>

Results of applying this approach in the JavaScript of Safari 8
<lang JSON>[
  {
    "hash": "#nose",
    "host": "example.com:8042",
    "hostname": "example.com",
    "origin": "foo://example.com:8042",
    "pathname": "/over/there",
    "port": "8042",
    "protocol": "foo:",
    "search": "?name=ferret"
  },
  {
    "hash": "",
    "host": "",
    "hostname": "",
    "origin": "urn://",
    "pathname": "example:animal:ferret:nose",
    "port": "",
    "protocol": "urn:",
    "search": ""
  },
  {
    "hash": "",
    "host": "",
    "hostname": "",
    "origin": "jdbc://",
    "pathname": "mysql://test_user:ouupppssss@localhost:3306/sakila",
    "port": "",
    "protocol": "jdbc:",
    "search": "?profileSQL=true"
  },
  {
    "hash": "",
    "host": "ftp.is.co.za",
    "hostname": "ftp.is.co.za",
    "origin": "ftp://ftp.is.co.za",
    "pathname": "/rfc/rfc1808.txt",
    "port": "",
    "protocol": "ftp:",
    "search": ""
  },
  {
    "hash": "#header1",
    "host": "www.ietf.org",
    "hostname": "www.ietf.org",
    "origin": "http://www.ietf.org",
    "pathname": "/rfc/rfc2396.txt",
    "port": "",
    "protocol": "http:",
    "search": ""
  },
  {
    "hash": "",
    "host": "[2001:db8::7]",
    "hostname": "[2001:db8::7]",
    "origin": "ldap://[2001:db8::7]",
    "pathname": "/c=GB",
    "port": "",
    "protocol": "ldap:",
    "search": "?objectClass=one&objectClass=two"
  },
  {
    "hash": "",
    "host": "",
    "hostname": "",
    "origin": "mailto://",
    "pathname": "John.Doe@example.com",
    "port": "",
    "protocol": "mailto:",
    "search": ""
  },
  {
    "hash": "",
    "host": "",
    "hostname": "",
    "origin": "news://",
    "pathname": "comp.infosystems.www.servers.unix",
    "port": "",
    "protocol": "news:",
    "search": ""
  },
  {
    "hash": "",
    "host": "",
    "hostname": "",
    "origin": "tel://",
    "pathname": "+1-816-555-1212",
    "port": "",
    "protocol": "tel:",
    "search": ""
  },
  {
    "hash": "",
    "host": "192.0.2.16:80",
    "hostname": "192.0.2.16",
    "origin": "telnet://192.0.2.16:80",
    "pathname": "/",
    "port": "80",
    "protocol": "telnet:",
    "search": ""
  },
  {
    "hash": "",
    "host": "",
    "hostname": "",
    "origin": "urn://",
    "pathname": "oasis:names:specification:docbook:dtd:xml:4.1.2",
    "port": "",
    "protocol": "urn:",
    "search": ""
  },
  {
    "hash": "",
    "host": "example.com",
    "hostname": "example.com",
    "origin": "ssh://example.com",
    "pathname": "",
    "port": "",
    "protocol": "ssh:",
    "search": ""
  },
  {
    "hash": "",
    "host": "example.com",
    "hostname": "example.com",
    "origin": "https://example.com",
    "pathname": "/place",
    "port": "",
    "protocol": "https:",
    "search": ""
  },
  {
    "hash": "",
    "host": "example.com",
    "hostname": "example.com",
    "origin": "http://example.com",
    "pathname": "/",
    "port": "",
    "protocol": "http:",
    "search": "?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64"
  }
]</lang>

