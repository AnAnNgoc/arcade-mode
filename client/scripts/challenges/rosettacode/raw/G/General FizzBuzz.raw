General FizzBuzz

{{task|Classic CS problems and programs}} 
[[Category:Iteration]] 
[[Category:Recursion]] 

;Task:
Write a generalized version of [[FizzBuzz]] that works for any list of factors, along with their words. 

This is basically a "fizzbuzz" implementation where the user supplies the parameters. 

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.


For example, given:
<pre>
>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)
</pre>

In other words: For this example, print the numbers '''1''' through '''20''', replacing every multiple of '''3''' with "Fizz", every multiple of '''5''' with "Buzz", and every multiple of '''7''' with "Baxx". 

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor. 

For instance, the number '''15''' is a multiple of both '''3''' and '''5'''; print "FizzBuzz".
 
If the max number was '''105''' instead of '''20''', you would print "FizzBuzzBaxx" because it's a multiple of '''3''', '''5''', and '''7'''.

{{out}}
<pre>
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz
</pre>
<br><br>


=={{header|JavaScript}}==

===ES5===

In a functional style of JavaScript, with two nested ''reduce'' folds â€“ one through the integer series,
and one through the series of rules.

First as compacted by Google's Closure compiler:
<lang JavaScript>function fizz(d, e) {
  return function b(a) {
    return a ? b(a - 1).concat(a) : [];
  }(e).reduce(function (b, a) {
    return b + (d.reduce(function (b, c) {
      return b + (a % c[0] ? "" : c[1]);
    }, "") || a.toString()) + "\n";
  }, "");
}</lang>

and then in the original expanded form,  for better legibility:

<lang JavaScript>function fizz(lstRules, lngMax) {

    return (
        function rng(i) {
            return i ? rng(i - 1).concat(i) : []
        }
    )(lngMax).reduce(
        function (strSeries, n) {

            // The next member of the series of lines:
            // a word string or a number string
            return strSeries + (
                lstRules.reduce(
                    function (str, tplNumWord) {
                        return str + (
                            n % tplNumWord[0] ? '' : tplNumWord[1]
                        )
                    }, ''
                ) || n.toString()
            ) + '\n';
            
        }, ''
    );
}

fizz([[3, 'Fizz'], [5, 'Buzz'], [7, 'Baxx']], 20);</lang>

{{out}}
<pre>1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz</pre>


===ES6===

<lang JavaScript>(() => {

    // fizz :: [[Int, String]] -> Int -> String
    const fizz = (lstRules, lngMax) => range(1, lngMax)
        .reduce((strSeries, n) =>

            // The next member of the series of lines:
            // a word string or a number string
            strSeries + (
                lstRules
                .reduce((str, tplNumWord) =>
                    str + (
                        n % tplNumWord[0] ? '' : tplNumWord[1]
                    ),
                    ''
                ) || n.toString()
            ) + '\n', ''
        );

    // range :: Int -> Int -> [Int]
    const range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);


    return fizz([
        [3, 'Fizz'],
        [5, 'Buzz'],
        [7, 'Baxx']
    ], 20);

})();</lang>


{{Out}}
<pre>1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz
</pre>

