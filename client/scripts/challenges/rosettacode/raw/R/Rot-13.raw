Rot-13

{{task|Encryption}} 
<a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Category:String_manipulation]]


;Task:
Implement a &nbsp; <span class="rosetta__text--bold">rot-13</span> &nbsp; function &nbsp; (or procedure, class, subroutine, or other "callable" object as appropriate to your programming environment). 

Optionally wrap this function in a utility program &nbsp; (like [[:Category:Tr" title="Category:String_manipulation]]


;Task:
Implement a &nbsp; <span class="rosetta__text--bold">rot-13</span> &nbsp; function &nbsp; (or procedure, class, subroutine, or other "callable" object as appropriate to your programming environment). 

Optionally wrap this function in a utility program &nbsp; (like [[:Category:Tr">tr</a>, &nbsp; which acts like a common [[UNIX]] utility, performing a line-by-line rot-13 encoding of every line of input contained in each file listed on its command line, &nbsp; or (if no filenames are passed thereon) acting as a filter on its &nbsp; "standard input." 


(A number of UNIX scripting languages and utilities, such as &nbsp; <span class="rosetta__text--italic">awk</span> &nbsp; and &nbsp; <span class="rosetta__text--italic">sed</span> &nbsp; either default to processing files in this way or have command line switches or modules to easily implement these wrapper semantics, e.g., &nbsp; [[Perl]] &nbsp; and &nbsp; [[Python]]).

The &nbsp; <span class="rosetta__text--bold">rot-13</span> &nbsp; encoding is commonly known from the early days of Usenet "Netnews" as a way of obfuscating text to prevent casual reading of &nbsp; <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Spoiler (media)" title="wp: Spoiler (media)">spoiler</a> &nbsp; or potentially offensive material. 

Many news reader and mail user agent programs have built-in <span class="rosetta__text--bold">rot-13</span> encoder/decoders or have the ability to feed a message through any external utility script for performing this (or other) actions.

The definition of the rot-13 function is to simply replace every letter of the ASCII alphabet with the letter which is "rotated" 13 characters "around" the 26 letter alphabet from its normal cardinal position &nbsp; (wrapping around from &nbsp; <span class="rosetta__text--bold">z</span>' &nbsp; to &nbsp; <span class="rosetta__text--bold">a</span> &nbsp; as necessary). 

Thus the letters &nbsp; <span class="rosetta__text--bold">abc</span> &nbsp; become &nbsp; <span class="rosetta__text--bold">nop</span> &nbsp; and so on. 

Technically <span class="rosetta__text--bold">rot-13</span> is a &nbsp; "mono-alphabetic substitution cipher" &nbsp; with a trivial &nbsp; "key". 

A proper implementation should work on upper and lower case letters, preserve case, and pass all non-alphabetic characters 
in the input stream through without alteration.


;Related tasks:
* &nbsp; [[Caesar cipher]]
* &nbsp; [[Substitution Cipher]]
* &nbsp; [[Vigen√®re Cipher/Cryptanalysis]]
<br><br>


=={{header|JavaScript}}==
<lang javascript>function rot13(c) {
    return c.replace(/([a-m])|([n-z])/ig, function($0,$1,$2) {
        return String.fromCharCode($1 ? $1.charCodeAt(0) + 13 : $2 ? $2.charCodeAt(0) - 13 : 0) || $0;
    });
}
rot13("ABJURER nowhere") // NOWHERE abjurer
</lang>

TDD with Jasmine using Underscore.js

<lang javascript>
function rot13(value){
  if (!value)
    return "";

  function singleChar(c) {
    if (c.toUpperCase() < "A" || c.toUpperCase() > "Z")
      return c;

    if (c.toUpperCase() <= "M")
      return String.fromCharCode(c.charCodeAt(0) + 13);

    return String.fromCharCode(c.charCodeAt(0) - 13);  
  }

  return _.map(value.split(""), singleChar).join("");
}

describe("Rot-13", function() {
  it("Given nothing will return nothing", function() {
    expect(rot13()).toBe("");
  });

  it("Given empty string will return empty string", function() {
    expect(rot13("")).toBe("");
  });

  it("Given A will return N", function() {
    expect(rot13("A")).toBe("N");
  });

  it("Given B will return O", function() {
    expect(rot13("B")).toBe("O");
  });

  it("Given N will return A", function() {
    expect(rot13("N")).toBe("A");
  });

  it("Given Z will return M", function() {
    expect(rot13("Z")).toBe("M");
  });

  it("Given ZA will return MN", function() {
    expect(rot13("ZA")).toBe("MN");
  });

  it("Given HELLO will return URYYB", function() {
    expect(rot13("HELLO")).toBe("URYYB");
  });

  it("Given hello will return uryyb", function() {
    expect(rot13("hello")).toBe("uryyb");
  });


  it("Given hello1 will return uryyb1", function() {
    expect(rot13("hello1")).toBe("uryyb1");
  });
});
</lang>

