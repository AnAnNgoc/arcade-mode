Partial function application

{{task|Programming language concepts}}

<a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Partial application" title="wp: Partial application">Partial function application</a> &nbsp; is the ability to take a function of many
parameters and apply arguments to some of the parameters to create a new
function that needs only the application of the remaining arguments to
produce the equivalent of applying all arguments to the original function.

E.g:
: Given values <code>v1, v2</code>
: Given <code>f(param1, param2)</code>
: Then  <code>partial(f, param1=v1)</code> returns <code>f'(param2)</code>
: And   <code>f(param1=v1, param2=v2) == f'(param2=v2)</code> (for any value v2)


Note that in the partial application of a parameter, (in the above case param1), other parameters are not explicitly mentioned. This is a recurring feature of partial function application.


;Task 
* Create a function fs( f, s ) that takes a function, f( n ), of one value and a sequence of values s.<br> Function fs should return an ordered sequence of the result of applying function f to every value of s in turn.

* Create function f1 that takes a value and returns it multiplied by 2.
* Create function f2 that takes a value and returns it squared.

* Partially apply f1 to fs to form function fsf1( s )
* Partially apply f2 to fs to form function fsf2( s )

* Test fsf1 and fsf2 by evaluating them with s being the sequence of integers from 0 to 3 inclusive and then the sequence of even integers from 2 to 8 inclusive.


;Notes
* In partially applying the functions f1 or f2 to fs, there should be no <span class="rosetta__text--italic">explicit</span> mention of any other parameters to fs, although introspection of fs within the partial applicator to find its parameters <span class="rosetta__text--italic">is</span> allowed.
* This task is more about <span class="rosetta__text--italic">how</span> results are generated rather than just getting results.
<br><br>


=={{header|JavaScript}}==
===ES5===
Higher order functions are part of the core architecture of JavaScript.

(No special libraries are required for the creation or application of partial functions)

<lang JavaScript>var f1 = function (x) { return x * 2; },
    f2 = function (x) { return x * x; },

    fs = function (f, s) {
        return function (s) {
            return s.map(f);
        }
    },

    fsf1 = fs(f1),
    fsf2 = fs(f2);

// Test
    [
        fsf1([0, 1, 2, 3]),
        fsf2([0, 1, 2, 3]),
		
        fsf1([2, 4, 6, 8]),
        fsf2([2, 4, 6, 8])
    ]</lang>

Output:

<pre>[[0, 2, 4, 6], [0, 1, 4, 9], [4, 8, 12, 16], [4, 16, 36, 64]]</pre>

For additional flexibility ( allowing for an arbitrary number of arguments in applications of a partially applied function, and dropping the square brackets from the function calls in the tests above ) we can make use of the array-like ''arguments'' object, which is a property of any JavaScript function.

<lang JavaScript>var f1 = function (x) { return x * 2; },
    f2 = function (x) { return x * x; },

    fs = function (f) {
        return function () {
            return Array.prototype.slice.call(
                arguments
            ).map(f);
        }
    },

    fsf1 = fs(f1),
    fsf2 = fs(f2);

// Test alternative approach, with arbitrary numbers of arguments
    [
        fsf1(0, 1, 2, 3, 4),
        fsf2(0, 1, 2),
        fsf1(2, 4, 6, 8, 10, 12),
        fsf2(2, 4, 6, 8)
    ]</lang>

Output:

<pre>[[0, 2, 4, 6, 8], [0, 1, 4], [4, 8, 12, 16, 20, 24], [4, 16, 36, 64]]</pre>

===ES6===
====Simple curry====
<lang JavaScript>(() => {
    'use strict';

    // GENERIC FUNCTIONS ------------------------------------------------------

    // curry :: ((a, b) -> c) -> a -> b -> c
    const curry = f => a => b => f(a, b);

    // map :: (a -> b) -> [a] -> [b]
    const map = curry((f, xs) => xs.map(f));


    // PARTIAL APPLICATION ----------------------------------------------------

    const
        f1 = x => x * 2,
        f2 = x => x * x,

        fs = map,

        fsf1 = fs(f1),
        fsf2 = fs(f2);

    // TEST -------------------------------------------------------------------
    return [
        fsf1([0, 1, 2, 3]),
        fsf2([0, 1, 2, 3]),

        fsf1([2, 4, 6, 8]),
        fsf2([2, 4, 6, 8])
    ];
})();</lang>
{{Out}}
<pre>[[0, 2, 4, 6], [0, 1, 4, 9], [4, 8, 12, 16], [4, 16, 36, 64]]</pre>
====Generic curry====
The simple version of the higher-order '''curry''' function above works only on functions with two arguments. For more flexibility, we can generalise it to a form which curries functions with an arbitrary number of arguments:

<lang JavaScript>(() => {
    'use strict';

    // GENERIC FUNCTIONS ------------------------------------------------------

    // 2 or more arguments
    // curry :: Function -> Function
    const curry = (f, ...args) => {
        const go = xs => xs.length >= f.length ? (f.apply(null, xs)) :
            function () {
                return go(xs.concat(Array.from(arguments)));
            };
        return go([].slice.call(args, 1));
    };

    // map :: (a -> b) -> [a] -> [b]
    const map = curry((f, xs) => xs.map(f));

    // PARTIAL APPLICATION ----------------------------------------------------
    const
        f1 = x => x * 2,
        f2 = x => x * x,

        fs = map,

        fsf1 = fs(f1),
        fsf2 = fs(f2);

    // TEST -------------------------------------------------------------------
    return [
        fsf1([0, 1, 2, 3]),
        fsf2([0, 1, 2, 3]),

        fsf1([2, 4, 6, 8]),
        fsf2([2, 4, 6, 8])
    ];
})();</lang>
{{Out}}
<pre>[[0, 2, 4, 6], [0, 1, 4, 9], [4, 8, 12, 16], [4, 16, 36, 64]]</pre>

