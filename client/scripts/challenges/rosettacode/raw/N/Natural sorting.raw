
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Natural sorting
/// type: rosetta-code

/// categories:
/// ?

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// [[Category:Sorting]]
/// <br>
/// <br>
/// Natural sorting is the sorting of text that does more than rely on the
/// order of individual characters codes to make the finding of
/// individual strings easier for a <span class="rosetta__text--italic">human</span> reader.
/// <br>
/// There is no "one true way" to do this, but for the purpose of this task 'natural' orderings might include:
/// <span class="rosetta__text--indented">1.  Ignore leading, trailing and multiple adjacent spaces</span>
/// <span class="rosetta__text--indented">2.  Make all whitespace characters equivalent.</span>
/// <span class="rosetta__text--indented">3.  Sorting without regard to case.</span>
/// <span class="rosetta__text--indented">4.  Sorting numeric portions of strings in numeric order. That is split the string into fields on numeric boundaries, then sort on each field, with the rightmost fields being the most significant, and numeric fields of integers treated as numbers.</span>
/// <span class="rosetta__text--indented">: foo9.txt before foo10.txt</span>
/// <span class="rosetta__text--indented">: As well as ... x9y99 before x9y100, before x10y0</span>
/// <span class="rosetta__text--indented">: ... (for any number of groups of integers in a string).</span>
/// <span class="rosetta__text--indented">5.  Title sorts: without regard to a leading, very common, word such</span>
/// <span class="rosetta__text--indented">: as 'The' in "The thirty-nine steps".</span>
/// <span class="rosetta__text--indented">6.  Sort letters without regard to accents.</span>
/// <span class="rosetta__text--indented">7.  Sort ligatures as separate letters.</span>
/// <span class="rosetta__text--indented">8.  Replacements:</span>
/// <span class="rosetta__text--indented">: Sort german scharfes S (ß) as ss</span>
/// <span class="rosetta__text--indented">: Sort ſ,  LATIN SMALL LETTER LONG S as s</span>
/// <span class="rosetta__text--indented">: Sort ʒ,  LATIN SMALL LETTER EZH as s</span>
/// <span class="rosetta__text--indented">: ...</span>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Task Description</dt></dl>
/// <ul class="rosetta__unordered-list">
/// <li class="rosetta__list-item"><span class="rosetta__text--bold">Implement the first four</span> of the eight given features in a natural sorting routine/function/method...</li>
/// <li class="rosetta__list-item">Test each feature implemented separately with an ordered list of test strings from the 'Sample inputs' section below, and make sure your naturally sorted output is in the same order as other language outputs such as Python. </li>
/// <li class="rosetta__list-item">Print and display your output.</li>
/// <br>
/// </ul>
/// <ul class="rosetta__unordered-list">
/// <li class="rosetta__list-item"><span class="rosetta__text--bold">For extra credit</span> implement more than the first four.</li>
/// <br>
/// </ul>
/// Note: It is not necessary to have individual control of which features are active in the natural sorting routine at any time. 
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Sample input:</dt></dl>
/// <br>
/// <pre>
/// # Ignoring leading spaces
/// Text strings:
/// ['ignore leading spaces: 2-2', ' ignore leading spaces: 2-1', '  ignore leading spaces: 2+0', '   ignore leading spaces: 2+1']
/// <br>
/// # Ignoring multiple adjacent spaces (m.a.s)
/// Text strings:
/// ['ignore m.a.s spaces: 2-2', 'ignore m.a.s  spaces: 2-1', 'ignore m.a.s   spaces: 2+0', 'ignore m.a.s    spaces: 2+1']
/// <br>
/// <br>
/// # Equivalent whitespace characters
/// Text strings:
/// ['Equiv. spaces: 3-3', 'Equiv.\rspaces: 3-2', 'Equiv.\x0cspaces: 3-1', 'Equiv.\x0bspaces: 3+0', 'Equiv.\nspaces: 3+1', 'Equiv.\tspaces: 3+2']
/// <br>
/// # Case Indepenent sort
/// Text strings:
/// ['cASE INDEPENENT: 3-2', 'caSE INDEPENENT: 3-1', 'casE INDEPENENT: 3+0', 'case INDEPENENT: 3+1']
/// <br>
/// # Numeric fields as numerics
/// Text strings:
/// ['foo100bar99baz0.txt', 'foo100bar10baz0.txt', 'foo1000bar99baz10.txt', 'foo1000bar99baz9.txt']
/// <br>
/// # Title sorts
/// Text strings:
/// ['The Wind in the Willows', 'The 40th step more', 'The 39 steps', 'Wanda']
/// <br>
/// # Equivalent accented characters (and case)
/// Text strings:
/// [u'Equiv. \xfd accents: 2-2', u'Equiv. \xdd accents: 2-1', u'Equiv. y accents: 2+0', u'Equiv. Y accents: 2+1']
/// <br>
/// <br>
/// # Separated ligatures
/// Text strings:
/// [u'\u0132 ligatured ij', 'no ligature']
/// <br>
/// # Character replacements
/// Text strings:
/// [u'Start with an \u0292: 2-2', u'Start with an \u017f: 2-1', u'Start with an \xdf: 2+0', u'Start with an s: 2+1']</pre>
/// <br>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:

var nsort = function(input) {
  var e = function(s) {
    return (' ' + s + ' ').replace(/[\s]+/g, ' ').toLowerCase().replace(/[\d]+/, function(d) {
      d = '' + 1e20 + d;
      return d.substring(d.length - 20);
    });
  };
  return input.sort(function(a, b) {
    return e(a).localeCompare(e(b));
  });
};

console.log(nsort([
  "file10.txt",
  "\nfile9.txt",
  "File11.TXT",
  "file12.txt"
]));
// -> ['\nfile9.txt', 'file10.txt', 'File11.TXT', 'file12.txt']


/// rawSolutions:
=={{header|JavaScript}}==

Implements the first four rules. Rule 4 works for digits up to 20 characters.

<lang JavaScript>
var nsort = function(input) {
  var e = function(s) {
    return (' ' + s + ' ').replace(/[\s]+/g, ' ').toLowerCase().replace(/[\d]+/, function(d) {
      d = '' + 1e20 + d;
      return d.substring(d.length - 20);
    });
  };
  return input.sort(function(a, b) {
    return e(a).localeCompare(e(b));
  });
};

console.log(nsort([
  "file10.txt",
  "\nfile9.txt",
  "File11.TXT",
  "file12.txt"
]));
// -> ['\nfile9.txt', 'file10.txt', 'File11.TXT', 'file12.txt']
</lang>



/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
