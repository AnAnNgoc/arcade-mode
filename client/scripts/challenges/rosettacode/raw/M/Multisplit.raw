
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Multisplit
/// type: rosetta-code

/// categories:
/// String manipulation

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
///  
/// It is often necessary to split a string into pieces 
/// based on several different (potentially multi-character) separator strings, 
/// while still retaining the information about which separators were present in the input. 
/// <br>
/// This is particularly useful when doing small parsing tasks. <br>
/// The task is to write code to demonstrate this.
/// <br>
/// The function (or procedure or method, as appropriate) should 
/// take an input string and an ordered collection of separators. 
/// <br>
/// The order of the separators is significant: <br>
/// The delimiter order represents priority in matching, with the first defined delimiter having the highest priority. 
/// In cases where there would be an ambiguity as to 
/// which separator to use at a particular point 
/// (e.g., because one separator is a prefix of another) 
/// the separator with the highest priority should be used. 
/// Delimiters can be reused and the output from the function should be an ordered sequence of substrings.
/// <br>
/// Test your code using the input string “<code>a!===b=!=c</code>” and the separators “<code>==</code>”, “<code>!=</code>” and “<code>=</code>”.
/// <br>
/// For these inputs the string should be parsed as <code>"a" (!=) "" (==) "b" (=) "" (!=) "c"</code>, where matched delimiters are shown in parentheses, and separated strings are quoted, so our resulting output is <code>"a", empty string, "b", empty string, "c"</code>. 
/// Note that the quotation marks are shown for clarity and do not form part of the output.
/// <br>
/// <span class="rosetta__text--bold">Extra Credit:</span> provide information that indicates which separator was matched at each separation point and where in the input string that separator was matched.
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:
RegExp.escape = function(text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}

multisplit = function(string, seps) {
    var sep_regex = RegExp(_.map(seps, function(sep) { return RegExp.escape(sep); }).join('|'));
    return string.split(sep_regex);
}

/// rawSolutions:
=={{header|JavaScript}}==
Based on Ruby example.
{{libheader|Underscore.js}}
<lang JavaScript>RegExp.escape = function(text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}

multisplit = function(string, seps) {
    var sep_regex = RegExp(_.map(seps, function(sep) { return RegExp.escape(sep); }).join('|'));
    return string.split(sep_regex);
}</lang>


/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
