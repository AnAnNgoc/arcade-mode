
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Man or boy test
/// type: rosetta-code

/// categories:
/// Recursion

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// <br>
/// <br>
/// <br>
/// <br>
/// <span class="rosetta__text--bold">Background</span>: The <span class="rosetta__text--bold">man or boy test</span> was proposed by computer scientist <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Donald_Knuth" title="wp: Donald_Knuth">Donald Knuth]] as a means of evaluating implementations of the [[:Category:ALGOL 60|ALGOL 60</a> programming language. The aim of the test was to distinguish compilers that correctly implemented "recursion and non-local references" from those that did not.
/// <br>
/// <blockquote style="font-style:italic">
///   I have written the following simple routine, which may separate the 'man-compilers' from the 'boy-compilers'<br> &mdash; <span style="font-style:normal">Donald Knuth</span></blockquote>
/// <br>
/// <span class="rosetta__text--bold">Task</span>: Imitate <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/#ALGOL 60 - Knuth's example" title="#ALGOL 60 - Knuth's example">Knuth's example in Algol 60</a> in another language, as far as possible. 
/// <br>
/// <span class="rosetta__text--bold">Details</span>: Local variables of routines are often kept in [http://c2.com/cgi/wiki?ActivationRecord <span class="rosetta__text--italic">activation records</span>] (also <span class="rosetta__text--italic">call frames</span>). In many languages, these records are kept on a <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/System stack" title="System stack">call stack]]. In Algol (and e.g. in [[Smalltalk]]), they are allocated on a [[heap</a> instead. Hence it is possible to pass references to routines that still can use and update variables from their call environment, even if the routine where those variables are declared already returned. This difference in implementations is sometimes called the <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Funarg_problem" title="wp: Funarg_problem">Funarg Problem</a>.
/// <br>
/// In Knuth's example, each call to <span class="rosetta__text--italic">A</span> allocates an activation record for the variable <span class="rosetta__text--italic">A</span>. When <span class="rosetta__text--italic">B</span> is called from <span class="rosetta__text--italic">A</span>, any access to <span class="rosetta__text--italic">k</span> now refers to this activation record. Now <span class="rosetta__text--italic">B</span> in turn calls <span class="rosetta__text--italic">A</span>, but passes itself as an argument. This argument remains bound to the activation record. This call to <span class="rosetta__text--italic">A</span> also "shifts" the variables <span class="rosetta__text--italic">x<sub>i</sub></span> by one place, so eventually the argument <span class="rosetta__text--italic">B</span> (still bound to its particular
/// activation record) will appear as <span class="rosetta__text--italic">x4</span> or <span class="rosetta__text--italic">x5</span> in a call to <span class="rosetta__text--italic">A</span>. If this happens when the expression <span class="rosetta__text--italic">x4 + x5</span> is evaluated, then this will again call <span class="rosetta__text--italic">B</span>, which in turn will update <span class="rosetta__text--italic">k</span> in the activation record it was originally bound to. As this activation record is shared with other instances of calls to <span class="rosetta__text--italic">A</span> and <span class="rosetta__text--italic">B</span>, it will influence the whole computation.
/// <br>
/// So all the example does is to set up a convoluted calling structure, where updates to <span class="rosetta__text--italic">k</span> can influence the behavior
/// in completely different parts of the call tree.
/// <br>
/// Knuth used this to test the correctness of the compiler, but one can of course also use it to test that other languages can emulate the Algol behavior correctly. If the handling of activation records is correct, the computed value will be &minus;67.
/// <br>
/// <span class="rosetta__text--bold">Performance and Memory</span>: Man or Boy is intense and can be pushed to challenge any machine. Memory (both stack and heap) not CPU time is the constraining resource as the recursion creates a proliferation activation records which will quickly exhaust memory and present itself through a stack error.  Each language may have ways of adjusting the amount of memory or increasing the recursion depth. Optionally, show how you would make such adjustments.
/// <br>
/// The table below shows the result, call depths, and total calls for a range of <span class="rosetta__text--italic">k</span>:
/// {| class="wikitable" style="font-size: 85%"
/// ! <span class="rosetta__text--italic">k</span>
/// ! 0
/// ! 1
/// ! 2
/// ! 3
/// ! 4
/// ! 5
/// ! 6
/// ! 7
/// ! 8
/// ! 9
/// ! 10
/// ! 11
/// ! 12
/// ! 13
/// ! 14
/// ! 15
/// ! 16
/// ! 17
/// ! 18
/// ! 19
/// ! 20
/// ! 21
/// ! 22
/// ! 23
/// ! 24
/// ! 25
/// ! 26
/// ! 27
/// ! 28
/// ! 29
/// ! 30
/// |-
/// ! <span class="rosetta__text--italic">A</span>
/// |align="right"| 1
/// |align="right"| 0
/// |align="right"| -2
/// |align="right"| 0
/// |align="right"| 1
/// |align="right"| 0
/// |align="right"| 1
/// |align="right"| -1
/// |align="right"| -10
/// |align="right"| -30
/// |align="right"| -67
/// |align="right"| -138
/// |align="right"| -291
/// |align="right"| -642
/// |align="right"| -1,446
/// |align="right"| -3,250
/// |align="right"| -7,244
/// |align="right"| -16,065
/// |align="right"| -35,601
/// |align="right"| -78,985
/// |align="right"| -175,416
/// |align="right"| -389,695
/// |align="right"| -865,609
/// |align="right"| -1,922,362
/// |align="right"| -4,268,854
/// |align="right"| -9,479,595
/// |align="right"| -21,051,458
/// |align="right"| -46,750,171
/// |align="right"| -103,821,058
/// |align="right"| -230,560,902
/// |align="right"| -512,016,658
/// |-
/// ! <span class="rosetta__text--italic">A</span> called
/// |align="right"| 1
/// |align="right"| 2
/// |align="right"| 3
/// |align="right"| 4
/// |align="right"| 8
/// |align="right"| 18
/// |align="right"| 38
/// |align="right"| 80
/// |align="right"| 167
/// |align="right"| 347
/// |align="right"| 722
/// |align="right"| 1,509
/// |align="right"| 3,168
/// |align="right"| 6,673
/// |align="right"| 14,091
/// |align="right"| 29,825
/// |align="right"| 63,287
/// |align="right"| 134,652
/// |align="right"| 287,264
/// |align="right"| 614,442
/// |align="right"| 1,317,533
/// |align="right"| 2,831,900
/// |align="right"| 6,100,852
/// |align="right"| 13,172,239
/// |align="right"| 28,499,827
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |-
/// ! <span class="rosetta__text--italic">A</span> depth
/// |align="right"| 1
/// |align="right"| 2
/// |align="right"| 3
/// |align="right"| 4
/// |align="right"| 8
/// |align="right"| 16
/// |align="right"| 32
/// |align="right"| 64
/// |align="right"| 128
/// |align="right"| 256
/// |align="right"| 512
/// |align="right"| 1,024
/// |align="right"| 2,048
/// |align="right"| 4,096
/// |align="right"| 8,192
/// |align="right"| 16,384
/// |align="right"| 32,768
/// |align="right"| 65,536
/// |align="right"| 131,072
/// |align="right"| 262,144
/// |align="right"| 524,288
/// |align="right"| 1,048,576
/// |align="right"| 2,097,152
/// |align="right"| 4,194,304
/// |align="right"| 8,388,608
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |-
/// ! <span class="rosetta__text--italic">B</span> called
/// |align="right"| 0
/// |align="right"| 1
/// |align="right"| 2
/// |align="right"| 3
/// |align="right"| 7
/// |align="right"| 17
/// |align="right"| 37
/// |align="right"| 79
/// |align="right"| 166
/// |align="right"| 346
/// |align="right"| 721
/// |align="right"| 1,508
/// |align="right"| 3,167
/// |align="right"| 6,672
/// |align="right"| 14,090
/// |align="right"| 29,824
/// |align="right"| 63,286
/// |align="right"| 134,651
/// |align="right"| 287,263
/// |align="right"| 614,441
/// |align="right"| 1,317,532
/// |align="right"| 2,831,899
/// |align="right"| 6,100,851
/// |align="right"| 13,172,238
/// |align="right"| 28,499,826
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |-
/// ! <span class="rosetta__text--italic">B</span> depth
/// |align="right"| 0
/// |align="right"| 1
/// |align="right"| 2
/// |align="right"| 3
/// |align="right"| 7
/// |align="right"| 15
/// |align="right"| 31
/// |align="right"| 63
/// |align="right"| 127
/// |align="right"| 255
/// |align="right"| 511
/// |align="right"| 1,023
/// |align="right"| 2,047
/// |align="right"| 4,095
/// |align="right"| 8,191
/// |align="right"| 16,383
/// |align="right"| 32,767
/// |align="right"| 65,535
/// |align="right"| 131,071
/// |align="right"| 262,143
/// |align="right"| 524,287
/// |align="right"| 1,048,575
/// |align="right"| 2,097,151
/// |align="right"| 4,194,303
/// |align="right"| 8,388,607
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |&nbsp;
/// |}
/// <br><br>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:
function a(k, x1, x2, x3, x4, x5) {
  function b() {
    k -= 1;
    return a(k, b, x1, x2, x3, x4);
  }
  return (k > 0) ? b() : x4() + x5();
}

// this uses lambda wrappers around the numeric arguments
function x(n) {
  return function () {
    return n;
  };
}
alert(a(10, x(1), x(-1), x(-1), x(1), x(0)));

/// rawSolutions:
=={{header|JavaScript}}==
In Chrome we get a "Maximum call stack size exceeded" when a > 13. In Firefox we get "too much recursion" when a > 12.
<lang javascript>function a(k, x1, x2, x3, x4, x5) {
  function b() {
    k -= 1;
    return a(k, b, x1, x2, x3, x4);
  }
  return (k > 0) ? b() : x4() + x5();
}

// this uses lambda wrappers around the numeric arguments
function x(n) {
  return function () {
    return n;
  };
}
alert(a(10, x(1), x(-1), x(-1), x(1), x(0)));</lang>

Implemented using ES6 syntax
<lang javascript>var x = n => () => n;

var a = (k, x1, x2, x3, x4, x5) => {
  var b = () => return a(--k, b, x1, x2, x3, x4); //decrement k before use
  return (k > 0) ? b() : x4() + x5();
};</lang>



/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
