
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Move-to-front algorithm
/// type: rosetta-code

/// categories:
/// ?

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// Given a symbol table of a <span class="rosetta__text--italic">zero-indexed</span> array of all possible input symbols
/// <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Move-to-front transform" title="wp: Move-to-front transform">this algorithm</a> reversibly transforms a sequence
/// of input symbols into an array of output numbers (indices).<br>
/// The transform in many cases acts to give frequently repeated input symbols
/// lower indices which is <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Move-to-front_transform#Use_in_practical_data_compression_algorithms" title="wp: Move-to-front_transform#Use_in_practical_data_compression_algorithms"> useful in some compression algorithms</a>.
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Encoding algorithm:</dt></dl>
/// <pre>
///     for each symbol of the input sequence:
///         output the index of the symbol in the symbol table
///         move that symbol to the front of the symbol table
/// </pre>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Decoding algorithm:</dt></dl>
/// <pre>
///     # Using the same starting symbol table
///     for each index of the input sequence:
///         output the symbol at that index of the symbol table
///         move that symbol to the front of the symbol table
/// </pre>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Example:</dt></dl>
/// Encoding the string of character symbols 'broood' using a symbol table of
/// the characters 'a'-to-'z'
/// <br>
/// {| class="wikitable" border="1"
/// |-
/// ! Input
/// ! Output
/// ! SymbolTable
/// |-
/// | <span class="rosetta__text--bold">b</span>roood
/// | 1
/// | 'abcdefghijklmnopqrstuvwxyz'
/// |-
/// | b<span class="rosetta__text--bold">r</span>oood
/// | 1 17
/// | 'bacdefghijklmnopqrstuvwxyz'
/// |-
/// | br<span class="rosetta__text--bold">o</span>ood
/// | 1 17 15
/// | 'rbacdefghijklmnopqstuvwxyz'
/// |-
/// | bro<span class="rosetta__text--bold">o</span>od
/// | 1 17 15 0
/// | 'orbacdefghijklmnpqstuvwxyz'
/// |-
/// | broo<span class="rosetta__text--bold">o</span>d
/// | 1 17 15 0 0
/// | 'orbacdefghijklmnpqstuvwxyz'
/// |-
/// | brooo<span class="rosetta__text--bold">d</span>
/// | 1 17 15 0 0 5
/// | 'orbacdefghijklmnpqstuvwxyz'
/// |}
/// <br>
/// Decoding the indices back to the original symbol order:
/// {| class="wikitable" border="1"
/// |-
/// ! Input
/// ! Output
/// ! SymbolTable
/// |-
/// |  <span class="rosetta__text--bold">1</span> 17 15 0 0 5
/// | b
/// | 'abcdefghijklmnopqrstuvwxyz'
/// |-
/// | 1 <span class="rosetta__text--bold">17</span> 15 0 0 5
/// | br
/// | 'bacdefghijklmnopqrstuvwxyz'
/// |-
/// | 1 17 <span class="rosetta__text--bold">15</span> 0 0 5
/// | bro
/// | 'rbacdefghijklmnopqstuvwxyz'
/// |-
/// | 1 17 15 <span class="rosetta__text--bold">0</span> 0 5
/// | broo
/// | 'orbacdefghijklmnpqstuvwxyz'
/// |-
/// | 1 17 15 0 <span class="rosetta__text--bold">0</span> 5
/// | brooo
/// | 'orbacdefghijklmnpqstuvwxyz'
/// |-
/// | 1 17 15 0 0 <span class="rosetta__text--bold">5</span> 
/// | broood
/// | 'orbacdefghijklmnpqstuvwxyz'
/// |}
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Task:</dt></dl>
/// <ul class="rosetta__unordered-list">
/// <li class="rosetta__list-item">Encode and decode the following three strings of characters using the symbol table of the characters 'a'-to-'z' as above. </li>
/// <li class="rosetta__list-item">Show the strings and their encoding here.</li>
/// <li class="rosetta__list-item">Add a check to ensure that the decoded string is the same as the original.</li>
/// <br>
/// </ul>
/// <br>
/// The strings are: 
/// <br>
///    <big> broood       </big>   
///    <big> bananaaa     </big>
///    <big> hiphophiphop </big> 
/// <br>
/// (Note the spellings.)
/// <br><br>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:
var encodeMTF = function (word) {
  var init = {wordAsNumbers: [], charList: 'abcdefghijklmnopqrstuvwxyz'.split('')};

  return word.split('').reduce(function (acc, char) {
    var charNum = acc.charList.indexOf(char); //get index of char
    acc.wordAsNumbers.push(charNum); //add original index to acc
    acc.charList.unshift(acc.charList.splice(charNum, 1)[0]); //put at beginning of list
    return acc;
  }, init).wordAsNumbers; //return number list
};

var decodeMTF = function (numList) {
  var init = {word: '', charList: 'abcdefghijklmnopqrstuvwxyz'.split('')};

  return numList.reduce(function (acc, num) {
    acc.word += acc.charList[num];
    acc.charList.unshift(acc.charList.splice(num, 1)[0]); //put at beginning of list
    return acc;
  }, init).word;
};

//test our algorithms
var words = ['broood', 'bananaaa', 'hiphophiphop'];
var encoded = words.map(encodeMTF);
var decoded = encoded.map(decodeMTF);

//print results
console.log("from encoded:");
console.log(encoded);
console.log("from decoded:");
console.log(decoded);

/// rawSolutions:
=={{header|JavaScript}}==
<lang javascript>var encodeMTF = function (word) {
  var init = {wordAsNumbers: [], charList: 'abcdefghijklmnopqrstuvwxyz'.split('')};

  return word.split('').reduce(function (acc, char) {
    var charNum = acc.charList.indexOf(char); //get index of char
    acc.wordAsNumbers.push(charNum); //add original index to acc
    acc.charList.unshift(acc.charList.splice(charNum, 1)[0]); //put at beginning of list
    return acc;
  }, init).wordAsNumbers; //return number list
};

var decodeMTF = function (numList) {
  var init = {word: '', charList: 'abcdefghijklmnopqrstuvwxyz'.split('')};

  return numList.reduce(function (acc, num) {
    acc.word += acc.charList[num];
    acc.charList.unshift(acc.charList.splice(num, 1)[0]); //put at beginning of list
    return acc;
  }, init).word;
};

//test our algorithms
var words = ['broood', 'bananaaa', 'hiphophiphop'];
var encoded = words.map(encodeMTF);
var decoded = encoded.map(decodeMTF);

//print results
console.log("from encoded:");
console.log(encoded);
console.log("from decoded:");
console.log(decoded);</lang>
{{out}}
<pre>from encoded:
[
  [1, 17, 15, 0, 0, 5],
  [1, 1, 13, 1, 1, 1, 0, 0],
  [7, 8, 15, 2, 15, 2, 2, 3, 2, 2, 3, 2]
]
from decoded:
['broood', 'bananaaa', 'hiphophiphop']</pre>



/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
