
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Mad Libs
/// type: rosetta-code

/// categories:
/// ?

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
///  
/// <br>
/// <br>
/// <br>
/// <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Mad Libs" title="wp: Mad Libs">Mad Libs</a> is a phrasal template word game where one player prompts another for a list of words to substitute for blanks in a story, usually with funny results. 
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Task;</dt></dl>
/// Write a program to create a Mad Libs like story. 
/// <br>
/// The program should read an arbitrary multiline story from input.
/// <br>
/// The story will be terminated with a blank line. 
/// <br>
/// Then, find each replacement to be made within the story, ask the user for a word to replace it with, and make all the replacements.
/// <br>
/// Stop when there are none left and print the final story.
/// <br>
/// <br>
/// The input should be an arbitrary story in the form:
/// <pre>
/// <name> went for a walk in the park. <he or she>
/// found a <noun>. <name> decided to take it home.
/// </pre>
/// Given this example, it should then ask for a <tt>name</tt>, a <tt>he or she</tt> and a <tt>noun</tt> (<tt><nowiki><name></nowiki></tt> gets replaced both times with the same value).
/// <br><br>
/// <br>
/// ==  ==
/// <br>
/// The fun of Mad Libs is not knowing the story ahead of time, so the program reads the story template from a text file. The name of the text file is given as a command line argument. 
/// <br>
/// <lang Ada>with Ada.Text_IO, Ada.Command_Line, String_Helper;
/// <br>
/// procedure Madlib is
/// <br>
///    use String_Helper;
/// <br>
///    Text: Vector := Get_Vector(Ada.Command_Line.Argument(1));
///    M, N: Natural;
/// <br>
/// begin
///    -- search for templates and modify the text accordingly
///    for I in Text.First_Index .. Text.Last_Index loop
///       loop
///          Search_Brackets(Text.Element(I), "<", ">", M, N);
///       exit when M=0; -- "M=0" means "not found"
///          Ada.Text_IO.Put_Line("Replacement for " & Text.Element(I)(M .. N) & "?");
///          declare
///             Old: String := Text.Element(I)(M .. N);
///             New_Word: String := Ada.Text_IO.Get_Line;
///          begin
///             for J in I .. Text.Last_Index loop
///                Text.Replace_Element(J, Replace(Text.Element(J), Old, New_Word));
///             end loop;
///          end;
///       end loop;
///    end loop;
/// <br>
///    -- write the text
///    for I in Text.First_Index .. Text.Last_Index loop
///       Ada.Text_IO.Put_Line(Text.Element(I));
///    end loop;
/// end Madlib;</lang>
/// <br>
/// It uses an auxiliary package String_Helper for simple string functions;
/// <br>
/// <lang Ada>with Ada.Containers.Indefinite_Vectors;
/// <br>
/// package String_Helper is
/// <br>
///    function Index(Source: String; Pattern: String) return Natural;
/// <br>
///    procedure Search_Brackets(Source: String;
///                              Left_Bracket: String;
///                              Right_Bracket: String;
///                              First, Last: out Natural);
///       -- returns indices of first pair of brackets in source
///       -- indices are zero if no such brackets are found
/// <br>
///    function Replace(Source: String; Old_Word: String; New_Word: String)
///                    return String;
/// <br>
///    package String_Vec is new Ada.Containers.Indefinite_Vectors
///      (Index_Type   => Positive,
///       Element_Type => String);
/// <br>
///    type Vector is new String_Vec.Vector with null record;
/// <br>
///    function Get_Vector(Filename: String) return Vector;
/// <br>
/// end String_Helper;</lang>
/// <br>
/// Here is the implementation of String_Helper:
/// <br>
/// <lang Ada>with Ada.Strings.Fixed, Ada.Text_IO;
/// <br>
/// package body String_Helper is
/// <br>
///    function Index(Source: String; Pattern: String) return Natural is
///    begin
///       return Ada.Strings.Fixed.Index(Source => Source, Pattern => Pattern);
///    end Index;
/// <br>
///    procedure Search_Brackets(Source: String;
///                              Left_Bracket: String;
///                              Right_Bracket: String;
///                              First, Last: out Natural) is
///    begin
///       First := Index(Source, Left_Bracket);
///       if First = 0 then
///          Last := 0; -- not found
///       else
///          Last := Index(Source(First+1 .. Source'Last), Right_Bracket);
///          if Last = 0 then
///             First := 0; -- not found;
///          end if;
///       end if;
///    end Search_Brackets;
/// <br>
///    function Replace(Source: String; Old_Word: String; New_Word: String)
///                    return String is
///       L: Positive := Old_Word'Length;
///       I: Natural := Index(Source, Old_Word);
///    begin
///       if I = 0 then
///          return Source;
///       else
///          return Source(Source'First .. I-1) & New_Word
///            & Replace(Source(I+L .. Source'Last), Old_Word, New_Word);
///       end if;
///    end Replace;
/// <br>
///    function Get_Vector(Filename: String) return Vector is
///       F: Ada.Text_IO.File_Type;
///       T: Vector;
///    begin
///       Ada.Text_IO.Open(F, Ada.Text_IO.In_File, Filename);
///       while not Ada.Text_IO.End_Of_File(F) loop
///          T.Append(Ada.Text_IO.Get_Line(F));
///       end loop;
///       Ada.Text_IO.Close(F);
///       return T;
///    end Get_Vector;
/// <br>
/// end String_Helper;</lang>
/// <br>
/// A sample run (with the story template in t.txt):
/// <br>
/// <pre>./madlib t.txt
/// Replacement for <name>?
/// Hilla, the hypohondraic,
/// Replacement for <he or she>?
/// She
/// Replacement for <noun>?
/// headache
/// Hilla, the hypohondraic, went for a walk in the park. She
/// found a headache. Hilla, the hypohondraic, decided to take it home.</pre>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:


/// rawSolutions:
null

/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
