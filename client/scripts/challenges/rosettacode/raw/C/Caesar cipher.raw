Caesar cipher

{{task|Encryption}}
[[Category:String manipulation]]


;Task:
Implement a [[wp:Caesar cipher|Caesar cipher]], both encoding and decoding. <br>
The key is an integer from 1 to 25. 

This cipher rotates (either towards left or right) the letters of the alphabet (A to Z). 

The encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).
<br>So key 2 encrypts "HI" to "JK", but key 20 encrypts "HI" to "BC". 

This simple "mono-alphabetic substitution cipher" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.

Caesar cipher is identical to [[Vigenère cipher]] with a key of length 1. <br>
Also, [[Rot-13]] is identical to Caesar cipher with key 13.


;Related tasks:
* [[Rot-13]]
* [[Substitution Cipher]]
* [[Vigenère Cipher/Cryptanalysis]]
<br><br>


=={{header|JavaScript}}==

===ES5===

<lang javascript>function caesar (text, shift) {
  return text.toUpperCase().replace(/[^A-Z]/g,'').replace(/[A-Z]/g, function(a) {
    return String.fromCharCode(65+(a.charCodeAt(0)-65+shift)%26);
  });
}

// Tests
var text = 'veni, vidi, vici';
for (var i = 0; i<26; i++) {
  console.log(i+': '+caesar(text,i));
}</lang>

{{output}}
<pre>
0: VENIVIDIVICI
1: WFOJWJEJWJDJ
2: XGPKXKFKXKEK
3: YHQLYLGLYLFL
...
</pre>

===ES6===

<lang javascript>var caesar = (text, shift) => text
  .toUpperCase()
  .replace(/[^A-Z]/g, '')
  .replace(/[A-Z]/g, a =>
    String.fromCharCode(65 + (a.charCodeAt(0) - 65 + shift) % 26));</lang>


Or, allowing encoding and decoding of both lower and upper case:

<lang JavaScript>((key, strPlain) => {

    // Int -> String -> String
    let caesar = (k, s) => s.split('')
        .map(c => tr(
            inRange(['a', 'z'], c) ? 'a' :
            inRange(['A', 'Z'], c) ? 'A' : 0,
            k, c
        ))
        .join('');

    // Int -> String -> String
    let unCaesar = (k, s) => caesar(26 - (k % 26), s);

    // Char -> Int -> Char -> Char
    let tr = (base, offset, char) =>
        base ? (
            String.fromCharCode(
                ord(base) + (
                    ord(char) - ord(base) + offset
                ) % 26
            )
        ) : char;

    // [a, a] -> a -> b
    let inRange = ([min, max], v) => !(v < min || v > max);

    // Char -> Int
    let ord = c => c.charCodeAt(0);

    // range :: Int -> Int -> [Int]
    let range = (m, n) =>
        Array.from({
            length: Math.floor(n - m) + 1
        }, (_, i) => m + i);

    // TEST
    let strCipher = caesar(key, strPlain),
        strDecode = unCaesar(key, strCipher);

    return [strCipher, ' -> ', strDecode];

})(114, 'Curio, Cesare venne, e vide e vinse ? ');</lang>

{{Out}}
<pre>Mebsy, Mockbo foxxo, o fsno o fsxco ? ,  -> , Curio, Cesare venne, e vide e vinse ?</pre>

