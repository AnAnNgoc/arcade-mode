Create an object at a given address

{{task|Basic Data Operations}}
{{basic data operation}}
In systems programing it is sometimes required to place language objects at specific memory locations, like I/O registers, hardware interrupt vectors etc.

<span class="rosetta__text--bold">Task</span>

Show how language objects can be allocated at a specific machine addresses.

Since most <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/OS]]es prohibit access to the physical memory if it is not mapped by the application, as an example, rather than a physical address, take the address of some existing object (using suitable [[Address Operations" title="OS]]es prohibit access to the physical memory if it is not mapped by the application, as an example, rather than a physical address, take the address of some existing object (using suitable [[Address Operations">address operations</a> if necessary). For example, create an integer object. Print the machine address of the object. Take the address of the object and create another integer object at this address. Print the value of this object to verify that it is same as one of the origin. Change the value of the origin and verify it again.


{{omit from|Modula-2}}

=={{Header|6502 Assembly}}==
In [[6502 Assembly]] memory is represented by either an 8-bit or a 16-bit address (i.e. $0000 - $FFFF). 8-bit address are reserved for the memory from $00 to $FF - known as zero page; access to this memory takes one less byte in the opcode and one less cycle to execute.

Data can be stored, one byte at a time, through the store instructions, for example to store data at $1900:
<lang 6502asm>        sta $1900
        stx $1901
        sty $1902</lang>

Storage can be indexed through the use of the X or Y registers:
<lang 6502asm>        ldx #54
.loop   sta $1900,X
        dex
        bne loop</lang>

It can also be stored via indirect indexed addressing (i.e. memory points to an address), using the Y register:
<lang 6502asm>        lda #0
        sta $70
        lda #$20
        sta $71
        ldy #0
        sta ($70),Y</lang>

Finally, it can be stored via indexed indirect addressing (i.e. read the address of memory from the table stored at the parameter), using the X register:
<lang 6502asm>        lda #0
        sta $70
        lda #$20
        sta $71
        ldx #0
        sta ($70,X)</lang>

It should be noted that on the 6502 processor hardware is normally memory mapped, so this is often used for manipulating hardware.

=={{Header|Ada}}==
In [[Ada]] object address can be specified using the address representation clause [http://www.adaic.org/standards/05rm/html/RM-13-3.html RM 13.3]:
<lang ada>
type IO_Port is mod 2**8; -- One byte
Device_Port : type IO_Port;
for Device_Port'Address use 16#FFFF_F000#;
</lang>
In the example above the address is specified constant. It is also possible to specify address dynamically as the following solution of the task does:
<lang ada>
with Ada.Text_IO;              use Ada.Text_IO;
with System.Storage_Elements;  use System.Storage_Elements;

procedure Test_Address is
   X : Integer := 123;
   Y : Integer;
   for Y'Address use X'Address;
begin
   Put_Line ("At address:" & Integer_Address'Image (To_Integer (Y'Address)));
   Put_Line (Integer'Image (Y));
   X := 456;
   Put_Line (Integer'Image (Y));
end Test_Address;
</lang>
Sample output:
<pre>
At address: 38207236
 123
 456
</pre>
=={{Header|Aikido}}==
Aikido doesn't support getting the address of a variable.  However, in the spirit of this task, it does support raw memory access using <code>peek</code> and <code>poke</code>.  These can be used on both an integer representing an address (64 bit) or a value obtained from calling <code>malloc</code>.
<lang aikido>

var portaddr = 0x80
var v = peek (portaddr, 1)   // 1 byte
v |= 0x40
poke (portaddr, v, 1) // 1 byte back again

var addr = malloc (16)
poke (addr, 1234, 4)
poke (addr+4, 0, 2)
poke (addr+6, 12, 2)

</lang>


