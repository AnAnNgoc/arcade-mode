
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Compiler/virtual machine interpreter
/// type: rosetta-code

/// categories:
/// ?

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// Virtual Machine Interpreter
/// <br>
/// A virtual machine implements a computer in software.
/// <br>
/// <br>
/// <br>
/// Write a virtual machine interpreter.  This interpreter should be able to run virtual
/// assembly language programs created via the <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/code_generator" title="Compiler/code_generator">task</a>. This is a
/// byte-coded, 32-bit word stack based virtual machine.
/// <br>
/// The program should read input from a file and/or stdin, and write output to a file and/or
/// stdout.
/// <br>
/// Input format:
/// <br>
/// Given the following program:
/// <br>
///  count = 1;
///  while (count < 10) {
///      print("count is: ", count, "\n");
///      count = count + 1;
///  }
/// <br>
/// The output from the <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/code_generator" title="Compiler/code_generator">Code generator</a> is a virtual assembly code program:
/// <br>
/// {| class="wikitable"
/// |-
/// ! Output from gen, input to VM
/// |-
/// <br>
/// | style="vertical-align:top" |
/// <b><pre>Datasize: 1 Strings: 2
/// "count is: "
/// "\n"
///     0 push  1
///     5 store [0]
///    10 fetch [0]
///    15 push  10
///    20 lt
///    21 jz     (43) 65
///    26 push  0
///    31 prts
///    32 fetch [0]
///    37 prti
///    38 push  1
///    43 prts
///    44 fetch [0]
///    49 push  1
///    54 add
///    55 store [0]
///    60 jmp    (-51) 10
///    65 halt</pre></b>
/// |}
/// <br>
/// The first line of the input specifies the datasize required and the number of constant
/// strings, in the order that they are reference via the code.
/// <br>
/// The data can be stored in a separate array, or the data can be stored at the beginning of
/// the stack.  Data is addressed starting at 0.  If there are 3 variables, the 3rd one if
/// referenced at address 2.
/// <br>
/// If there are one or more constant strings, they come next.  The code refers to these
/// strings by their index.  The index starts at 0.  So if there are 3 strings, and the code
/// wants to reference the 3rd string, 2 will be used.
/// <br>
/// Next comes the actual virtual assembly code.  The first number is the code address of that
/// instruction.  After that is the instruction mnemonic, followed by optional operands,
/// depending on the instruction.
/// <br>
/// Registers:
/// <br>
/// sp:
///     the stack pointer - points to the next top of stack.  The stack is a 32-bit integer
///     array.
/// <br>
/// pc:
///     the program counter - points to the current instruction to be performed.  The code is an
///     array of bytes.
/// <br>
/// Data:
///     data
///     string pool
/// <br>
/// Instructions:
/// <br>
/// Each instruction is one byte.  The following instructions also have a 32-bit integer
/// operand:
/// <br>
///  fetch [index]
/// <br>
/// where index is an index into the data array.
/// <br>
///  store [index]
/// <br>
/// where index is an index into the data array.
/// <br>
///  push n
/// <br>
/// where value is a 32-bit integer that will be pushed onto the stack.
/// <br>
///  jmp (n) addr
/// <br>
/// where (n) is a 32-bit integer specifying the distance between the current location and the
/// desired location.  addr is an unsigned value of the actual code address.
/// <br>
///  jz (n) addr
/// <br>
/// where (n) is a 32-bit integer specifying the distance between the current location and the
/// desired location.  addr is an unsigned value of the actual code address.
/// <br>
/// The following instructions do not have an operand.  They perform their operation directly
/// against the stack:
/// <br>
/// For the following instructions, the operation is performed against the top two entries in
/// the stack:
/// <br>
///  add
///  sub
///  mul
///  div
///  mod
///  lt
///  gt
///  le
///  ge
///  eq
///  ne
///  and
///  or
/// <br>
/// For the following instructions, the operation is performed against the top entry in the
/// stack:
/// <br>
///  neg
///  not
/// <br>
/// Print the word at stack top as a character.
/// <br>
///  prtc
/// <br>
/// Print the word at stack top as an integer.
/// <br>
///  prti
/// <br>
/// Stack top points to an index into the string pool.  Print that entry.
/// <br>
///  prts
/// <br>
/// Unconditional stop.
/// <br>
///  halt
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title"> A simple example virtual machine:</dt></dl>
/// <br>
/// <lang python>def run_vm(data_size)
///     int stack[data_size + 1000]
///     set stack[0..data_size - 1] to 0
///     int pc = 0
///     while True:
///         op = code[pc]
///         pc += 1
/// <br>
///         if op == FETCH:
///             stack.append(stack[bytes_to_int(code[pc:pc+word_size])[0]]);
///             pc += word_size
///         elif op == STORE:
///             stack[bytes_to_int(code[pc:pc+word_size])[0]] = stack.pop();
///             pc += word_size
///         elif op == PUSH:
///             stack.append(bytes_to_int(code[pc:pc+word_size])[0]);
///             pc += word_size
///         elif op == ADD:   stack[-2] += stack[-1]; stack.pop()
///         elif op == SUB:   stack[-2] -= stack[-1]; stack.pop()
///         elif op == MUL:   stack[-2] *= stack[-1]; stack.pop()
///         elif op == DIV:   stack[-2] /= stack[-1]; stack.pop()
///         elif op == MOD:   stack[-2] %= stack[-1]; stack.pop()
///         elif op == LT:    stack[-2] = stack[-2] <  stack[-1]; stack.pop()
///         elif op == GT:    stack[-2] = stack[-2] >  stack[-1]; stack.pop()
///         elif op == LE:    stack[-2] = stack[-2] <= stack[-1]; stack.pop()
///         elif op == GE:    stack[-2] = stack[-2] >= stack[-1]; stack.pop()
///         elif op == EQ:    stack[-2] = stack[-2] == stack[-1]; stack.pop()
///         elif op == NE:    stack[-2] = stack[-2] != stack[-1]; stack.pop()
///         elif op == AND:   stack[-2] = stack[-2] and stack[-1]; stack.pop()
///         elif op == OR:    stack[-2] = stack[-2] or  stack[-1]; stack.pop()
///         elif op == NEG:   stack[-1] = -stack[-1]
///         elif op == NOT:   stack[-1] = not stack[-1]
///         elif op == JMP:   pc += bytes_to_int(code[pc:pc+word_size])[0]
///         elif op == JZ:    if stack.pop() then pc += word_size else pc += bytes_to_int(code[pc:pc+word_size])[0]
///         elif op == PRTC:  print stack[-1] as a character; stack.pop()
///         elif op == PRTS:  print the constant string referred to by stack[-1]; stack.pop()
///         elif op == PRTI:  print stack[-1] as an integer; stack.pop()
///         elif op == HALT:  break</lang>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title"> Additional examples</dt></dl>
/// <br>
/// Your solution should pass all the test cases above and the additional tests found <span class="rosetta__text--bold"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/Sample_programs" title="Compiler/Sample_programs">Here</a></span>.
/// <br>
/// <br>
/// <br>
/// The C and Python versions can be considered reference implementations.
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Related Tasks</dt></dl>
/// <br>
/// <ul class="rosetta__unordered-list">
/// <li class="rosetta__list-item"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/lexical_analyzer" title="Compiler/lexical_analyzer">Lexical Analyzer task</a></li>
/// <li class="rosetta__list-item"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/syntax_analyzer" title="Compiler/syntax_analyzer">Syntax Analyzer task</a></li>
/// <li class="rosetta__list-item"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/code_generator" title="Compiler/code_generator">Code Generator task</a></li>
/// <li class="rosetta__list-item"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/AST_interpreter" title="Compiler/AST_interpreter">AST Interpreter task</a></li>
/// <br>
/// </ul>
/// <hr>
/// __TOC__
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:


/// rawSolutions:
null

/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
