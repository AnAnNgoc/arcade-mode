
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Compiler/AST interpreter
/// type: rosetta-code

/// categories:
/// ?

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// AST interpreter
/// <br>
/// An AST interpreter interprets an [https://en.wikipedia.org/wiki/Abstract_syntax_tree Abstract Syntax Tree (AST)]
/// produced by a <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/syntax_analyzer" title="Compiler/syntax_analyzer">Syntax Analyzer</a>.
/// <br>
/// <br>
/// <br>
/// Take the AST output from the Syntax analyzer <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/syntax_analyzer" title="Compiler/syntax_analyzer">task</a>, and interpret it as appropriate.
/// Refer to the <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/syntax_analyzer" title="Compiler/syntax_analyzer">Syntax analyzer task</a> for details of the AST.
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Loading the AST from the syntax analyzer is as simple as (pseudo code):</dt></dl>
/// <br>
/// <lang python>def load_ast()
///     line = readline()
///     # Each line has at least one token
///     line_list = tokenize the line, respecting double quotes
/// <br>
///     text = line_list[0] # first token is always the node type
/// <br>
///     if text == ";"   # a terminal node
///         return NULL
/// <br>
///     node_type = text # could convert to internal form if desired
/// <br>
///     # A line with two tokens is a leaf node
///     # Leaf nodes are: Identifier, Integer, String
///     # The 2nd token is the value
///     if len(line_list) > 1
///         return make_leaf(node_type, line_list[1])
/// <br>
///     left = load_ast()
///     right = load_ast()
///     return make_node(node_type, left, right)</lang>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title"> The interpreter algorithm is relatively simple:</dt></dl>
/// <br>
/// <lang python>interp(x)
///     if x == NULL return NULL
///     elif x.node_type == Integer return x.value converted to an integer
///     elif x.node_type == Ident   return the current value of variable x.value
///     elif x.node_type == String  return x.value
///     elif x.node_type == Assign
///                     globals[x.left.value] = interp(x.right)
///                     return NULL
///     elif x.node_type is a binary operator return interp(x.left) operator interp(x.right)
///     elif x.node_type is a unary operator, return return operator interp(x.left)
///     elif x.node_type ==  If
///                     if (interp(x.left)) then interp(x.right.left)
///                     else interp(x.right.right)
///                     return NULL
///     elif x.node_type == While
///                     while (interp(x.left)) do interp(x.right)
///                     return NULL
///     elif x.node_type == Prtc
///                     print interp(x.left) as a character, no newline
///                     return NULL
///     elif x.node_type == Prti
///                     print interp(x.left) as an integer, no newline
///                     return NULL
///     elif x.node_type == Prts
///                     print interp(x.left) as a string, respecting newlines ("\n")
///                     return NULL
///     elif x.node_type == Sequence
///                     interp(x.left)
///                     interp(x.right)
///                     return NULL
///     else
///         error("unknown node type")</lang>
/// <br>
/// Notes:
/// <br>
/// Because of the simple nature of our tiny language, Semantic analysis is not needed.
/// <br>
/// Your interpreter should use C like division semantics, for both division and modulus.  For division of positive operands, only the non-fractional portion of the result should be returned.  In other words, the result should be truncated towards 0.
/// <br>
/// This means, for instance, that 3 / 2 should result in 1.
/// <br>
/// For division when one of the operands is negative, the result should be truncated towards 0.
/// <br>
/// This means, for instance, that 3 / -2 should result in -1.
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title"> Test program</dt></dl>
/// <br>
/// {| class="wikitable"
/// |-
/// ! prime.t
/// ! lex &lt;prime.t  	&#124; parse &#124; interp
/// |-
/// | style="vertical-align:top" |
/// <lang c>/*
///  Simple prime number generator
///  */
/// count = 1;
/// n = 1;
/// limit = 100;
/// while (n < limit) {
///     k=3;
///     p=1;
///     n=n+2;
///     while ((k*k<=n) && (p)) {
///         p=n/k*k!=n;
///         k=k+2;
///     }
///     if (p) {
///         print(n, " is prime\n");
///         count = count + 1;
///     }
/// }
/// print("Total primes found: ", count, "\n"); </lang>
/// <br>
/// | style="vertical-align:top" |
/// <b><pre>
/// 3 is prime
/// 5 is prime
/// 7 is prime
/// 11 is prime
/// 13 is prime
/// 17 is prime
/// 19 is prime
/// 23 is prime
/// 29 is prime
/// 31 is prime
/// 37 is prime
/// 41 is prime
/// 43 is prime
/// 47 is prime
/// 53 is prime
/// 59 is prime
/// 61 is prime
/// 67 is prime
/// 71 is prime
/// 73 is prime
/// 79 is prime
/// 83 is prime
/// 89 is prime
/// 97 is prime
/// 101 is prime
/// Total primes found: 26
/// </pre></b>
/// <br>
/// |}
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title"> Additional examples</dt></dl>
/// <br>
/// Your solution should pass all the test cases above and the additional tests found <span class="rosetta__text--bold"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/Sample_programs" title="Compiler/Sample_programs">Here</a></span>.
/// <br>
/// <br>
/// <br>
/// The C and Python versions can be considered reference implementations.
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Related Tasks</dt></dl>
/// <br>
/// <ul class="rosetta__unordered-list">
/// <li class="rosetta__list-item"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/lexical_analyzer" title="Compiler/lexical_analyzer">Lexical Analyzer task</a></li>
/// <li class="rosetta__list-item"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/syntax_analyzer" title="Compiler/syntax_analyzer">Syntax Analyzer task</a></li>
/// <li class="rosetta__list-item"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/code_generator" title="Compiler/code_generator">Code Generator task</a></li>
/// <li class="rosetta__list-item"><a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/Compiler/virtual_machine_interpreter" title="Compiler/virtual_machine_interpreter">Virtual Machine Interpreter task</a></li>
/// <br>
/// </ul>
/// <hr>
/// __TOC__
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:


/// rawSolutions:
null

/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
