Checkpoint synchronization

{{task|Concurrency}}[[Category:Classic CS problems and programs]]{{requires|Concurrency}}
The checkpoint synchronization is a problem of synchronizing multiple <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/task]]s. Consider a workshop where several workers ([[task]]s) assembly details of some mechanism. When each of them completes his work they put the details together. There is no store, so a worker who finished its part first must wait for others before starting another one. Putting details together is the <span class="rosetta__text--italic">checkpoint</span> at which [[task]]s synchronize themselves before going their paths apart.

<span class="rosetta__text--bold">The task</span>

Implement checkpoint synchronization in your language.

Make sure that the solution is [[Race condition" title="task]]s. Consider a workshop where several workers ([[task]]s) assembly details of some mechanism. When each of them completes his work they put the details together. There is no store, so a worker who finished its part first must wait for others before starting another one. Putting details together is the <span class="rosetta__text--italic">checkpoint</span> at which [[task]]s synchronize themselves before going their paths apart.

<span class="rosetta__text--bold">The task</span>

Implement checkpoint synchronization in your language.

Make sure that the solution is [[Race condition">race condition</a>-free. Note that a straightforward solution based on <a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/event]]s is exposed to [[Race condition" title="event]]s is exposed to [[Race condition">race condition</a>. Let two [[task]]s A and B need to be synchronized at a checkpoint. Each signals its event (<span class="rosetta__text--italic">EA</span> and <span class="rosetta__text--italic">EB</span> correspondingly), then waits for the AND-combination of the events (<span class="rosetta__text--italic">EA</span>&<span class="rosetta__text--italic">EB</span>) and resets its event. Consider the following scenario: A signals <span class="rosetta__text--italic">EA</span> first and gets blocked waiting for <span class="rosetta__text--italic">EA</span>&<span class="rosetta__text--italic">EB</span>. Then B signals <span class="rosetta__text--italic">EB</span> and loses the processor. Then A is released (both events are signaled) and resets <span class="rosetta__text--italic">EA</span>. Now if B returns and enters waiting for <span class="rosetta__text--italic">EA</span>&<span class="rosetta__text--italic">EB</span>, it gets lost.

When a worker is ready it shall not continue before others finish. A typical implementation bug is when a worker is counted twice within one working cycle causing its premature completion. This happens when the quickest worker serves its cycle two times while the laziest one is lagging behind.

If you can, implement workers joining and leaving.


