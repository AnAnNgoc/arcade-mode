Compare sorting algorithms' performance

{{task|Sorting}}
Measure a relative performance of sorting algorithms implementations.

Plot <span class="rosetta__text--bold">execution time vs. input sequence length</span> dependencies for various implementation of sorting algorithm and different input sequence types (<a class="rosetta__link--rosetta" href="http://rosettacode.org/wiki/#Figures: log2( time in microseconds ) vs. log2( sequence length )" title="#Figures: log2( time in microseconds ) vs. log2( sequence length )">example figures</a>). 

Consider three type of input sequences:
* ones: sequence of all <span class="rosetta__text--italic">1</span>'s. Example: {1, 1, 1, 1, 1}
* range: ascending sequence, i.e. already sorted. Example: {1, 2, 3, 10, 15}
* shuffled range: sequence with elements randomly distributed. Example: {5, 3, 9, 6, 8}

Consider at least two different sorting functions (different algorithms or/and different implementation of the same algorithm).
For example, consider [[Bubble Sort]], [[Insertion sort]], [[Quicksort]] or/and implementations of Quicksort with different pivot selection mechanisms. Where possible, use existing implementations.

Preliminary subtask:
* [[Bubble Sort]], [[Insertion sort]], [[Quicksort]], [[Radix sort]], [[Shell sort]]
* [[Query Performance]]
* [[Write float arrays to a text file]]
* [[Plot x, y arrays]]
* [[Polynomial Fitting]]

General steps:
# Define sorting routines to be considered.
# Define appropriate sequence generators and write timings.
# Plot timings.
# What conclusions about relative performance of the sorting routines could be made based on the plots?


