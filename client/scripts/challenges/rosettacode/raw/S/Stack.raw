
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Stack
/// type: rosetta-code

/// categories:
/// Encyclopedia
/// Classic CS problems and programs

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// <br>
/// <br>
/// <br>
/// A <span class="rosetta__text--bold">stack</span> is a container of elements with &nbsp; <big><u>l</u>ast <u>i</u>n, <u>f</u>irst <u>o</u>ut</big>  &nbsp; access policy. &nbsp; Sometimes it also called <span class="rosetta__text--bold">LIFO</span>. 
/// <br>
/// The stack is accessed through its <span class="rosetta__text--bold">top</span>. 
/// <br>
/// The basic stack operations are:
/// <br>
/// <ul class="rosetta__unordered-list"><li class="rosetta__list-item--unordered">&nbsp; <span class="rosetta__text--italic">push</span> &nbsp; stores a new element onto the stack top;</li>
/// <li class="rosetta__list-item--unordered">&nbsp; <span class="rosetta__text--italic">pop</span> &nbsp; returns the last pushed stack element, while removing it from the stack;</li>
/// <li class="rosetta__list-item--unordered">&nbsp; <span class="rosetta__text--italic">empty</span> &nbsp; tests if the stack contains no elements.</li></ul>
/// <br>
/// Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):
/// <br>
/// <ul class="rosetta__unordered-list"><li class="rosetta__list-item--unordered">&nbsp; <span class="rosetta__text--italic">top</span> &nbsp; (sometimes called <span class="rosetta__text--italic">peek</span> to keep with the <span class="rosetta__text--italic">p</span> theme) returns the topmost element without modifying the stack.</li></ul>
/// <br>
/// Stacks allow a very simple hardware implementation.
///  
/// They are common in almost all processors.
///  
/// In programming, stacks are also very popular for their way (<span class="rosetta__text--bold">LIFO</span>) of resource management, usually memory. 
/// <br>
/// Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks). 
/// <br>
/// This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework. 
/// <br>
/// See <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Stack_automaton" title="wp: Stack_automaton">stack machine</a>. 
/// <br>
/// Many algorithms in pattern matching, compiler construction (e.g. <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Recursive_descent" title="wp: Recursive_descent">recursive descent parsers</a>), and machine learning (e.g. based on <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Tree_traversal" title="wp: Tree_traversal">tree traversal</a>) have a natural representation in terms of stacks.
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Task:</dt></dl>
/// Create a stack supporting the basic operations: push, pop, empty.
/// <br>
/// <br>
/// <br>
/// <br><br>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:
var stack = [];
stack.push(1)
stack.push(2,3);
print(stack.pop());   // 3
print(stack.length);   // 2, stack empty if 0

/// rawSolutions:
=={{header|JavaScript}}==
The built-in Array class already has stack primitives.
<lang javascript>var stack = [];
stack.push(1)
stack.push(2,3);
print(stack.pop());   // 3
print(stack.length);   // 2, stack empty if 0</lang>
Here's a constructor that wraps the array:
<lang javascript>function Stack() {
    this.data = new Array();

    this.push  = function(element) {this.data.push(element)}
    this.pop   = function() {return this.data.pop()}
    this.empty = function() {return this.data.length == 0}
    this.peek  = function() {return this.data[this.data.length - 1]}
}</lang>
Here's an example using the revealing module pattern instead of prototypes.
<lang javascript>
function makeStack() {
  var stack = [];

  var popStack = function () {
    return stack.pop();
  };
  var pushStack = function () {
    return stack.push.apply(stack, arguments);
  };
  var isEmpty = function () {
    return stack.length === 0;
  };
  var peekStack = function () {
    return stack[stack.length-1];
  };
    
  return {
    pop: popStack,
    push: pushStack,
    isEmpty: isEmpty,
    peek: peekStack,
    top: peekStack
  };
}
</lang>



/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
