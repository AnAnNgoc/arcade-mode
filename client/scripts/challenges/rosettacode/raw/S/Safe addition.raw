
/* eslint spaced-comment: 0 */
/* eslint no-redeclare: 0 */
/* eslint no-undef: 0 */
/* eslint no-unused-vars: 0 */

const assert = require('chai').assert;

/// title: Safe addition
/// type: rosetta-code

/// categories:
/// ?

/// difficulty: ?

/// benchmark:
replaceWithActualFunctionHere;

/// description:
/// <br>
/// <br>
/// Implementation of &nbsp; <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Interval_arithmetic" title="wp: Interval_arithmetic">interval arithmetic</a> &nbsp; and more generally fuzzy number arithmetic require operations that yield safe upper and lower bounds of the exact result. 
/// <br>
/// For example, for an addition, it is the operations &nbsp; <big> +&uarr; </big> &nbsp; and &nbsp; <big> +&darr; </big> &nbsp; defined as: &nbsp; <big> <span class="rosetta__text--italic">a</span> +&darr; <span class="rosetta__text--italic">b</span> &le; <span class="rosetta__text--italic">a</span> + <span class="rosetta__text--italic">b</span> &le; <span class="rosetta__text--italic">a</span> +&uarr; <span class="rosetta__text--italic">b</span>. </big>  
/// <br>
/// Additionally it is desired that the width of the interval &nbsp; <big> (<span class="rosetta__text--italic">a</span> +&uarr; <span class="rosetta__text--italic">b</span>) - (<span class="rosetta__text--italic">a</span> +&darr; <span class="rosetta__text--italic">b</span>) </big>  &nbsp; would be about the machine epsilon after removing the exponent part. 
/// <br>
/// Differently to the standard floating-point arithmetic, safe interval arithmetic is <span class="rosetta__text--bold">accurate</span> (but still imprecise). 
/// <br>
/// I.E.: &nbsp; the result of each defined operation contains (though does not identify) the exact mathematical outcome.
/// <br>
/// Usually a &nbsp; <a class="rosetta__link--wiki" href="https://en.wikipedia.org/wiki/Floating_Point_Unit" title="wp: Floating_Point_Unit">FPU's</a> &nbsp; have machine &nbsp; <big> +,-,*,/ </big> &nbsp; operations accurate within the machine precision. 
/// <br>
/// To illustrate it, let us consider a machine with decimal floating-point arithmetic that has the precision is <span class="rosetta__text--bold">3</span> decimal points. 
/// <br>
/// If the result of the machine addition is &nbsp; <big> 1.23, </big> &nbsp; then the exact mathematical result is within the interval &nbsp; <big> ]1.22, 1.24[. </big> 
/// <br>
/// When the machine rounds towards zero, then the exact result is within &nbsp; <big> [1.23,1.24[. </big> &nbsp; This is the basis for an implementation of safe addition.
/// <br>
/// <br>
/// <dl class="rosetta__description-list"><dt class="rosetta__description-title">Task;</dt></dl>
/// Show how &nbsp; <big> +&darr; </big> &nbsp; and &nbsp; <big> +&uarr; </big> &nbsp; can be implemented in your language using the standard floating-point type. 
/// <br>
/// Define an interval type based on the standard floating-point one, &nbsp; and implement an interval-valued addition of two floating-point numbers considering them exact, in short an operation that yields the interval &nbsp; <big> [<span class="rosetta__text--italic">a</span> +&darr; <span class="rosetta__text--italic">b</span>, <span class="rosetta__text--italic">a</span> +&uarr; <span class="rosetta__text--italic">b</span>]. </big> 
/// <br><br>
/// <br>
/// <br>

/// challengeSeed:
function replaceMe (foo) {
  // Good luck!
  return true;
}

/// solutions:


/// rawSolutions:
null

/// tail:
const replaceThis = 3;

/// tests:
assert(typeof replaceMe === 'function', 'message: <code>replaceMe</code> is a function.');
