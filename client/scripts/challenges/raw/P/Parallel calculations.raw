Parallel calculations

{{task|Control Structures}}

Many programming languages allow you to specify computations to be run in parallel. 
While [[Concurrent computing]] is focused on concurrency, 
the purpose of this task is to distribute time-consuming calculations 
on as many CPUs as possible.

Assume we have a collection of numbers, and want to find the one 
with the largest minimal prime factor 
(that is, the one that contains relatively large factors). 
To speed up the search, the factorization should be done 
in parallel using separate threads or processes, 
to take advantage of multi-core CPUs.

Show how this can be formulated in your language. 
Parallelize the factorization of those numbers, 
then search the returned list of numbers and factors 
for the largest minimal factor, 
and return that number and its prime factors.

For the prime number decomposition 
you may use the solution of the [[Prime decomposition]] task.

{{omit from|J}}


=={{header|JavaScript}}==
This code demonstrates Web Workers. This should work on current versions of Firefox, Safari, Chrome and Opera.

This first portion should be placed in a file called "parallel_worker.js". This file contains the logic used by every worker created.
<lang javascript>
var onmessage = function(event) {   
    postMessage({"n" : event.data.n,
                 "factors" : factor(event.data.n),
                 "id" : event.data.id});
};

function factor(n) {
    var factors = [];
    for(p = 2; p <= n; p++) {
        if((n % p) == 0) {
            factors[factors.length] = p;
            n /= p;
        }
    }
    return factors;
}
</lang>

For each number a worker is spawned. Once the final worker completes its task (worker_count is reduced to 0), the reduce function is called to determine which number is the answer.
<lang javascript>
var numbers = [12757923, 12878611, 12757923, 15808973, 15780709, 197622519];
var workers = [];
var worker_count = 0;

var results = [];

for(var i = 0; i < numbers.length; i++) {
    worker_count++;
    workers[i] = new Worker("parallel_worker.js");
    workers[i].onmessage = accumulate;
    workers[i].postMessage({n: numbers[i], id: i});
}

function accumulate(event) {
    n = event.data.n;
    factors = event.data.factors;
    id = event.data.id;
    console.log(n + " : " + factors);
    results[id] = {n:n, factors:factors};
    // Cleanup - kill the worker and countdown until all work is done
    workers[id].terminate();
    worker_count--;
    if(worker_count == 0)
	reduce();
}

function reduce() {
    answer = 0;
    for(i = 1; i < results.length; i++) {
	min = results[i].factors[0];
	largest_min = results[answer].factors[0];
	if(min > largest_min)
	    answer = i;
    }
    n = results[answer].n;
    factors = results[answer].factors;
    console.log("The number with the relatively largest factors is: " + n + " : " + factors);
}
</lang>

